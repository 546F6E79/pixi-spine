{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/ShearTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TransformConstraint.js","src/SpineRuntime/TransformConstraintData.js","src/SpineRuntime/TransformConstraintTimeline.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/WeightedMeshAttachment.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/imageLoaderAdapter.js","src/loaders/index.js","src/loaders/syncImageLoaderAdapter.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","spine","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders",2,"Animation","name","timelines","duration","this","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil",3,"TrackEntry","AnimationState","stateData","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","hasAnimationByName","getCurrent","./TrackEntry",4,"AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty",5,"AtlasReader","AtlasPage","AtlasRegion","syncImageLoaderAdapter","Atlas","atlasText","loaderFunction","callback","pages","regions","addSpineAtlas","addTexture","texture","page","rendererObject","baseTexture","width","realWidth","height","realHeight","format","minFilter","magFilter","uWrap","TextureWrap","clampToEdge","vWrap","region","addTextureHash","textures","stripExtension","indexOf","substr","lastIndexOf","iterateParser","line","reader","readLine","self","trim","readTuple","tuple","parseInt","Format","TextureFilter","direction","readValue","repeat","hasLoaded","console","log","rotate","x","y","resolution","frame","Rectangle","splits","pads","originalWidth","originalHeight","offsetX","offsetY","orig","VERSION","Texture","frame2","crop","clone","_updateUvs","baseUrl","crossOrigin","texturesLoading","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","../loaders/syncImageLoaderAdapter.js","./AtlasPage","./AtlasReader","./AtlasRegion",6,"RegionAttachment","MeshAttachment","WeightedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","v","u2","v2","regionOffsetX","regionOffsetY","spineOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","newWeightedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./WeightedMeshAttachment",7,8,"text","lines","split","value","replace","colon","substring","lastMatch","comma",9,"Object","defineProperties","get","tex","_uvs","x0","y0","x2","y2","warn","pixiOffsetY",10,"Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves",11,"AttachmentType","boundingbox","mesh","weightedmesh","skinnedmesh","linkedmesh","weightedlinkedmesh",12,"Bone","boneData","parent","matrix","Matrix","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","shearX","shearY","flipX","flipY","worldSignX","worldSignY","updateWorldTransform","rotationX","rotationY","la","cos","degRad","lb","lc","sin","ld","m","c","b","d","tx","ty","signum","pa","pb","pc","pd","inheritRotation","inheritScale","temp","psx","psy","za","zb","zc","zd","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldX","worldY",13,"BoneData",14,"vertices","type","computeWorldVertices","bone","worldVertices","m00","m01","m10","m11","px","py","./AttachmentType",15,"ColorTimeline","g","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot",16,"setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY",17,"DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex",18,"Event","intValue","floatValue","stringValue",19,"EventData",20,"EventTimeline",21,"FfdTimeline","frameVertices","slotAttachment","applyFFD","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev",22,"IkConstraint","bendDirection","bones","findBone","apply1","apply2","targetX","targetY","parentRotation","child","bendDir","offset1","offset2","sign2","csx","cy","pp","ppm","wx","wy","a1","a2","l1","l2","outer","abs","acos","ta","aa","bb","ll","dd","c0","c1","c2","q","r0","r1","minAngle","minDist","Infinity","minX","minY","maxAngle","maxDist","maxX","maxY","dist","PI","angle","offset",23,"IkConstraintData",24,"IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix",25,"parentMesh","inheritFFD","uvs","regionUVs","triangles","hullLength","edges","Float32Array","w1","h1","w2","h2","x1","x3","y1","y3","verticesCount","vx","vy","sourceAttachment","setParentMesh","hackRegion","newRegion","oldRegion",26,"updateOffset","regionScaleX","regionScaleY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices","size",27,"RotateTimeline","boneIndex","amount","prevFrameValue",28,"ScaleTimeline","prevFrameX","prevFrameY",29,"ShearTimeline",30,"Slot","Skeleton","slotData","transformConstraints","TransformConstraint","boneCache","updateCache","ikConstraintsCount","transformConstraintsCount","j","setBonesToSetupPose","setSlotsToSetupPose","constraint","rotateMix","translateMix","scaleMix","shearMix","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","constraintName","constraints","findTransformConstraint","./Bone","./IkConstraint","./Slot",31,"SkeletonBounds","polygonPool","polygons","boundingBoxes","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","../SpineRuntime",32,"SkeletonData","skins","animations","version","hash","findEvent","eventName",33,"LinkedMesh","TransformConstraintData","SlotData","Skin","TranslateTimeline","TransformConstraintTimeline","SkeletonJsonParser","attachmentLoader","AtlasAttachmentLoader","linkedMeshes","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","transform","transformMap","transformData","offsetRotation","offsetScaleX","offsetScaleY","offsetShearY","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","linkedMesh","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","ikConstraintName","transformConstraintName","transformConstraint","transformConstraintIndex","ffd","meshMap","meshName","isMesh","verticesValue","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./ShearTimeline","./SkeletonData","./Skin","./SlotData","./TransformConstraintData","./TransformConstraintTimeline","./TranslateTimeline",34,"attachments","oldSkin",35,"_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas",36,"multiply","BLEND_MODES","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL",37,38,"tempVec","bm","tm","bs","ts","by",39,40,"shareMix","translate","shear",41,42,"regionU2","regionU","regionV2","regionV","weight","skeletonBones","w",43,"./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js","./TransformConstraint",44,45,"spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","SlotContainerUpdateTransformV3","pt","worldTransform","wt","lt","localTransform","worldAlpha","_currentBounds","atlasParser","fromAtlas","resourceName","AnimCache","create","constructor","globalAutoUpdate","updateTransform","autoUpdateTransform","set","dt","children","undefined","visible","sprites","matrix2d","_dirtyVersion","isStatic","operMode","TransformManual","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","copy","displayObjectUpdateTransform","tint","utils","rgb2hex","meshes","dirty","Date","now","timeDelta","descriptor","Sprite","anchor","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","hackTextureBySlotIndex","indexDirty","hackTextureBySlotName","../loaders/atlasParser",46,"Loader","addPixiMiddleware","loader","use","./atlasParser",47,"Resource","imageLoaderAdapter","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","enableCaching","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","add","res","xhr","responseText","./imageLoaderAdapter",48,"namePrefix",49,"./Loader","./syncImageLoaderAdapter",50,"BaseTexture","fromImage"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n\n},{\"./Spine\":45,\"./SpineRuntime\":43,\"./loaders\":49}],2:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n\n},{\"../SpineUtil\":44}],3:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /**\r\n     * Returns true if animation exists in skeleton data\r\n     * @param animationName\r\n     * @returns {boolean}\r\n     */\r\n    hasAnimationByName: function (animationName)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n\n},{\"../SpineUtil\":44,\"./TrackEntry\":37}],4:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n\n},{\"../SpineUtil\":44}],5:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function(atlasText, loaderFunction, callback) {\r\n    this.pages = [];\r\n    this.regions = [];\r\n    if (typeof atlasText === \"string\") {\r\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\r\n    }\r\n};\r\n\r\nspine.Atlas.prototype = {\r\n    addTexture: function(name, texture) {\r\n        var pages = this.pages;\r\n        var page = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].rendererObject === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new spine.AtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.rendererObject = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.format = 'RGBA8888';\r\n            page.minFilter = page.magFilter = \"Nearest\";\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new spine.AtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    },\r\n    addTextureHash: function(textures, stripExtension) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    },\r\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\r\n    {\r\n        //TODO: remove this legacy later\r\n        if (typeof loaderFunction !== \"function\") {\r\n            //old syntax\r\n            var baseUrl = loaderFunction;\r\n            var crossOrigin = callback;\r\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n            callback = null;\r\n        }\r\n\r\n        this.texturesLoading = 0;\r\n\r\n        var self = this;\r\n\r\n        var reader = new spine.AtlasReader(atlasText);\r\n        var tuple = [];\r\n        tuple.length = 4;\r\n        var page = null;\r\n\r\n        iterateParser();\r\n\r\n        function iterateParser() {\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line === null) {\r\n                    return callback && callback(self);\r\n                }\r\n                line = reader.trim(line);\r\n                if (!line.length)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new spine.AtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    } else {\r\n                        //old format, detect width and height by texture\r\n                    }\r\n                    page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                    loaderFunction(line, function (texture) {\r\n                        page.rendererObject = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        self.pages.push(page);\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    var region = new spine.AtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n\r\n                    var resolution = page.rendererObject.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    var originalWidth = parseInt(tuple[0]) / resolution;\r\n                    var originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    var offsetX = parseInt(tuple[0]) / resolution;\r\n                    var offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    self.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.texture._updateUvs();\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n\n},{\"../SpineUtil\":44,\"../loaders/syncImageLoaderAdapter.js\":50,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9}],6:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.spineOffsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.WeightedMeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n\n},{\"../SpineUtil\":44,\"./BoundingBoxAttachment\":14,\"./MeshAttachment\":25,\"./RegionAttachment\":26,\"./WeightedMeshAttachment\":42}],7:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n\n},{\"../SpineUtil\":44}],8:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n\n},{\"../SpineUtil\":44}],9:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AtlasRegion = function ()\n{};\nspine.AtlasRegion.prototype = {\n    name: null,\n    /**\n     * @member {PIXI.Texture}\n     */\n    texture: null,\n\n    /**\n     * @member {PIXI.spine.Spine.AtlasPage}\n     */\n    page: null,\n    index: 0,\n    splits: null,\n    pads: null\n};\n\nObject.defineProperties(spine.AtlasRegion.prototype, {\n    x: {\n        get: function() {\n            return this.texture.frame.x;\n        }\n    },\n    y: {\n        get: function() {\n            return this.texture.frame.y;\n        }\n    },\n    width: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    height: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n    },\n    u: {\n        get: function() {\n            return this.texture._uvs.x0;\n        }\n    },\n    v: {\n        get: function() {\n            return this.texture._uvs.y0;\n        }\n    },\n    u2: {\n        get: function() {\n            return this.texture._uvs.x2;\n        }\n    },\n    v2: {\n        get: function() {\n            return this.texture._uvs.y2;\n        }\n    },\n    rotate: {\n        get: function() {\n            return !!this.texture.rotate;\n        }\n    },\n    offsetX: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n    },\n    offsetY: {\n        get: function() {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n    },\n    pixiOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n    },\n    spineOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n    },  \n    originalWidth: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return tex.crop.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    originalHeight: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return tex.crop.height;\n            }\n            return tex.orig.height;\n        }\n    }\n});\n\nmodule.exports = spine.AtlasRegion;\n\n\n},{\"../SpineUtil\":44}],10:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],11:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n\n},{\"../SpineUtil\":44}],12:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    update: function() {\n        this.rotationIK = this.rotation;\n        this.updateWorldTransform();\n    },\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n        var rotationX = rotation + this.shearX;\n        var rotationY = rotation + 90 + this.shearY;\n\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\n                    var temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    var r = parent.rotationIK;\n                    cos = Math.cos(r * spine.degRad);\n                    sin = Math.sin(r * spine.degRad);\n                    var psx = parent.scaleX, psy = parent.scaleY;\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                    temp = pa * za + pb * zc;\n                    pb = pa * zb + pb * zd;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pc * zb + pd * zd;\n                    pc = temp;\n\n                    if (psx < 0) {\n                        r = -r;\n                    } else {\n                        sin = -sin;\n                    }\n                    temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n\n},{\"../SpineUtil\":44}],13:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n\n},{\"../SpineUtil\":44}],14:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],15:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],16:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n\n},{\"../SpineUtil\":44}],17:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2}],18:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n\n},{\"../SpineUtil\":44}],19:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n\n},{\"../SpineUtil\":44}],20:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2}],21:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        var slotAttachment = slot.attachment;\r\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],22:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n    bone.updateWorldTransform();\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = Math.PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    parent.updateWorldTransform();\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n    child.updateWorldTransform();\n};\nmodule.exports = spine.IkConstraint;\n\n\n},{\"../SpineUtil\":44}],23:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n\n},{\"../SpineUtil\":44}],24:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],25:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n        }\n        this.rendererObject = newRegion;\n        this.updateUVs();\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],26:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n            this.oldRegion.size = { width: this.width, height: this.height };\n        }\n        this.rendererObject = newRegion;\n        if (newRegion.size) {\n            this.width = newRegion.size.width;\n            this.height = newRegion.size.height;\n        }\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],27:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],28:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],29:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ShearTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ShearTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ShearTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],30:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.transformConstraints = [];\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n        var transformConstraints = this.transformConstraints;\n        var transformConstraintsCount = transformConstraints.length;\n\n        var boneCache = this.boneCache;\n        boneCache.length = 0;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            boneCache.push(bone);\n            for (var j=0; j < transformConstraintsCount; j++) {\n                if (transformConstraints[j].bone == bone) {\n                    boneCache.push(transformConstraints[j]);\n                }\n            }\n            for (var j=0; j < ikConstraintsCount; j++) {\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\n                    boneCache.push(ikConstraints[j]);\n                    break;\n                }\n            }\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var boneCache = this.boneCache;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].update();\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\n        {\n            var constraint = transformConstraints[i];\n            var data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n\n},{\"../SpineUtil\":44,\"./Bone\":12,\"./IkConstraint\":22,\"./Slot\":35}],31:[function(require,module,exports){\nvar spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n\n},{\"../SpineRuntime\":43,\"./AttachmentType\":11}],32:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n    this.transformConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n    /** @return May be null. */\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n};\nmodule.exports = spine.SkeletonData;\n\n\n},{\"../SpineUtil\":44}],33:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    if (attachmentLoader.pages) {\n        //its an atlas, we have to wrap it\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\n    } else {\n        //got a loader, thats good\n        this.attachmentLoader = attachmentLoader;\n    }\n    if (!attachmentLoader.newRegionAttachment) {\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\n    }\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        var scale = this.scale;\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.shearX = boneMap[\"shearX\"] || 0;\n            boneData.shearY = boneMap[\"shearY\"] || 0;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        var transform = root[\"transform\"];\n        if (transform) {\n            for (var i = 0, n = transform.length; i<n; i++) {\n                var transformMap = transform[i];\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\n\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\n\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\n\n                skeletonData.transformConstraints.push(transformData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                mesh.updateUVs();\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                var uvs = this.getFloatArray(map, \"uvs\", 1);\n                var vertices = this.getFloatArray(map, \"vertices\", 1);\n                var weights = [];\n                var bones = [];\n                for (var i = 0, n = vertices.length; i < n; )\n                {\n                    var boneCount = vertices[i++] | 0;\n                    bones[bones.length] = boneCount;\n                    for (var nn = i + boneCount * 4; i < nn; )\n                    {\n                        bones[bones.length] = vertices[i];\n                        weights[weights.length] = vertices[i + 1] * scale;\n                        weights[weights.length] = vertices[i + 2] * scale;\n                        weights[weights.length] = vertices[i + 3];\n                        i += 4;\n                    }\n                }\n                mesh.bones = bones;\n                mesh.weights = weights;\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = uvs;\n                mesh.updateUVs();\n\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") {\n                        timeline = new spine.ScaleTimeline(values.length);\n                    } else if (timelineName == \"shear\") {\n                        timeline = new spine.ShearTimeline(values.length);\n                    }\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var transformMap = map[\"transform\"];\n        for (var transformConstraintName in transformMap)\n        {\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\n            var values = transformMap[transformConstraintName];\n            var timeline = new spine.TransformConstraintTimeline(values.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./BoneData\":13,\"./ColorTimeline\":15,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./IkConstraintData\":23,\"./IkConstraintTimeline\":24,\"./RotateTimeline\":27,\"./ScaleTimeline\":28,\"./ShearTimeline\":29,\"./SkeletonData\":32,\"./Skin\":34,\"./SlotData\":36,\"./TransformConstraintData\":39,\"./TransformConstraintTimeline\":40,\"./TranslateTimeline\":41}],34:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n\n},{\"../SpineUtil\":44}],35:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n\n},{\"../SpineUtil\":44}],36:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n\n},{\"../SpineUtil\":44}],37:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n\n},{\"../SpineUtil\":44}],38:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nvar tempVec = [0, 0];\nspine.TransformConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.translateMix = data.translateMix;\n    this.rotateMix = data.rotateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.offsetX = data.offsetX;\n    this.offsetY = data.offsetY;\n    this.offsetScaleX = data.offsetScaleX;\n    this.offsetScaleY = data.offsetScaleY;\n    this.offsetShearY = data.offsetShearY;\n\n    this.bone = skeleton.findBone(data.bone.name);\n    this.target = skeleton.findBone(data.target.name);\n};\n\nspine.TransformConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var bm = this.bone.matrix;\n        var tm = this.target.matrix;\n\n        var rotateMix = this.rotateMix;\n        if (rotateMix > 0) {\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r *= rotateMix;\n            var cos = Math.cos(r), sin = Math.sin(r);\n            bm.a = cos * a - sin * c;\n            bm.c = cos * b - sin * d;\n            bm.b = sin * a + cos * c;\n            bm.d = sin * b + cos * d;\n        }\n\n        var scaleMix = this.rotateMix;\n        if (scaleMix > 0) {\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\n            bm.a *= s;\n            bm.b *= s;\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\n            bm.c *= s;\n            bm.d *= s;\n        }\n\n        var shearMix = this.shearMix;\n        if (shearMix > 0) {\n            var b = bm.c, d = bm.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            bm.c = Math.cos(r) * s;\n            bm.d = Math.sin(r) * s;\n        }\n\n        var translateMix = this.translateMix;\n        if (translateMix > 0) {\n            tempVec[0] = this.offsetX;\n            tempVec[1] = this.offsetY;\n            this.target.localToWorld(tempVec);\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\n        }\n    }\n};\n\nmodule.exports = spine.TransformConstraint;\n\n},{\"../SpineUtil\":44}],39:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.TransformConstraintData = function (name)\n{\n    this.name = name;\n    this.bone = null;\n};\nspine.TransformConstraintData.prototype = {\n    target: null,\n    rotateMix: 1,\n    translateMix: 1,\n    scaleMix: 1,\n    shearMix: 1,\n    offsetRotation: 0,\n    offsetX: 0,\n    offsetY: 0,\n    offsetScaleX: 0,\n    offsetScaleY: 0,\n    offsetShearY: 0\n};\nmodule.exports = spine.TransformConstraintData;\n\n\n},{\"../SpineUtil\":44}],40:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TransformConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TransformConstraintTimeline.prototype = {\n    transformConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = rotateMix;\n        this.frames[frameIndex + 2] = translateMix;\n        this.frames[frameIndex + 3] = scaleMix;\n        this.frames[frameIndex + 4] = shareMix;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - 5])\n        { // Time is after last frame.\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frame = spine.Animation.binarySearch(frames, time, 5);\n        var frameTime = frames[frame];\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\n\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\n    }\n};\nmodule.exports = spine.TransformConstraintTimeline;\n\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],41:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],42:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.WeightedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.WeightedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.weightedmesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, vx, vy, weight;\r\n        var m;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.weights = parentMesh.weights;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.WeightedMeshAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],43:[function(require,module,exports){\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.TransformConstraint = require('./TransformConstraint');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./AnimationState\":3,\"./AnimationStateData\":4,\"./Atlas\":5,\"./AtlasAttachmentParser\":6,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./Bone\":12,\"./BoneData\":13,\"./BoundingBoxAttachment\":14,\"./ColorTimeline\":15,\"./Curves\":16,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./IkConstraint\":22,\"./IkConstraintData\":23,\"./IkConstraintTimeline\":24,\"./MeshAttachment\":25,\"./RegionAttachment\":26,\"./RotateTimeline\":27,\"./ScaleTimeline\":28,\"./ShearTimeline\":29,\"./Skeleton\":30,\"./SkeletonBounds\":31,\"./SkeletonData\":32,\"./SkeletonJsonParser\":33,\"./Skin.js\":34,\"./Slot\":35,\"./SlotData\":36,\"./TrackEntry\":37,\"./TransformConstraint\":38,\"./TransformConstraintData\":39,\"./TransformConstraintTimeline\":40,\"./TranslateTimeline\":41,\"./WeightedMeshAttachment\":42}],44:[function(require,module,exports){\nmodule.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\n    signum: function(x) {\n        if (x>0) return 1;\n        if (x<0) return -1;\n        return 0;\n    }\n};\n\n\n},{}],45:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                var transform = slotContainer.transform;\n                var lt;\n                if (slotContainer.transform.matrix2d) {\n                    //gameofbombs pixi fork\n                    lt = transform.matrix2d;\n                    transform._dirtyVersion++;\n                    transform.version = transform._dirtyVersion;\n                    transform.isStatic = true;\n                    transform.operMode = 0;\n                } else\n                if (PIXI.TransformManual) {\n                    //PIXI v4.0\n                    if (transform.position) {\n                        transform = new PIXI.TransformManual();\n                        slotContainer.transform = transform;\n                    }\n                    lt = transform.localTransform;\n                } else {\n                    //PIXI v4.0rc\n                    if (!transform._dirtyLocal) {\n                        transform = new PIXI.TransformStatic();\n                        slotContainer.transform = transform;\n                    }\n                    lt = transform.localTransform;\n                    transform._dirtyParentVersion = -1;\n                    transform._dirtyLocal = 1;\n                    transform._versionLocal = 1;\n                }\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r * attachment.r, slot.g * attachment.g, slot.b * attachment.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n            if (PIXI.VERSION[0] !== '3') {\n                // PIXI version 4\n                slot.currentMesh.dirty = true;\n            }\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var texture = descriptor.texture;\n    var sprite = new PIXI.Sprite(texture);\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\n    sprite.rotation = attachment.rotation * spine.degRad;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {\n    var slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n        return false;\n    }\n    var attachment = slot.attachment;\n    if (!attachment || !attachment.hackRegion) {\n        return false;\n    }\n    var region = null;\n    if (texture) {\n        region = new spine.AtlasRegion();\n        region.texture = texture;\n        region.size = size;\n    }\n\n    attachment.hackRegion(region);\n    var descriptor = attachment.rendererObject;\n    if (slot.currentSprite) {\n        var sprite = slot.currentSprite;\n        sprite.texture = descriptor.texture;\n        sprite.scale.x = attachment.width / descriptor.originalWidth;\n        sprite.scale.y = - attachment.height / descriptor.originalHeight;\n    }\n    if (slot.currentMesh) {\n        var mesh = slot.currentMesh;\n        mesh.texture = descriptor.texture;\n        for (var i = 0; i < attachment.uvs.length; i++) {\n            mesh.uvs[i] = attachment.uvs[i];\n        }\n        if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            mesh.indexDirty = true;\n        } else {\n            // PIXI version 3\n            mesh.dirty = true;\n        }\n    }\n    return true;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotName = function(slotName, texture, size) {\n    var index = this.skeleton.findSlotIndex(slotName);\n    if (index == -1) {\n        return false;\n    }\n    return this.hackTextureBySlotIndex(index,texture, size);\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n\n},{\"../SpineRuntime\":43,\"../loaders/atlasParser\":47}],46:[function(require,module,exports){\n/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n\n},{\"./atlasParser\":47}],47:[function(require,module,exports){\nvar Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n            if (atlasParser.enableCaching) {\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n            }\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching) {\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n                }\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = false;\r\n\n},{\"../SpineRuntime\":43,\"./imageLoaderAdapter\":48}],48:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n\n},{\"../SpineRuntime\":43}],49:[function(require,module,exports){\nmodule.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n\n},{\"./Loader\":46,\"./atlasParser\":47,\"./imageLoaderAdapter\":48,\"./syncImageLoaderAdapter\":50}],50:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n\n},{\"../SpineRuntime\":43}]},{},[1])\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /**\r\n     * Returns true if animation exists in skeleton data\r\n     * @param animationName\r\n     * @returns {boolean}\r\n     */\r\n    hasAnimationByName: function (animationName)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function(atlasText, loaderFunction, callback) {\r\n    this.pages = [];\r\n    this.regions = [];\r\n    if (typeof atlasText === \"string\") {\r\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\r\n    }\r\n};\r\n\r\nspine.Atlas.prototype = {\r\n    addTexture: function(name, texture) {\r\n        var pages = this.pages;\r\n        var page = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].rendererObject === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new spine.AtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.rendererObject = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.format = 'RGBA8888';\r\n            page.minFilter = page.magFilter = \"Nearest\";\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new spine.AtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    },\r\n    addTextureHash: function(textures, stripExtension) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    },\r\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\r\n    {\r\n        //TODO: remove this legacy later\r\n        if (typeof loaderFunction !== \"function\") {\r\n            //old syntax\r\n            var baseUrl = loaderFunction;\r\n            var crossOrigin = callback;\r\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n            callback = null;\r\n        }\r\n\r\n        this.texturesLoading = 0;\r\n\r\n        var self = this;\r\n\r\n        var reader = new spine.AtlasReader(atlasText);\r\n        var tuple = [];\r\n        tuple.length = 4;\r\n        var page = null;\r\n\r\n        iterateParser();\r\n\r\n        function iterateParser() {\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line === null) {\r\n                    return callback && callback(self);\r\n                }\r\n                line = reader.trim(line);\r\n                if (!line.length)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new spine.AtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    } else {\r\n                        //old format, detect width and height by texture\r\n                    }\r\n                    page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                    loaderFunction(line, function (texture) {\r\n                        page.rendererObject = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        self.pages.push(page);\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    var region = new spine.AtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n\r\n                    var resolution = page.rendererObject.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    var originalWidth = parseInt(tuple[0]) / resolution;\r\n                    var originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    var offsetX = parseInt(tuple[0]) / resolution;\r\n                    var offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    self.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.texture._updateUvs();\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.spineOffsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.WeightedMeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\nspine.AtlasRegion = function ()\n{};\nspine.AtlasRegion.prototype = {\n    name: null,\n    /**\n     * @member {PIXI.Texture}\n     */\n    texture: null,\n\n    /**\n     * @member {PIXI.spine.Spine.AtlasPage}\n     */\n    page: null,\n    index: 0,\n    splits: null,\n    pads: null\n};\n\nObject.defineProperties(spine.AtlasRegion.prototype, {\n    x: {\n        get: function() {\n            return this.texture.frame.x;\n        }\n    },\n    y: {\n        get: function() {\n            return this.texture.frame.y;\n        }\n    },\n    width: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    height: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n    },\n    u: {\n        get: function() {\n            return this.texture._uvs.x0;\n        }\n    },\n    v: {\n        get: function() {\n            return this.texture._uvs.y0;\n        }\n    },\n    u2: {\n        get: function() {\n            return this.texture._uvs.x2;\n        }\n    },\n    v2: {\n        get: function() {\n            return this.texture._uvs.y2;\n        }\n    },\n    rotate: {\n        get: function() {\n            return !!this.texture.rotate;\n        }\n    },\n    offsetX: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n    },\n    offsetY: {\n        get: function() {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n    },\n    pixiOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n    },\n    spineOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n    },  \n    originalWidth: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return tex.crop.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    originalHeight: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return tex.crop.height;\n            }\n            return tex.orig.height;\n        }\n    }\n});\n\nmodule.exports = spine.AtlasRegion;\n\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n","var spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    update: function() {\n        this.rotationIK = this.rotation;\n        this.updateWorldTransform();\n    },\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n        var rotationX = rotation + this.shearX;\n        var rotationY = rotation + 90 + this.shearY;\n\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\n                    var temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    var r = parent.rotationIK;\n                    cos = Math.cos(r * spine.degRad);\n                    sin = Math.sin(r * spine.degRad);\n                    var psx = parent.scaleX, psy = parent.scaleY;\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                    temp = pa * za + pb * zc;\n                    pb = pa * zb + pb * zd;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pc * zb + pd * zd;\n                    pc = temp;\n\n                    if (psx < 0) {\n                        r = -r;\n                    } else {\n                        sin = -sin;\n                    }\n                    temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n","var spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        var slotAttachment = slot.attachment;\r\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n    bone.updateWorldTransform();\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = Math.PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    parent.updateWorldTransform();\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n    child.updateWorldTransform();\n};\nmodule.exports = spine.IkConstraint;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n        }\n        this.rendererObject = newRegion;\n        this.updateUVs();\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n            this.oldRegion.size = { width: this.width, height: this.height };\n        }\n        this.rendererObject = newRegion;\n        if (newRegion.size) {\n            this.width = newRegion.size.width;\n            this.height = newRegion.size.height;\n        }\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ShearTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ShearTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ShearTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.transformConstraints = [];\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n        var transformConstraints = this.transformConstraints;\n        var transformConstraintsCount = transformConstraints.length;\n\n        var boneCache = this.boneCache;\n        boneCache.length = 0;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            boneCache.push(bone);\n            for (var j=0; j < transformConstraintsCount; j++) {\n                if (transformConstraints[j].bone == bone) {\n                    boneCache.push(transformConstraints[j]);\n                }\n            }\n            for (var j=0; j < ikConstraintsCount; j++) {\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\n                    boneCache.push(ikConstraints[j]);\n                    break;\n                }\n            }\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var boneCache = this.boneCache;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].update();\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\n        {\n            var constraint = transformConstraints[i];\n            var data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n    this.transformConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n    /** @return May be null. */\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n};\nmodule.exports = spine.SkeletonData;\n\n","var spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    if (attachmentLoader.pages) {\n        //its an atlas, we have to wrap it\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\n    } else {\n        //got a loader, thats good\n        this.attachmentLoader = attachmentLoader;\n    }\n    if (!attachmentLoader.newRegionAttachment) {\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\n    }\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        var scale = this.scale;\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.shearX = boneMap[\"shearX\"] || 0;\n            boneData.shearY = boneMap[\"shearY\"] || 0;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        var transform = root[\"transform\"];\n        if (transform) {\n            for (var i = 0, n = transform.length; i<n; i++) {\n                var transformMap = transform[i];\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\n\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\n\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\n\n                skeletonData.transformConstraints.push(transformData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                mesh.updateUVs();\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                var uvs = this.getFloatArray(map, \"uvs\", 1);\n                var vertices = this.getFloatArray(map, \"vertices\", 1);\n                var weights = [];\n                var bones = [];\n                for (var i = 0, n = vertices.length; i < n; )\n                {\n                    var boneCount = vertices[i++] | 0;\n                    bones[bones.length] = boneCount;\n                    for (var nn = i + boneCount * 4; i < nn; )\n                    {\n                        bones[bones.length] = vertices[i];\n                        weights[weights.length] = vertices[i + 1] * scale;\n                        weights[weights.length] = vertices[i + 2] * scale;\n                        weights[weights.length] = vertices[i + 3];\n                        i += 4;\n                    }\n                }\n                mesh.bones = bones;\n                mesh.weights = weights;\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = uvs;\n                mesh.updateUVs();\n\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") {\n                        timeline = new spine.ScaleTimeline(values.length);\n                    } else if (timelineName == \"shear\") {\n                        timeline = new spine.ShearTimeline(values.length);\n                    }\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var transformMap = map[\"transform\"];\n        for (var transformConstraintName in transformMap)\n        {\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\n            var values = transformMap[transformConstraintName];\n            var timeline = new spine.TransformConstraintTimeline(values.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\nvar tempVec = [0, 0];\nspine.TransformConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.translateMix = data.translateMix;\n    this.rotateMix = data.rotateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.offsetX = data.offsetX;\n    this.offsetY = data.offsetY;\n    this.offsetScaleX = data.offsetScaleX;\n    this.offsetScaleY = data.offsetScaleY;\n    this.offsetShearY = data.offsetShearY;\n\n    this.bone = skeleton.findBone(data.bone.name);\n    this.target = skeleton.findBone(data.target.name);\n};\n\nspine.TransformConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var bm = this.bone.matrix;\n        var tm = this.target.matrix;\n\n        var rotateMix = this.rotateMix;\n        if (rotateMix > 0) {\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r *= rotateMix;\n            var cos = Math.cos(r), sin = Math.sin(r);\n            bm.a = cos * a - sin * c;\n            bm.c = cos * b - sin * d;\n            bm.b = sin * a + cos * c;\n            bm.d = sin * b + cos * d;\n        }\n\n        var scaleMix = this.rotateMix;\n        if (scaleMix > 0) {\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\n            bm.a *= s;\n            bm.b *= s;\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\n            bm.c *= s;\n            bm.d *= s;\n        }\n\n        var shearMix = this.shearMix;\n        if (shearMix > 0) {\n            var b = bm.c, d = bm.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            bm.c = Math.cos(r) * s;\n            bm.d = Math.sin(r) * s;\n        }\n\n        var translateMix = this.translateMix;\n        if (translateMix > 0) {\n            tempVec[0] = this.offsetX;\n            tempVec[1] = this.offsetY;\n            this.target.localToWorld(tempVec);\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\n        }\n    }\n};\n\nmodule.exports = spine.TransformConstraint;\n","var spine = require('../SpineUtil') || {};\nspine.TransformConstraintData = function (name)\n{\n    this.name = name;\n    this.bone = null;\n};\nspine.TransformConstraintData.prototype = {\n    target: null,\n    rotateMix: 1,\n    translateMix: 1,\n    scaleMix: 1,\n    shearMix: 1,\n    offsetRotation: 0,\n    offsetX: 0,\n    offsetY: 0,\n    offsetScaleX: 0,\n    offsetScaleY: 0,\n    offsetShearY: 0\n};\nmodule.exports = spine.TransformConstraintData;\n\n","var spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TransformConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TransformConstraintTimeline.prototype = {\n    transformConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = rotateMix;\n        this.frames[frameIndex + 2] = translateMix;\n        this.frames[frameIndex + 3] = scaleMix;\n        this.frames[frameIndex + 4] = shareMix;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - 5])\n        { // Time is after last frame.\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frame = spine.Animation.binarySearch(frames, time, 5);\n        var frameTime = frames[frame];\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\n\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\n    }\n};\nmodule.exports = spine.TransformConstraintTimeline;\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.WeightedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.WeightedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.weightedmesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, vx, vy, weight;\r\n        var m;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.weights = parentMesh.weights;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.WeightedMeshAttachment;\r\n\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.TransformConstraint = require('./TransformConstraint');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n","module.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\n    signum: function(x) {\n        if (x>0) return 1;\n        if (x<0) return -1;\n        return 0;\n    }\n};\n\n","var spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                var transform = slotContainer.transform;\n                var lt;\n                if (slotContainer.transform.matrix2d) {\n                    //gameofbombs pixi fork\n                    lt = transform.matrix2d;\n                    transform._dirtyVersion++;\n                    transform.version = transform._dirtyVersion;\n                    transform.isStatic = true;\n                    transform.operMode = 0;\n                } else\n                if (PIXI.TransformManual) {\n                    //PIXI v4.0\n                    if (transform.position) {\n                        transform = new PIXI.TransformManual();\n                        slotContainer.transform = transform;\n                    }\n                    lt = transform.localTransform;\n                } else {\n                    //PIXI v4.0rc\n                    if (!transform._dirtyLocal) {\n                        transform = new PIXI.TransformStatic();\n                        slotContainer.transform = transform;\n                    }\n                    lt = transform.localTransform;\n                    transform._dirtyParentVersion = -1;\n                    transform._dirtyLocal = 1;\n                    transform._versionLocal = 1;\n                }\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r * attachment.r, slot.g * attachment.g, slot.b * attachment.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n            if (PIXI.VERSION[0] !== '3') {\n                // PIXI version 4\n                slot.currentMesh.dirty = true;\n            }\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var texture = descriptor.texture;\n    var sprite = new PIXI.Sprite(texture);\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\n    sprite.rotation = attachment.rotation * spine.degRad;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {\n    var slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n        return false;\n    }\n    var attachment = slot.attachment;\n    if (!attachment || !attachment.hackRegion) {\n        return false;\n    }\n    var region = null;\n    if (texture) {\n        region = new spine.AtlasRegion();\n        region.texture = texture;\n        region.size = size;\n    }\n\n    attachment.hackRegion(region);\n    var descriptor = attachment.rendererObject;\n    if (slot.currentSprite) {\n        var sprite = slot.currentSprite;\n        sprite.texture = descriptor.texture;\n        sprite.scale.x = attachment.width / descriptor.originalWidth;\n        sprite.scale.y = - attachment.height / descriptor.originalHeight;\n    }\n    if (slot.currentMesh) {\n        var mesh = slot.currentMesh;\n        mesh.texture = descriptor.texture;\n        for (var i = 0; i < attachment.uvs.length; i++) {\n            mesh.uvs[i] = attachment.uvs[i];\n        }\n        if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            mesh.indexDirty = true;\n        } else {\n            // PIXI version 3\n            mesh.dirty = true;\n        }\n    }\n    return true;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotName = function(slotName, texture, size) {\n    var index = this.skeleton.findSlotIndex(slotName);\n    if (index == -1) {\n        return false;\n    }\n    return this.hackTextureBySlotIndex(index,texture, size);\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n            if (atlasParser.enableCaching) {\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n            }\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching) {\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n                }\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = false;\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n","module.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n"],"sourceRoot":"./"}