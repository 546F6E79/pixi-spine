{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/ShearTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TransformConstraint.js","src/SpineRuntime/TransformConstraintData.js","src/SpineRuntime/TransformConstraintTimeline.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/WeightedMeshAttachment.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/imageLoaderAdapter.js","src/loaders/index.js","src/loaders/syncImageLoaderAdapter.js","src"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiSpine","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","spine","Animation","name","timelines","duration","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","TrackEntry","AnimationState","stateData","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","hasAnimationByName","getCurrent","AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty","AtlasReader","AtlasPage","AtlasRegion","syncImageLoaderAdapter","Atlas","atlasText","loaderFunction","callback","pages","regions","addSpineAtlas","addTexture","texture","page","rendererObject","baseTexture","width","realWidth","height","realHeight","format","minFilter","magFilter","uWrap","TextureWrap","clampToEdge","vWrap","region","addTextureHash","textures","stripExtension","indexOf","substr","lastIndexOf","iterateParser","line","reader","readLine","trim","readTuple","tuple","parseInt","Format","TextureFilter","direction","readValue","repeat","hasLoaded","console","log","rotate","x","y","resolution","frame","PIXI","Rectangle","splits","pads","originalWidth","originalHeight","offsetX","offsetY","orig","VERSION","Texture","frame2","crop","clone","_updateUvs","baseUrl","crossOrigin","texturesLoading","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","RegionAttachment","MeshAttachment","WeightedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","v","u2","v2","regionOffsetX","regionOffsetY","spineOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","newWeightedMeshAttachment","newBoundingBoxAttachment","text","lines","split","value","replace","colon","substring","lastMatch","comma","Object","defineProperties","get","tex","_uvs","x0","y0","x2","y2","warn","pixiOffsetY","Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","AttachmentType","boundingbox","mesh","weightedmesh","skinnedmesh","linkedmesh","weightedlinkedmesh","Bone","boneData","parent","matrix","Matrix","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","shearX","shearY","flipX","flipY","worldSignX","worldSignY","updateWorldTransform","rotationX","rotationY","la","cos","degRad","lb","lc","sin","ld","m","c","b","d","tx","ty","signum","pa","pb","pc","pd","inheritRotation","inheritScale","temp","psx","psy","za","zb","zc","zd","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldX","worldY","BoneData","vertices","type","computeWorldVertices","bone","worldVertices","m00","m01","m10","m11","px","py","ColorTimeline","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot","setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY","DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex","Event","intValue","floatValue","stringValue","EventData","EventTimeline","FfdTimeline","frameVertices","slotAttachment","applyFFD","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev","IkConstraint","bendDirection","bones","findBone","apply1","apply2","targetX","targetY","parentRotation","child","bendDir","offset1","offset2","sign2","csx","cy","pp","ppm","wx","wy","a1","a2","l1","l2","outer","abs","acos","ta","aa","bb","ll","dd","c0","c1","c2","q","r0","r1","minAngle","minDist","Infinity","minX","minY","maxAngle","maxDist","maxX","maxY","dist","PI","angle","offset","IkConstraintData","IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix","parentMesh","inheritFFD","uvs","regionUVs","triangles","hullLength","edges","Float32Array","w1","h1","w2","h2","x1","x3","y1","y3","verticesCount","vx","vy","sourceAttachment","setParentMesh","hackRegion","newRegion","oldRegion","updateOffset","regionScaleX","regionScaleY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices","size","RotateTimeline","boneIndex","amount","prevFrameValue","ScaleTimeline","prevFrameX","prevFrameY","ShearTimeline","Slot","Skeleton","slotData","transformConstraints","TransformConstraint","boneCache","updateCache","ikConstraintsCount","transformConstraintsCount","j","setBonesToSetupPose","setSlotsToSetupPose","constraint","rotateMix","translateMix","scaleMix","shearMix","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","constraintName","constraints","findTransformConstraint","SkeletonBounds","polygonPool","polygons","boundingBoxes","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","max","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonData","skins","animations","version","hash","findEvent","eventName","LinkedMesh","TransformConstraintData","SlotData","Skin","TranslateTimeline","TransformConstraintTimeline","SkeletonJsonParser","attachmentLoader","AtlasAttachmentLoader","linkedMeshes","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","transform","transformMap","transformData","offsetRotation","offsetScaleX","offsetScaleY","offsetShearY","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","linkedMesh","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","ikConstraintName","transformConstraintName","transformConstraint","transformConstraintIndex","ffd","meshMap","meshName","isMesh","verticesValue","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","attachments","oldSkin","_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas","multiply","BLEND_MODES","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL","tempVec","bm","tm","bs","ts","by","shareMix","translate","shear","regionU2","regionU","regionV2","regionV","weight","skeletonBones","w","Spine","spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","SlotContainerUpdateTransformV3","pt","worldTransform","wt","lt","localTransform","worldAlpha","_currentBounds","atlasParser","TransformBase","TransformManual","fromAtlas","resourceName","AnimCache","create","constructor","globalAutoUpdate","updateTransform","autoUpdateTransform","set","tint","utils","rgb2hex","hex2rgb","tempRgb","dt","children","g0","b0","undefined","visible","sprites","matrix2d","_dirtyVersion","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","copy","displayObjectUpdateTransform","meshes","dirty","Date","now","timeDelta","descriptor","Sprite","anchor","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","hackTextureBySlotIndex","indexDirty","hackTextureBySlotName","loaders","Loader","addPixiMiddleware","loader","use","Resource","imageLoaderAdapter","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","enableCaching","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","add","res","xhr","responseText","namePrefix","BaseTexture","fromImage","SpineRuntime"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /**\r\n     * Returns true if animation exists in skeleton data\r\n     * @param animationName\r\n     * @returns {boolean}\r\n     */\r\n    hasAnimationByName: function (animationName)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function(atlasText, loaderFunction, callback) {\r\n    this.pages = [];\r\n    this.regions = [];\r\n    if (typeof atlasText === \"string\") {\r\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\r\n    }\r\n};\r\n\r\nspine.Atlas.prototype = {\r\n    addTexture: function(name, texture) {\r\n        var pages = this.pages;\r\n        var page = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].rendererObject === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new spine.AtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.rendererObject = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.format = 'RGBA8888';\r\n            page.minFilter = page.magFilter = \"Nearest\";\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new spine.AtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    },\r\n    addTextureHash: function(textures, stripExtension) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    },\r\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\r\n    {\r\n        //TODO: remove this legacy later\r\n        if (typeof loaderFunction !== \"function\") {\r\n            //old syntax\r\n            var baseUrl = loaderFunction;\r\n            var crossOrigin = callback;\r\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n            callback = null;\r\n        }\r\n\r\n        this.texturesLoading = 0;\r\n\r\n        var self = this;\r\n\r\n        var reader = new spine.AtlasReader(atlasText);\r\n        var tuple = [];\r\n        tuple.length = 4;\r\n        var page = null;\r\n\r\n        iterateParser();\r\n\r\n        function iterateParser() {\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line === null) {\r\n                    return callback && callback(self);\r\n                }\r\n                line = reader.trim(line);\r\n                if (!line.length)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new spine.AtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    } else {\r\n                        //old format, detect width and height by texture\r\n                    }\r\n                    page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                    loaderFunction(line, function (texture) {\r\n                        page.rendererObject = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        self.pages.push(page);\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    var region = new spine.AtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n\r\n                    var resolution = page.rendererObject.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    var originalWidth = parseInt(tuple[0]) / resolution;\r\n                    var originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    var offsetX = parseInt(tuple[0]) / resolution;\r\n                    var offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    self.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.texture._updateUvs();\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.spineOffsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.WeightedMeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\nspine.AtlasRegion = function ()\n{};\nspine.AtlasRegion.prototype = {\n    name: null,\n    /**\n     * @member {PIXI.Texture}\n     */\n    texture: null,\n\n    /**\n     * @member {PIXI.spine.Spine.AtlasPage}\n     */\n    page: null,\n    index: 0,\n    splits: null,\n    pads: null\n};\n\nObject.defineProperties(spine.AtlasRegion.prototype, {\n    x: {\n        get: function() {\n            return this.texture.frame.x;\n        }\n    },\n    y: {\n        get: function() {\n            return this.texture.frame.y;\n        }\n    },\n    width: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    height: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n    },\n    u: {\n        get: function() {\n            return this.texture._uvs.x0;\n        }\n    },\n    v: {\n        get: function() {\n            return this.texture._uvs.y0;\n        }\n    },\n    u2: {\n        get: function() {\n            return this.texture._uvs.x2;\n        }\n    },\n    v2: {\n        get: function() {\n            return this.texture._uvs.y2;\n        }\n    },\n    rotate: {\n        get: function() {\n            return !!this.texture.rotate;\n        }\n    },\n    offsetX: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n    },\n    offsetY: {\n        get: function() {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n    },\n    pixiOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n    },\n    spineOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n    },  \n    originalWidth: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return tex.crop.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    originalHeight: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return tex.crop.height;\n            }\n            return tex.orig.height;\n        }\n    }\n});\n\nmodule.exports = spine.AtlasRegion;\n\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n","var spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    update: function() {\n        this.rotationIK = this.rotation;\n        this.updateWorldTransform();\n    },\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n        var rotationX = rotation + this.shearX;\n        var rotationY = rotation + 90 + this.shearY;\n\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\n                    var temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    var r = parent.rotationIK;\n                    cos = Math.cos(r * spine.degRad);\n                    sin = Math.sin(r * spine.degRad);\n                    var psx = parent.scaleX, psy = parent.scaleY;\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                    temp = pa * za + pb * zc;\n                    pb = pa * zb + pb * zd;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pc * zb + pd * zd;\n                    pc = temp;\n\n                    if (psx < 0) {\n                        r = -r;\n                    } else {\n                        sin = -sin;\n                    }\n                    temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n","var spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        var slotAttachment = slot.attachment;\r\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n\n    //OLD ONE:\n\n    // float parentRotation = bone.parent == null ? 0 : bone.parent.getWorldRotationX();\n    // float rotation = bone.rotation;\n    // float rotationIK = atan2(targetY - bone.worldY, targetX - bone.worldX) * radDeg - parentRotation;\n    // if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != bone.skeleton.flipY)) rotationIK = 360 - rotationIK;\n\n    //NEW ONE\n\n    // var pp = bone.parent;\n    // float id = 1 / (pp.a * pp.d - pp.b * pp.c);\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\n    // float tx = (x * pp.d - y * pp.b) * id - bone.x, ty = (y * pp.a - x * pp.c) * id - bone.y;\n    // float rotationIK = atan2(ty, tx) * radDeg - bone.shearX;\n    // if (bone.scaleX < 0) rotationIK += 180;\n\n\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n    bone.updateWorldTransform();\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n\n    //OLD ONE\n    // float tx, ty, dx, dy;\n    // if (pp == null) {\n    //     tx = targetX - px;\n    //     ty = targetY - py;\n    //     dx = child.worldX - px;\n    //     dy = child.worldY - py;\n    // } else {\n    //     float a = pp.a, b = pp.b, c = pp.c, d = pp.d, invDet = 1 / (a * d - b * c);\n    //     float wx = pp.worldX, wy = pp.worldY, x = targetX - wx, y = targetY - wy;\n    //     tx = (x * d - y * b) * invDet - px;\n    //     ty = (y * a - x * c) * invDet - py;\n    //     x = child.worldX - wx;\n    //     y = child.worldY - wy;\n    //     dx = (x * d - y * b) * invDet - px;\n    //     dy = (y * a - x * c) * invDet - py;\n    // }\n\n    //NEW ONE\n    // float ppa = pp.a, ppb = pp.b, ppc = pp.c, ppd = pp.d, id = 1 / (ppa * ppd - ppb * ppc);\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\n    // float tx = (x * ppd - y * ppb) * id - px, ty = (y * ppa - x * ppc) * id - py;\n    // x = child.worldX - pp.worldX;\n    // y = child.worldY - pp.worldY;\n    // float dx = (x * ppd - y * ppb) * id - px, dy = (y * ppa - x * ppc) * id - py;\n\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = Math.PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    parent.updateWorldTransform();\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n    child.updateWorldTransform();\n};\nmodule.exports = spine.IkConstraint;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n        }\n        this.rendererObject = newRegion;\n        this.updateUVs();\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    },\n    hackRegion: function(newRegion) {\n        if (!newRegion) {\n            if (!this.oldRegion) return;\n            newRegion = this.oldRegion;\n        }\n        if (!this.oldRegion) {\n            this.oldRegion = this.rendererObject;\n            this.oldRegion.size = { width: this.width, height: this.height };\n        }\n        this.rendererObject = newRegion;\n        if (newRegion.size) {\n            this.width = newRegion.size.width;\n            this.height = newRegion.size.height;\n        }\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ShearTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ShearTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ShearTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.transformConstraints = [];\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n        var transformConstraints = this.transformConstraints;\n        var transformConstraintsCount = transformConstraints.length;\n\n        var boneCache = this.boneCache;\n        boneCache.length = 0;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            boneCache.push(bone);\n            for (var j=0; j < transformConstraintsCount; j++) {\n                if (transformConstraints[j].bone == bone) {\n                    boneCache.push(transformConstraints[j]);\n                }\n            }\n            for (var j=0; j < ikConstraintsCount; j++) {\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\n                    boneCache.push(ikConstraints[j]);\n                    break;\n                }\n            }\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var boneCache = this.boneCache;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].update();\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\n        {\n            var constraint = transformConstraints[i];\n            var data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n    this.transformConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n    /** @return May be null. */\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n};\nmodule.exports = spine.SkeletonData;\n\n","var spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    if (attachmentLoader.pages) {\n        //its an atlas, we have to wrap it\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\n    } else {\n        //got a loader, thats good\n        this.attachmentLoader = attachmentLoader;\n    }\n    if (!attachmentLoader.newRegionAttachment) {\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\n    }\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        var scale = this.scale;\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.shearX = boneMap[\"shearX\"] || 0;\n            boneData.shearY = boneMap[\"shearY\"] || 0;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        var transform = root[\"transform\"];\n        if (transform) {\n            for (var i = 0, n = transform.length; i<n; i++) {\n                var transformMap = transform[i];\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\n\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\n\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\n\n                skeletonData.transformConstraints.push(transformData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh ||\n            type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var vertexCount = map[\"vertexCount\"] || 0;\n            if (vertexCount * 2 === map[\"vertices\"].length ||\n                map[\"vertices\"].length === map[\"uvs\"].length) {\n                //regular mesh\n                var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                if (!mesh) return null;\n                mesh.path = path;\n                color = map[\"color\"];\n                if (color) {\n                    mesh.r = this.toColor(color, 0);\n                    mesh.g = this.toColor(color, 1);\n                    mesh.b = this.toColor(color, 2);\n                    mesh.a = this.toColor(color, 3);\n                }\n                mesh.width = (map[\"width\"] || 0) * scale;\n                mesh.height = (map[\"height\"] || 0) * scale;\n\n                var parent = map[\"parent\"];\n                if (!parent) {\n                    mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\n                    mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                    mesh.updateUVs();\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n                } else {\n                    mesh.inheritFFD = !!map[\"ffd\"];\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n                }\n                return mesh;\n            } else {\n                //weighted mesh\n                var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n                if (!mesh) return null;\n                mesh.path = path;\n                color = map[\"color\"];\n                if (color) {\n                    mesh.r = this.toColor(color, 0);\n                    mesh.g = this.toColor(color, 1);\n                    mesh.b = this.toColor(color, 2);\n                    mesh.a = this.toColor(color, 3);\n                }\n                mesh.width = (map[\"width\"] || 0) * scale;\n                mesh.height = (map[\"height\"] || 0) * scale;\n\n                var parent = map[\"parent\"];\n                if (!parent) {\n                    var uvs = this.getFloatArray(map, \"uvs\", 1);\n                    var vertices = this.getFloatArray(map, \"vertices\", 1);\n                    var weights = [];\n                    var bones = [];\n                    for (var i = 0, n = vertices.length; i < n;) {\n                        var boneCount = vertices[i++] | 0;\n                        bones[bones.length] = boneCount;\n                        for (var nn = i + boneCount * 4; i < nn;) {\n                            bones[bones.length] = vertices[i];\n                            weights[weights.length] = vertices[i + 1] * scale;\n                            weights[weights.length] = vertices[i + 2] * scale;\n                            weights[weights.length] = vertices[i + 3];\n                            i += 4;\n                        }\n                    }\n                    mesh.bones = bones;\n                    mesh.weights = weights;\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\n                    mesh.regionUVs = uvs;\n                    mesh.updateUVs();\n\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n                } else {\n                    mesh.inheritFFD = !!map[\"ffd\"];\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n                }\n                return mesh;\n            }\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") {\n                        timeline = new spine.ScaleTimeline(values.length);\n                    } else if (timelineName == \"shear\") {\n                        timeline = new spine.ShearTimeline(values.length);\n                    }\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var transformMap = map[\"transform\"];\n        for (var transformConstraintName in transformMap)\n        {\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\n            var values = transformMap[transformConstraintName];\n            var timeline = new spine.TransformConstraintTimeline(values.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n        }\n\n        var ffd = map[\"deform\"] || map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\nvar tempVec = [0, 0];\nspine.TransformConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.translateMix = data.translateMix;\n    this.rotateMix = data.rotateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.offsetX = data.offsetX;\n    this.offsetY = data.offsetY;\n    this.offsetScaleX = data.offsetScaleX;\n    this.offsetScaleY = data.offsetScaleY;\n    this.offsetShearY = data.offsetShearY;\n\n    this.bone = skeleton.findBone(data.bone.name);\n    this.target = skeleton.findBone(data.target.name);\n};\n\nspine.TransformConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var bm = this.bone.matrix;\n        var tm = this.target.matrix;\n\n        var rotateMix = this.rotateMix;\n        if (rotateMix > 0) {\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r *= rotateMix;\n            var cos = Math.cos(r), sin = Math.sin(r);\n            bm.a = cos * a - sin * c;\n            bm.c = cos * b - sin * d;\n            bm.b = sin * a + cos * c;\n            bm.d = sin * b + cos * d;\n        }\n\n        var scaleMix = this.rotateMix;\n        if (scaleMix > 0) {\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\n            bm.a *= s;\n            bm.b *= s;\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\n            bm.c *= s;\n            bm.d *= s;\n        }\n\n        var shearMix = this.shearMix;\n        if (shearMix > 0) {\n            var b = bm.c, d = bm.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            bm.c = Math.cos(r) * s;\n            bm.d = Math.sin(r) * s;\n        }\n\n        var translateMix = this.translateMix;\n        if (translateMix > 0) {\n            tempVec[0] = this.offsetX;\n            tempVec[1] = this.offsetY;\n            this.target.localToWorld(tempVec);\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\n        }\n    }\n};\n\nmodule.exports = spine.TransformConstraint;\n","var spine = require('../SpineUtil') || {};\r\nspine.TransformConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bone = null;\r\n};\r\nspine.TransformConstraintData.prototype = {\r\n    target: null,\r\n    rotateMix: 1,\r\n    translateMix: 1,\r\n    scaleMix: 1,\r\n    shearMix: 1,\r\n    offsetRotation: 0,\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    offsetScaleX: 0,\r\n    offsetScaleY: 0,\r\n    offsetShearY: 0\r\n};\r\nmodule.exports = spine.TransformConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TransformConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TransformConstraintTimeline.prototype = {\n    transformConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = rotateMix;\n        this.frames[frameIndex + 2] = translateMix;\n        this.frames[frameIndex + 3] = scaleMix;\n        this.frames[frameIndex + 4] = shareMix;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - 5])\n        { // Time is after last frame.\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frame = spine.Animation.binarySearch(frames, time, 5);\n        var frameTime = frames[frame];\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\n\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\n    }\n};\nmodule.exports = spine.TransformConstraintTimeline;\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.WeightedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.WeightedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.weightedmesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, vx, vy, weight;\r\n        var m;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.weights = parentMesh.weights;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.WeightedMeshAttachment;\r\n\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.TransformConstraint = require('./TransformConstraint');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n","module.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\r\n    signum: function(x) {\r\n        if (x>0) return 1;\r\n        if (x<0) return -1;\r\n        return 0;\r\n    }\r\n};\r\n\r\n","var spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\nvar TransformBase = PIXI.TransformBase || PIXI.TransformManual;\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n\n    /**\n     * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     */\n    this.tintRgb = new Float32Array([1, 1, 1]);\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof PIXI.spine.Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    },\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     * @default 0xFFFFFF\n     */\n    tint: {\n        get: function() {\n            return PIXI.utils.rgb2hex(this.tintRgb);\n        },\n        set: function(value) {\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n        }\n    }\n});\n\nvar tempRgb = [0, 0, 0];\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    var r0 = this.tintRgb[0];\n    var g0 = this.tintRgb[1];\n    var b0 = this.tintRgb[2];\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                var transform = slotContainer.transform;\n                var lt;\n                if (slotContainer.transform.matrix2d) {\n                    //gameofbombs pixi fork\n                    lt = transform.matrix2d;\n                    transform._dirtyVersion++;\n                    transform.version = transform._dirtyVersion;\n                    transform.isStatic = true;\n                    transform.operMode = 0;\n                } else {\n                    if (TransformBase) {\n                        //PIXI v4.0\n                        if (transform.position) {\n                            transform = new PIXI.TransformBase();\n                            slotContainer.transform = transform;\n                        }\n                        lt = transform.localTransform;\n                    } else {\n                        //PIXI v4.0rc\n                        if (!transform._dirtyLocal) {\n                            transform = new PIXI.TransformStatic();\n                            slotContainer.transform = transform;\n                        }\n                        lt = transform.localTransform;\n                        transform._dirtyParentVersion = -1;\n                        transform._dirtyLocal = 1;\n                        transform._versionLocal = 1;\n                    }\n                }\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n            tempRgb[0] = r0 * slot.r * attachment.r;\n            tempRgb[1] = g0 * slot.g * attachment.g;\n            tempRgb[2] = b0 * slot.b * attachment.b;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n            slot.currentSprite.blendMode = slot.blendMode;\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n            if (PIXI.VERSION[0] !== '3') {\n                // PIXI version 4\n                slot.currentMesh.dirty = true;\n                //only for PIXI v4\n                var tintRgb = slot.currentMesh.tintRgb;\n                tintRgb[0] = r0 * slot.r * attachment.r;\n                tintRgb[1] = g0 * slot.g * attachment.g;\n                tintRgb[2] = b0 * slot.b * attachment.b;\n            }\n            slot.currentMesh.blendMode = slot.blendMode;\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var texture = descriptor.texture;\n    var sprite = new PIXI.Sprite(texture);\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\n    sprite.rotation = attachment.rotation * spine.degRad;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {\n    var slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n        return false;\n    }\n    var attachment = slot.attachment;\n    if (!attachment || !attachment.hackRegion) {\n        return false;\n    }\n    var region = null;\n    if (texture) {\n        region = new spine.AtlasRegion();\n        region.texture = texture;\n        region.size = size;\n    }\n\n    attachment.hackRegion(region);\n    var descriptor = attachment.rendererObject;\n    if (slot.currentSprite) {\n        var sprite = slot.currentSprite;\n        sprite.texture = descriptor.texture;\n        sprite.scale.x = attachment.width / descriptor.originalWidth;\n        sprite.scale.y = - attachment.height / descriptor.originalHeight;\n    }\n    if (slot.currentMesh) {\n        var mesh = slot.currentMesh;\n        mesh.texture = descriptor.texture;\n        for (var i = 0; i < attachment.uvs.length; i++) {\n            mesh.uvs[i] = attachment.uvs[i];\n        }\n        if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            mesh.indexDirty = true;\n        } else {\n            // PIXI version 3\n            mesh.dirty = true;\n        }\n    }\n    return true;\n};\n\n/**\n * Changes texture in attachment in specific slot.\n *\n * PIXI runtime feature, it was made to satisfy our users.\n *\n * @param slotName {string}\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n * @returns {boolean} Success flag\n */\nSpine.prototype.hackTextureBySlotName = function(slotName, texture, size) {\n    var index = this.skeleton.findSlotIndex(slotName);\n    if (index == -1) {\n        return false;\n    }\n    return this.hackTextureBySlotIndex(index,texture, size);\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n            if (atlasParser.enableCaching) {\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n            }\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching) {\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n                }\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = false;\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n","module.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = { // \"PIXI.spine\" assignment is here for people/plugins who use plugin both through require and as a plugin.\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n"],"sourceRoot":"/source/"}