{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/Spine.ts","src/core/Animation.ts","src/core/AnimationState.ts","src/core/AnimationStateData.ts","src/core/AtlasAttachmentLoader.ts","src/core/BlendMode.ts","src/core/Bone.ts","src/core/BoneData.ts","src/core/Event.ts","src/core/EventData.ts","src/core/IkConstraint.ts","src/core/IkConstraintData.ts","src/core/PathConstraint.ts","src/core/PathConstraintData.ts","src/core/Skeleton.ts","src/core/SkeletonBounds.ts","src/core/SkeletonData.ts","src/core/SkeletonJson.ts","src/core/Skin.ts","src/core/Slot.ts","src/core/SlotData.ts","src/core/Texture.ts","src/core/TextureAtlas.ts","src/core/TransformConstraint.ts","src/core/TransformConstraintData.ts","src/core/Utils.ts","src/core/attachments/Attachment.ts","src/core/attachments/AttachmentType.ts","src/core/attachments/BoundingBoxAttachment.ts","src/core/attachments/MeshAttachment.ts","src/core/attachments/PathAttachment.ts","src/core/attachments/RegionAttachment.ts","src/core/attachments/index.ts","src/core/index.ts","src/loaders.ts","src/index.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","PIXI","spine","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","SlotContainerUpdateTransformV3","pt","parent","worldTransform","wt","lt","localTransform","b","c","d","tx","ty","worldAlpha","alpha","_currentBounds","TransformBase","Bone","yDown","tempRgb","SpineSprite","_super","tex","__extends","Sprite","SpineMesh","texture","vertices","uvs","indices","drawMode","mesh","Mesh","Spine","spineData","hackTextureBySlotName","slotName","size","index","skeleton","findSlotIndex","hackTextureBySlotIndex","Skeleton","updateWorldTransform","stateData","AnimationStateData","state","AnimationState","slotContainers","slots","slot","attachment","slotContainer","Container","push","addChild","RegionAttachment","spriteName","region","name","sprite","createSprite","currentSprite","currentSpriteName","MeshAttachment","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","Float32Array","Object","defineProperty","prototype","updateTransform","autoUpdateTransform","value","utils","rgb2hex","hex2rgb","update","dt","apply","drawOrder","children","data","r0","g0","b0","attColor","color","ar","visible","sprites","undefined","transform","lt_1","matrix2d","_dirtyVersion","version","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","bone","matrix","copy","Matrix","displayObjectUpdateTransform","tint","blendMode","meshName","meshes","computeWorldVertices","VERSION","setSpriteRegion","scale","x","width","originalWidth","y","height","originalHeight","scaleX","scaleY","setMeshRegion","updateUVs","dirty","globalAutoUpdate","lastTime","Date","now","timeDelta","defName","tempAttachment","tempRegion","rotation","MathUtils","degRad","anchor","strip","regionUVs","Uint16Array","triangles","DRAW_MODES","TRIANGLES","canvasPadding","slotIndex","TextureRegion","Utils_1","attachments_1","Animation","timelines","duration","time","loop","events","mix","binarySearch","values","target","step","low","high","current","linearSearch","last","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","type","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","getCurvePercent","percent","clamp","start","prevX","prevY","RotateTimeline","frames","setFrame","degrees","ROTATION","bones","boneIndex","ENTRIES","amount_1","PREV_ROTATION","frame","prevRotation","frameTime","PREV_TIME","amount","TranslateTimeline","X","Y","PREV_X","PREV_Y","ScaleTimeline","ShearTimeline","shearX","shearY","ColorTimeline","R","G","B","A","PREV_R","PREV_G","PREV_B","PREV_A","add","set","AttachmentTimeline","attachmentNames","Array","attachmentName","setAttachment","getAttachment","EventTimeline","event","firedEvents","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","arrayCopy","DeformTimeline","frameVertices","slotAttachment","VertexAttachment","applyDeform","vertexCount","verticesArray","attachmentVertices","setArraySize","lastVertices","prevVertices","nextVertices","prev","IkConstraintTimeline","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","ikConstraintIndex","PREV_MIX","Math","floor","PREV_BEND_DIRECTION","TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","transformConstraintIndex","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","rotate","translate","shear","PathConstraintPositionTimeline","VALUE","pathConstraints","pathConstraintIndex","PREV_VALUE","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","tracks","timeScale","delta","next","nextTime","delay","nextDelta","setCurrent","endTime","clearTrack","previous","previousDelta","mixTime","animation","previousTime","mixDuration","ii","nn","event_1","onEvent","count","toInt","onComplete","clearTracks","trackIndex","onEnd","freeAll","entry","expandToIndex","getMix","onStart","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","TrackEntry","addAnimation","addAnimationWith","hasAnimation","getCurrent","setAnimationByName","deprecatedWarning1","console","warn","addAnimationByName","deprecatedWarning2","hasAnimationByName","deprecatedWarning3","reset","isComplete","animationToMixTime","defaultMix","setMix","fromName","toName","from","to","setMixWith","setMixByName","key","AtlasAttachmentLoader","atlas","newRegionAttachment","skin","path","findRegion","newMeshAttachment","newBoundingBoxAttachment","BoundingBoxAttachment","newPathAttachment","PathAttachment","BlendMode","BoneData_1","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","appliedValid","sorted","setToSetupPose","updateWorldTransformWith","m","rotationY","la","cosDeg","lb","lc","sinDeg","ld","flipX","flipY","pa","pb","pc","pd","transformMode","TransformMode","Normal","OnlyTranslation","NoRotationOrReflection","prx","abs","atan2","radDeg","rx","ry","NoScale","NoScaleOrReflection","cos","sin","za","zc","sqrt","PI","zb","zd","InheritRotation","temp","InheritScale","psx","psy","getWorldRotationX","getWorldRotationY","getWorldScaleX","getWorldScaleY","worldToLocalRotationX","pm","worldToLocalRotationY","rotateWorld","updateAppliedTransform","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","det","worldToLocal","world","invDet","localToWorld","local","BoneData","Event","EventData","IkConstraint","level","findBone","getOrder","order","apply1","worldX","worldY","apply2","targetX","targetY","pp","rotationIK","child","bendDir","px","py","csx","os1","os2","s2","cx","cy","cwx","cwy","ppm","l1","l2","a1","a2","outer","acos","aa","bb","dd","ta","c1","c2","q","r1","minAngle","minDist","minX","minY","maxAngle","maxDist","maxX","maxY","angle","os","IkConstraintData","PathConstraintData_1","PathConstraint","spaces","positions","lengths","segments","findSlot","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","length_1","max","computeWorldPositions","positionMode","PositionMode","Percent","boneX","boneY","offsetRotation","tip","Chain","p","length_2","length_3","PI2","percentPosition","percentSpacing","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","pathLength_1","curve","space","BEFORE","computeWorldVerticesWith","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","x1","y1","x2","y2","w","curveLength","segment","length_5","length_6","isNaN","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Slot_1","Bone_1","IkConstraint_1","TransformConstraint_1","PathConstraint_1","_updateCache","updateCacheReset","boneData","parent_1","slotData","Slot","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","Color","updateCache","ikCount","transformCount","pathCount","constraintCount","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","constrained","indexOf","sortReset","slotBone","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","attachments","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBounds","offset","POSITIVE_INFINITY","NEGATIVE_INFINITY","updateWorldVertices","min","SkeletonBounds","boundingBoxes","polygons","polygonPool","Pool","updateAabb","slotCount","boundingBox","polygon","obtain","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonData","animations","fps","findEvent","eventDataName","findPathConstraintIndex","pathConstraintName","SkeletonData_1","SlotData_1","Event_1","IkConstraintData_1","TransformConstraintData_1","Skin_1","EventData_1","Animation_1","SkeletonJson","attachmentLoader","linkedMeshes","readSkeletonData","json","root","JSON","parse","skeletonMap","hash","imagesPath","images","boneMap","parentName","getValue","hasOwnProperty","transformModeLegacy","transformModeFromString","slotMap","SlotData","setFromString","blendModeFromString","ik","constraintMap","j","targetName","TransformConstraintData","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","parent_2","setParentMesh","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","box","readVertices","parent_3","inheritDeform","LinkedMesh","hullLength","newArray","toFloatArray","weights","timelineName","timelineMap","timeline","valueMap","readCurve","timelineScale","paths","deform","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","toString","prop","defaultValue","str","BLEND_MODES","MULTIPLY","ADD","SCREEN","NORMAL","toLowerCase","inheritRotation","inheritScale","dictionary","oldSkin","skinAttachment","attachmentTime","setAttachmentTime","getAttachmentTime","setFromColor","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","crop","trim","orig","_uvs","x0","y0","spineOffsetY","Texture_1","TextureAtlas","atlasText","textureLoader","callback","pages","regions","addSpineAtlas","addTexture","page","baseTexture","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","substr","lastIndexOf","load","_this","reader","TextureAtlasReader","tuple","iterateParser","line","readLine","readTuple","parseInt","direction","readValue","hasLoaded","setFilters","log","resolution","Rectangle","frame2","clone","_updateUvs","dispose","lines","split","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","arguments","Vector2","tb","tc","td","modified","ts","by","hex","charAt","WHITE","RED","GREEN","BLUE","MAGENTA","signum","ceil","cbrt","pow","radiansToDegrees","degreesToRadians","source","sourceStart","dest","destStart","numElements","array","oldSize","SUPPORTS_TYPED_ARRAYS","DebugUtils","logBones","instantiator","items","pop","free","item","clear","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Attachment","worldVertices","deformArray","v","skip","skeletonBones","wx","wy","vx","vy","weight","v_1","sourceAttachment","AttachmentType","Attachment_1","tempColor","premultipliedAlpha","w1","h1","w2","h2","pixiOffsetY","parentMesh","getParentMesh","AttachmentType_1","BoundingBoxAttachment_1","MeshAttachment_1","PathAttachment_1","RegionAttachment_1","__export","AnimationState_1","AnimationStateData_1","BlendMode_1","Skeleton_1","SkeletonBounds_1","SkeletonJson_1","TextureAtlas_1","AtlasAttachmentLoader_1","atlasParser","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","replace","baseUrl","atlasOptions","crossOrigin","xhrType","loaders","Resource","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","imageLoaderAdapter","xhr","responseText","loader","namePrefix","syncImageLoaderAdapter","BaseTexture","fromImage","Loader","addPixiMiddleware","use","core","Spine_1"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import * as spine from \"./core\";\nimport {atlasParser} from \"./loaders\";\nimport {Attachment, VertexAttachment} from \"./core/attachments/Attachment\";\nimport {TextureAtlasRegion} from \"./core/TextureAtlas\";\nvar TransformBase = PIXI.TransformBase;\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\nlet tempRgb = [0, 0, 0];\n\nexport class SpineSprite extends PIXI.Sprite {\n    region: spine.TextureRegion;\n\n    constructor(tex: PIXI.Texture) {\n        super(tex);\n    }\n}\n\nexport class SpineMesh extends PIXI.mesh.Mesh {\n    region: spine.TextureRegion;\n\n    constructor(texture: PIXI.Texture, vertices?: ArrayLike<number>, uvs?: ArrayLike<number>, indices?: ArrayLike<number>, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport class Spine extends PIXI.Container {\n    static globalAutoUpdate: boolean = true;\n\n    tintRgb: ArrayLike<number>;\n    spineData: spine.SkeletonData;\n    skeleton: spine.Skeleton;\n    stateData: spine.AnimationStateData;\n    state: spine.AnimationState;\n    slotContainers: Array<PIXI.Container>;\n\n    constructor(spineData: spine.SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if ((typeof spineData) === \"string\") {\n            throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.skeleton = new spine.Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n\n        /**\n         * A spine AnimationStateData object created from the spine data passed in the constructor\n         *\n         * @member {object}\n         */\n        this.stateData = new spine.AnimationStateData(spineData);\n\n        /**\n         * A spine AnimationState object created from the spine AnimationStateData object\n         *\n         * @member {object}\n         */\n        this.state = new spine.AnimationState(this.stateData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            var slot = this.skeleton.slots[i];\n            var attachment : any = slot.attachment;\n            var slotContainer = new PIXI.Container();\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n\n            if (attachment instanceof spine.RegionAttachment) {\n                var spriteName = (attachment.region as TextureAtlasRegion).name;\n                var sprite = this.createSprite(slot, attachment, spriteName);\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                var mesh = this.createMesh(slot, attachment);\n                slot.currentMesh = mesh;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            }\n            else {\n                continue;\n            }\n\n        }\n\n        /**\n         * Should the Spine object update its transforms\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof PIXI.spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof PIXI.spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n    }\n\n    set autoUpdate(value: boolean) {\n        this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return PIXI.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n        this.skeleton.updateWorldTransform();\n\n        let drawOrder = this.skeleton.drawOrder;\n        let slots = this.skeleton.slots;\n\n        for (var i = 0, n = drawOrder.length; i < n; i++) {\n            this.children[i] = this.slotContainers[drawOrder[i].data.index];\n        }\n\n        var r0 = this.tintRgb[0];\n        var g0 = this.tintRgb[1];\n        var b0 = this.tintRgb[2];\n\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slot = slots[i];\n            var attachment = slot.attachment;\n            var slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            var attColor = (attachment as any).color;\n            if (attachment instanceof spine.RegionAttachment) {\n                let region = (attachment as spine.RegionAttachment).region;\n                if (region) {\n                    let ar = region as TextureAtlasRegion;\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                        var spriteName = ar.name;\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        }\n                        else {\n                            var sprite = this.createSprite(slot, attachment, spriteName);\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n                    }\n                }\n\n                if (slotContainer.transform) {\n                    var transform = slotContainer.transform;\n                    let lt : PIXI.Matrix;\n                    if (slotContainer.transform.matrix2d) {\n                        //gameofbombs pixi fork\n                        lt = transform.matrix2d;\n                        transform._dirtyVersion++;\n                        transform.version = transform._dirtyVersion;\n                        transform.isStatic = true;\n                        transform.operMode = 0;\n                    } else {\n                        if (TransformBase) {\n                            //PIXI v4.0\n                            if (transform.position) {\n                                transform = new PIXI.TransformBase();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                        } else {\n                            //PIXI v4.0rc\n                            if (!transform._dirtyLocal) {\n                                transform = new PIXI.TransformStatic();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                            transform._dirtyParentVersion = -1;\n                            transform._dirtyLocal = 1;\n                            transform._versionLocal = 1;\n                        }\n                    }\n                    slot.bone.matrix.copy(lt);\n                } else {\n                    //PIXI v3\n                    var lt = slotContainer.localTransform || new PIXI.Matrix();\n                    slot.bone.matrix.copy(lt);\n                    slotContainer.localTransform = lt;\n                    slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                }\n                tempRgb[0] = r0 * slot.color.r * attColor.r;\n                tempRgb[1] = g0 * slot.color.g * attColor.g;\n                tempRgb[2] = b0 * slot.color.b * attColor.b;\n                slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                slot.currentSprite.blendMode = slot.blendMode;\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                    var meshName = attachment.name;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                    }\n\n                    slot.meshes = slot.meshes || {};\n\n                    if (slot.meshes[meshName] !== undefined) {\n                        slot.meshes[meshName].visible = true;\n                    }\n                    else {\n                        var mesh = this.createMesh(slot, attachment);\n                        slotContainer.addChild(mesh);\n                    }\n\n                    slot.currentMesh = slot.meshes[meshName];\n                    slot.currentMeshName = meshName;\n                }\n                (attachment as VertexAttachment).computeWorldVertices(slot, slot.currentMesh.vertices);\n                if (PIXI.VERSION[0] !== '3') {\n                    // PIXI version 4\n                    // slot.currentMesh.dirty++;\n                    //only for PIXI v4\n                    var tintRgb = slot.currentMesh.tintRgb;\n                    tintRgb[0] = r0 * slot.color.r * attColor.r;\n                    tintRgb[1] = g0 * slot.color.g * attColor.g;\n                    tintRgb[2] = b0 * slot.color.b * attColor.b;\n                }\n                slot.currentMesh.blendMode = slot.blendMode;\n            }\n            else {\n                slotContainer.visible = false;\n                continue;\n            }\n            slotContainer.visible = true;\n\n            slotContainer.alpha = slot.color.a;\n        }\n    };\n\n    private setSpriteRegion(attachment: spine.RegionAttachment, sprite: SpineSprite, region: spine.TextureRegion) {\n        sprite.region = region;\n        sprite.texture = region.texture;\n        if (!region.size) {\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n        } else {\n            //hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: spine.MeshAttachment, mesh: SpineMesh, region: spine.TextureRegion) {\n        mesh.region = region;\n        mesh.texture = region.texture;\n        attachment.updateUVs(region, mesh.uvs);\n        // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n        // } else {\n            // PIXI version 3\n        mesh.dirty++;\n        // }\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (Spine.globalAutoUpdate) {\n            this.lastTime = this.lastTime || Date.now();\n            var timeDelta = (Date.now() - this.lastTime) * 0.001;\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        PIXI.Container.prototype.updateTransform.call(this);\n    };\n\n    /**\n     * Create a new sprite to be used with spine.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: spine.Slot, attachment: spine.RegionAttachment, defName: string) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        var texture = region.texture;\n        var sprite = new SpineSprite(texture);\n        sprite.rotation = attachment.rotation * spine.MathUtils.degRad;\n        sprite.anchor.x = 0.5;\n        sprite.anchor.y = 0.5;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        sprite.region = attachment.region;\n        this.setSpriteRegion(attachment, sprite, attachment.region);\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[defName] = sprite;\n        return sprite;\n    };\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: spine.Slot, attachment: spine.MeshAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        let strip = new SpineMesh(\n            region.texture,\n            new Float32Array(attachment.regionUVs.length),\n            new Float32Array(attachment.regionUVs.length),\n            new Uint16Array(attachment.triangles),\n            PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n        strip.canvasPadding = 1.5;\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        this.setMeshRegion(attachment, strip, region);\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.name] = strip;\n        return strip;\n    };\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var slot = this.skeleton.slots[slotIndex];\n        if (!slot) {\n            return false;\n        }\n        var attachment: any = slot.attachment;\n        var region: spine.TextureRegion = attachment.region;\n        if (texture) {\n            region = new spine.TextureRegion();\n            region.texture = texture;\n            region.size = size;\n        }\n        if (slot.currentSprite && slot.currentSprite.region != region) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n            slot.currentSprite.region = region;\n        } else\n        if (slot.currentMesh && slot.currentMesh.region != region) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        } else {\n            slot.tempRegion = region;\n            slot.tempAttachment = attachment;\n        }\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName = function (slotName: String, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var index = this.skeleton.findSlotIndex(slotName);\n        if (index == -1) {\n            return false;\n        }\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n}\n\nfunction SlotContainerUpdateTransformV3() {\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n}\n","import {Event} from \"./Event\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Utils, MathUtils, Color, ArrayLike} from \"./Utils\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {VertexAttachment, Attachment} from \"./attachments\";\nimport {Slot} from \"./Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Animation {\n    name: string;\n    timelines: Array<Timeline>;\n    duration: number;\n\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n    }\n\n    mix (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n    }\n\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n        if (high == 0) return step;\n        let current = high >>> 1;\n        while (true) {\n            if (values[(current + 1) * step] <= target)\n                low = current + 1;\n            else\n                high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step)\n            if (values[i] > target) return i;\n        return -1;\n    }\n}\n\nexport interface Timeline {\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    constructor (frameCount: number) {\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    getFrameCount () {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    setLinear (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    setStepped (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    getCurveType (frameIndex: number): number {\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        let type = this.curves[index];\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let curves = this.curves;\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx, y = dfy;\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    getCurvePercent (frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        let curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let type = curves[i];\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number, prevY: number;\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        let y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n            let amount = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent((frame >> 1) - 1,\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let amount = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (prevRotation + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n}\n\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n    static X = 1; static Y = 2;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length + TranslateTimeline.PREV_X] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length + TranslateTimeline.PREV_Y] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n        let prevX = frames[frame + TranslateTimeline.PREV_X];\n        let prevY = frames[frame + TranslateTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n        bone.x += (bone.data.x + prevX + (frames[frame + TranslateTimeline.X] - prevX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevY + (frames[frame + TranslateTimeline.Y] - prevY) * percent - bone.y) * alpha;\n    }\n}\n\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length + ScaleTimeline.PREV_X] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length + ScaleTimeline.PREV_Y] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n        let prevX = frames[frame + ScaleTimeline.PREV_X];\n        let prevY = frames[frame + ScaleTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n        bone.scaleX += (bone.data.scaleX * (prevX + (frames[frame + ScaleTimeline.X] - prevX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevY + (frames[frame + ScaleTimeline.Y] - prevY) * percent) - bone.scaleY) * alpha;\n    }\n}\n\nexport class ShearTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n            bone.shearX += (bone.data.shearX + frames[frames.length + ShearTimeline.PREV_X] - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY + frames[frames.length + ShearTimeline.PREV_Y] - bone.shearY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n        let prevX = frames[frame + ShearTimeline.PREV_X];\n        let prevY = frames[frame + ShearTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n        bone.shearX += (bone.data.shearX + (prevX + (frames[frame + ShearTimeline.X] - prevX) * percent) - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + (prevY + (frames[frame + ShearTimeline.Y] - prevY) * percent) - bone.shearY) * alpha;\n    }\n}\n\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n    static R = 1; static G = 2; static B = 3; static A = 4;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let r = 0, g = 0, b = 0, a = 0;\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        let color: Color = skeleton.slots[this.slotIndex].color;\n        if (alpha < 1)\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        else\n            color.set(r, g, b, a);\n    }\n}\n\nexport class AttachmentTimeline implements Timeline {\n    slotIndex: number;\n    frames: ArrayLike<number> // time, ...\n    attachmentNames: Array<string>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameIndex = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        let attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex]\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nexport class EventTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    events: Array<Event>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > lastTime and <= time. */\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        if (firedEvents == null) return;\n        let frames = this.frames;\n        let frameCount = this.frames.length;\n\n        if (lastTime > time) { // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (lastTime < frames[0])\n            frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            let frameTime = frames[frame];\n            while (frame > 0) { // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++)\n            firedEvents.push(this.events[frame]);\n    }\n}\n\nexport class DrawOrderTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    drawOrders: Array<Array<number>>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe.\n     * @param drawOrder May be null to use bind pose draw order. */\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frame = frames.length - 1;\n        else\n            frame = Animation.binarySearch(frames, time) - 1;\n\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\n        let slots: Array<Slot> = skeleton.slots;\n        let drawOrderToSetupIndex = this.drawOrders[frame];\n        if (drawOrderToSetupIndex == null)\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\nexport class DeformTimeline extends CurveTimeline {\n    frames: ArrayLike<number>; // time, ...\n    frameVertices: Array<ArrayLike<number>>;\n    slotIndex: number;\n    attachment: VertexAttachment;\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let slot: Slot = skeleton.slots[this.slotIndex];\n        let slotAttachment: Attachment = slot.getAttachment();\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameVertices = this.frameVertices;\n        let vertexCount = frameVertices[0].length;\n\n        let verticesArray: Array<number> = slot.attachmentVertices;\n        if (verticesArray.length != vertexCount) alpha = 1; // Don't mix from uninitialized slot vertices.\n        let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\n            let lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1) {\n                for (let i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else\n                Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time);\n        let prevVertices = frameVertices[frame - 1];\n        let nextVertices = frameVertices[frame];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha < 1) {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n}\n\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\n    static MIX = 1; static BEND_DIRECTION = 2;\n\n    ikConstraintIndex: number;\n    frames: ArrayLike<number>; // time, mix, bendDirection, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time, mix and bend direction of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n            constraint.bendDirection = Math.floor(frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n    }\n}\n\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n    transformConstraintIndex: number;\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + TransformConstraintTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + TransformConstraintTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i + TransformConstraintTimeline.PREV_SCALE] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i + TransformConstraintTimeline.PREV_SHEAR] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n        let rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n        let translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n        let scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n        let shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n        constraint.rotateMix += (rotate + (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent - constraint.shearMix) * alpha;\n    }\n}\n\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.position += (frames[i + PathConstraintPositionTimeline.PREV_VALUE] - constraint.position) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n        let position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n        constraint.position += (position + (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent - constraint.position) * alpha;\n    }\n}\n\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.spacing += (frames[i + PathConstraintSpacingTimeline.PREV_VALUE] - constraint.spacing) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n        let spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n        constraint.spacing += (spacing + (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent - constraint.spacing) * alpha;\n    }\n}\n\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n    static ROTATE = 1; static TRANSLATE = 2;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + PathConstraintMixTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + PathConstraintMixTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n        let rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n        let translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n        constraint.rotateMix += (rotate + (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, Utils} from \"./Utils\";\r\nimport {Animation} from \"./Animation\";\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from \"./Event\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class AnimationState {\r\n    data: AnimationStateData;\r\n    tracks = new Array<TrackEntry>();\r\n    events = new Array<Event>();\r\n    timeScale = 1;\r\n\r\n    constructor (data: AnimationStateData = null) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n    }\r\n\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n            let current = this.tracks[i];\r\n            if (current == null) continue;\r\n\r\n            let next = current.next;\r\n            if (next != null) {\r\n                let nextTime = current.lastTime - next.delay;\r\n                if (nextTime >= 0) {\r\n                    let nextDelta = delta * next.timeScale;\r\n                    next.time = nextTime + nextDelta; // For start event to see correct time.\r\n                    current.time += delta * current.timeScale; // For end event to see correct time.\r\n                    this.setCurrent(i, next);\r\n                    next.time -= nextDelta; // Prevent increasing time twice, below.\r\n                    current = next;\r\n                }\r\n            } else if (!current.loop && current.lastTime >= current.endTime) {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                this.clearTrack(i);\r\n                continue;\r\n            }\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous != null) {\r\n                let previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    apply (skeleton: Skeleton) {\r\n        let events = this.events;\r\n\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n            let current = this.tracks[i];\r\n            if (current == null) continue;\r\n\r\n            events.length = 0;\r\n\r\n            let time = current.time;\r\n            let lastTime = current.lastTime;\r\n            let endTime = current.endTime;\r\n            let loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            let previous = current.previous;\r\n            if (previous == null)\r\n                current.animation.mix(skeleton, lastTime, time, loop, events, current.mix);\r\n            else {\r\n                let previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                let alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1) {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, lastTime, time, loop, events, alpha);\r\n            }\r\n\r\n            for (let ii = 0, nn = events.length; ii < nn; ii++) {\r\n                let event = events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {\r\n                let count = MathUtils.toInt(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    }\r\n\r\n    clearTracks () {\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    }\r\n\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (current == null) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n\r\n        this.freeAll(current);\r\n    }\r\n\r\n    freeAll (entry: TrackEntry) {\r\n        while (entry != null) {\r\n            let next = entry.next;\r\n            entry = next;\r\n        }\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.setArraySize(this.tracks, index - this.tracks.length + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    setCurrent (index: number, entry: TrackEntry) {\r\n        let current = this.expandToIndex(index);\r\n        if (current != null) {\r\n            let previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (entry.onEnd) entry.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0) {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous != null && current.mixTime / current.mixDuration < 0.5) {\r\n                    entry.previous = previous;\r\n                    previous = current;\r\n                } else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    }\r\n\r\n    /** @see #setAnimation(int, Animation, boolean) */\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current != null) this.freeAll(current.next);\r\n\r\n        let entry = new TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    }\r\n\r\n    /** {@link #addAnimation(int, Animation, boolean, float)} */\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    hasAnimation(animationName: string): boolean\r\n    {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n        let entry = new TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last != null) {\r\n            while (last.next != null)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0) {\r\n            if (last != null)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n    setAnimationByName (trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n    addAnimationByName (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n    hasAnimationByName (animationName: string): boolean\r\n    {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n}\r\n\r\nexport class TrackEntry {\r\n    next: TrackEntry; previous: TrackEntry;\r\n    animation: Animation;\r\n    loop = false;\r\n    delay = 0; time = 0; lastTime = -1; endTime = 0; timeScale = 1;\r\n    mixTime = 0; mixDuration = 0;\r\n    mix = 1;\r\n\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    reset () {\r\n        this.next = null;\r\n        this.previous = null;\r\n        this.animation = null;\r\n        this.timeScale = 1;\r\n        this.lastTime = -1; // Trigger events on frame zero.\r\n        this.time = 0;\r\n    }\r\n\r\n    /** Returns true if the current time is greater than the end time, regardless of looping. */\r\n    isComplete () : boolean {\r\n        return this.time >= this.endTime;\r\n    }\r\n}\r\n","import {Animation} from \"./Animation\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationStateData {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = { };\n    defaultMix = 0;\n\n    constructor (skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n        this.skeletonData = skeletonData;\n    }\n\n    setMix (fromName: string, toName: string, duration: number) {\n        let from = this.skeletonData.findAnimation(fromName);\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\n        let to = this.skeletonData.findAnimation(toName);\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1: boolean = false;\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith (from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error(\"from cannot be null.\");\n        if (to == null) throw new Error(\"to cannot be null.\");\n        let key = from.name + to.name;\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix (from: Animation, to: Animation) {\n        let key = from.name + to.name;\n        let value = this.animationToMixTime[key];\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","import {Skin} from \"./Skin\";\nimport {AttachmentLoader, BoundingBoxAttachment, MeshAttachment, PathAttachment, RegionAttachment} from \"./attachments\";\nimport {TextureAtlas} from \"./TextureAtlas\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor (atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n        let attachment = new RegionAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment (skin: Skin, name: string, path: string) : MeshAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n        let attachment = new MeshAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment (skin: Skin, name: string) : BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment (skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport enum BlendMode {\r\n    Normal,\r\n    Additive,\r\n    Multiply,\r\n    Screen\r\n}\r\n","import {Updatable} from \"./Updatable\";\nimport {BoneData, TransformMode} from \"./BoneData\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils, Vector2} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Bone implements Updatable {\n    static yDown: boolean = false;\n    //be careful! Spine b,c is c,b in pixi matrix\n    matrix = new PIXI.Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0; y = 0; rotation = 0; scaleX = 0; scaleY = 0; shearX = 0; shearY = 0;\n    ax = 0; ay = 0; arotation = 0; ascaleX = 0; ascaleY = 0; ashearX = 0; ashearY = 0;\n    appliedValid = false;\n\n    sorted = false;\n\n    /** @param parent May be null. */\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) { // Root bone.\n            let rotationY = rotation + 90 + shearY;\n            let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n            let lb = MathUtils.cosDeg(rotationY) * scaleY;\n            let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n            let ld = MathUtils.sinDeg(rotationY) * scaleY;\n            let skeleton = this.skeleton;\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x + skeleton.x;\n            m.ty = y + skeleton.y;\n            return;\n        }\n\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                let rotationY = rotation + 90 + shearY;\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                let rotationY = rotation + 90 + shearY;\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                let rx = rotation + shearX - prx;\n                let ry = rotation + shearY - prx + 90;\n                let la = MathUtils.cosDeg(rx) * scaleX;\n                let lb = MathUtils.cosDeg(ry) * scaleY;\n                let lc = MathUtils.sinDeg(rx) * scaleX;\n                let ld = MathUtils.sinDeg(ry) * scaleY;\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                let cos = MathUtils.cosDeg(rotation);\n                let sin = MathUtils.sinDeg(rotation);\n                let za = pa * cos + pb * sin;\n                let zc = pc * cos + pd * sin;\n                let s = Math.sqrt(za * za + zc * zc);\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                let r = Math.PI / 2 + Math.atan2(zc, za);\n                let zb = Math.cos(r) * s;\n                let zd = Math.sin(r) * s;\n                let la = MathUtils.cosDeg(shearX) * scaleX;\n                let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                let lc = MathUtils.sinDeg(shearX) * scaleX;\n                let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                if (this.data.transformMode != TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : (this.skeleton.flipX != this.skeleton.flipY) != Bone.yDown) {\n                    m.b = -m.b;\n                    m.d = -m.d;\n                }\n                return;\n            }\n            //old < 3.5 stuff\n            case TransformMode.InheritRotation: {\n                let rotationY = rotation + 90 + shearY;\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.arotation), sin = MathUtils.sinDeg(parent.arotation);\n                    let temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (parent.data.transformMode === TransformMode.InheritScale ||\n                        parent.data.transformMode === TransformMode.OnlyTranslation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            //old < 3.5 stuff\n            case TransformMode.InheritScale: {\n                let rotationY = rotation + 90 + shearY;\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.arotation), sin = MathUtils.sinDeg(parent.arotation);\n                    let psx = parent.scaleX, psy = parent.scaleY;\n                    let za = cos * psx, zb = sin * psy, zc = sin * psx, zd = cos * psy;\n                    let temp = pa * za + pb * zc;\n                    pb = pb * zd - pa * zb;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pd * zd - pc * zb;\n                    pc = temp;\n\n                    if (psx >= 0) sin = -sin;\n                    temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (parent.data.transformMode === TransformMode.InheritRotation ||\n                        parent.data.transformMode === TransformMode.OnlyTranslation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n        }\n        if (this.skeleton.flipX) {\n            m.a = -m.a;\n            m.c = -m.c;\n        }\n        if (this.skeleton.flipY != Bone.yDown) {\n            m.b = -m.b;\n            m.d = -m.d;\n        }\n    }\n\n    setToSetupPose () {\n        let data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX () {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY () {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX () {\n        let m = this.matrix;\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n    }\n\n    getWorldScaleY () {\n        let m = this.matrix;\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n    }\n\n    worldToLocalRotationX () {\n        let parent = this.parent;\n        if (parent == null) return this.arotation;\n        let pm = parent.matrix, m = this.matrix;\n        return Math.atan2(pm.a * m.b - pm.b * m.a, pm.d * m.a - pm.c * m.b) * MathUtils.radDeg;\n    }\n\n    worldToLocalRotationY () {\n        let parent = this.parent;\n        if (parent == null) return this.arotation;\n        let pm = parent.matrix, m = this.matrix;\n        return Math.atan2(pm.a * m.d - pm.b * m.c, pm.d * m.c - pm.c * m.d) * MathUtils.radDeg;\n    }\n\n    rotateWorld (degrees: number) {\n        let m = this.matrix;\n        let a = this.matrix.a, b = m.c, c = m.b, d = m.d;\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n        m.a = cos * a - sin * c;\n        m.c = cos * b - sin * d;\n        m.b = sin * a + cos * c;\n        m.d = sin * b + cos * d;\n        this.appliedValid = false;\n    }\n\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n    updateAppliedTransform () {\n        this.appliedValid = true;\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n            return;\n        }\n        let pm = parent.matrix;\n        let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n        this.ax = (dx * pm.d * pid - dy * pm.c * pid);\n        this.ay = (dy * pm.a * pid - dx * pm.b * pid);\n        let ia = pid * pm.d;\n        let id = pid * pm.a;\n        let ib = pid * pm.c;\n        let ic = pid * pm.b;\n        let ra = ia * m.a - ib * m.b;\n        let rb = ia * m.c - ib * m.d;\n        let rc = id * m.b - ic * m.a;\n        let rd = id * m.d - ic * m.c;\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            let det = ra * rd - rb * rc;\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    worldToLocal (world: Vector2) {\n        let m = this.matrix;\n        let a = m.a, b = m.c, c = m.b, d = m.d;\n        let invDet = 1 / (a * d - b * c);\n        let x = world.x - m.tx, y = world.y - m.ty;\n        world.x = (x * d * invDet - y * b * invDet);\n        world.y = (y * a * invDet - x * c * invDet);\n        return world;\n    }\n\n    localToWorld (local: Vector2) {\n        let m = this.matrix;\n        let x = local.x, y = local.y;\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n        return local;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0; y = 0; rotation = 0; scaleX = 1; scaleY = 1; shearX = 0; shearY = 0;\n    transformMode = TransformMode.Normal;\n\n    constructor (index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n\nexport enum TransformMode {\n    Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection, InheritRotation, InheritScale\n}\n","import {EventData} from \"./EventData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Event {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n\r\n    constructor (time: number, data: EventData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class EventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import {IkConstraintData} from \"./IkConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils} from \"./Utils\";\nimport {Constraint} from \"./Constraint\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraint implements Constraint {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    mix = 1;\n    bendDirection = 0;\n\n    level = 0;\n\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    getOrder () {\n        return this.data.order;\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let target = this.target;\n        let bones = this.bones;\n        switch (bones.length) {\n        case 1:\n            this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        let pp = bone.parent.matrix;\n        let id = 1 / (pp.a * pp.d - pp.b * pp.c);\n        let x = targetX - pp.tx, y = targetY - pp.ty;\n        let tx = (x * pp.d - y * pp.c) * id - bone.ax, ty = (y * pp.a - x * pp.b) * id - bone.ay;\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180)\n            rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX,\n            bone.ashearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n            return;\n        }\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;\n\n        let os1 = 0, os2 = 0, s2 = 0;\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else\n            os2 = 0;\n        let pm = parent.matrix;\n        let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pm.a, b = pm.c, c = pm.b, d = pm.d;\n        let u = Math.abs(psx - psy) <= 0.0001;\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pm.tx;\n            cwy = c * cx + pm.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pm.tx;\n            cwy = c * cx + d * cy + pm.ty;\n        }\n        let pp = parent.parent;\n        let ppm = parent.parent.matrix;\n        a = ppm.a;\n        b = ppm.c;\n        c = ppm.b;\n        d = ppm.d;\n        let id = 1 / (a * d - b * c), x = targetX - ppm.tx, y = targetY - ppm.ty;\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n        x = cwx - ppm.tx;\n        y = cwy - ppm.ty;\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n        outer:\n        if (u) {\n            l2 *= psx;\n            let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            let c1 = -2 * bb * l1, c2 = bb - aa;\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                let r0 = q / c2, r1 = c / q;\n                let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            let minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;\n            let maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            x = l1 + a;\n            d = x * x;\n            if (d > maxDist) {\n                maxAngle = 0;\n                maxDist = d;\n                maxX = x;\n            }\n            x = l1 - a;\n            d = x * x;\n            if (d < minDist) {\n                minAngle = MathUtils.PI;\n                minDist = d;\n                minX = x;\n            }\n            let angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            y = b * Math.sin(angle);\n            d = x * x + y * y;\n            if (d < minDist) {\n                minAngle = angle;\n                minDist = d;\n                minX = x;\n                minY = y;\n            }\n            if (d > maxDist) {\n                maxAngle = angle;\n                maxDist = d;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        let os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180)\n            a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180)\n            a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    mix = 1;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n","import {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Slot} from \"./Slot\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathAttachment} from \"./attachments\";\nimport {Utils, MathUtils} from \"./Utils\";\nimport {Constraint} from \"./Constraint\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraint implements Constraint {\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\n\n    spaces = new Array<number>(); positions = new Array<number>();\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n    segments = new Array<number>();\n\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let attachment = this.target.getAttachment();\n        if (!(attachment instanceof PathAttachment)) return;\n\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\n        let translate = translateMix > 0, rotate = rotateMix > 0;\n        if (!translate && !rotate) return;\n\n        let data = this.data;\n        let spacingMode = data.spacingMode;\n        let lengthSpacing = spacingMode == SpacingMode.Length;\n        let rotateMode = data.rotateMode;\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n        let bones = this.bones;\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\n        let spacing = this.spacing;\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n;) {\n                let bone = bones[i];\n                let m = bone.matrix;\n                let length = bone.data.length, x = length * m.a, y = length * m.b;\n                length = Math.sqrt(x * x + y * y);\n                if (scale) lengths[i] = length;\n                spaces[++i] = lengthSpacing ? Math.max(0, length + spacing) : spacing;\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++)\n                spaces[i] = spacing;\n        }\n\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n        let tip = rotateMode == RotateMode.Chain && offsetRotation == 0;\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            let bone = bones[i];\n            let m = bone.matrix;\n            m.tx += (boneX - m.tx) * translateMix;\n            m.ty += (boneY - m.ty) * translateMix;\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n            if (scale) {\n                let length = lengths[i];\n                if (length != 0) {\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n                    m.a *= s;\n                    m.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                let a = m.a, b = m.c, c = m.b, d = m.d, r = 0, cos = 0, sin = 0;\n                if (tangents)\n                    r = positions[p - 1];\n                else if (spaces[i + 1] == 0)\n                    r = positions[p + 2];\n                else\n                    r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a) - offsetRotation * MathUtils.degRad;\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    let length = bone.data.length;\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                }\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n            }\n            bone.appliedValid = false;\n        }\n    }\n\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\n        percentSpacing: boolean) {\n        let target = this.target;\n        let position = this.position;\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\n        let closed = path.closed;\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            let lengths = path.lengths;\n            curveCount -= closed ? 1 : 2;\n            let pathLength = lengths[curveCount];\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                let space = spaces[i];\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVerticesWith(target, 2, 4, world, 0);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (;; curve++) {\n                    let length = lengths[curve];\n                    if (p > length) continue;\n                    if (curve == 0)\n                        p /= length;\n                    else {\n                        let prev = lengths[curve - 1];\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);\n                        path.computeWorldVerticesWith(target, 0, 4, world, 4);\n                    } else\n                        path.computeWorldVerticesWith(target, curve * 6 + 2, 8, world, 0);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n                    tangents || (i > 0 && space == 0));\n            }\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);\n            path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);\n        }\n\n        // Curve lengths.\n        let curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++)\n                spaces[i] *= pathLength;\n        }\n\n        let segments = this.segments;\n        let curveLength = 0;\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            let space = spaces[i];\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (;; curve++) {\n                let length = curves[curve];\n                if (p > length) continue;\n                if (curve == 0)\n                    p /= length;\n                else {\n                    let prev = curves[curve - 1];\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (;; segment++) {\n                let length = segments[segment];\n                if (p > length) continue;\n                if (segment == 0)\n                    p /= length;\n                else {\n                    let prev = segments[segment - 1];\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n        return out;\n    }\n\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n        out: Array<number>, o: number, tangents: boolean) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n\n    getOrder () {\n        return this.data.order;\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number; spacing: number; rotateMix: number; translateMix: number;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n\nexport enum PositionMode {\n    Fixed, Percent\n}\n\nexport enum SpacingMode {\n    Length, Fixed, Percent\n}\n\nexport enum RotateMode {\n    Tangent, Chain, ChainScale\n}\n","import {Slot} from \"./Slot\";\nimport {Bone} from \"./Bone\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Color, Utils, Vector2} from \"./Utils\";\nimport {Skin} from \"./Skin\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Updatable} from \"./Updatable\";\nimport {Attachment, PathAttachment, RegionAttachment, MeshAttachment} from \"./attachments\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skeleton {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    updateCacheReset = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    flipX = false; flipY = false;\n    x = 0; y = 0;\n\n    constructor (data: SkeletonData) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            let boneData = data.bones[i];\n            let bone: Bone;\n            if (boneData.parent == null)\n                bone = new Bone(boneData, this, null);\n            else {\n                let parent = this.bones[boneData.parent.index];\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            let slotData = data.slots[i];\n            let bone = this.bones[slotData.boneData.index];\n            let slot = new Slot(slotData, bone);\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            let ikConstraintData = data.ikConstraints[i];\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            let transformConstraintData = data.transformConstraints[i];\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            let pathConstraintData = data.pathConstraints[i];\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache () {\n        let updateCache = this._updateCache;\n        updateCache.length = 0;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].sorted = false;\n\n        let ikConstraints = this.ikConstraints;\n        let transformConstraints = this.transformConstraints;\n        let pathConstraints = this.pathConstraints;\n        let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n        let constraintCount = ikCount + transformCount + pathCount;\n\n        outer:\n            for (let i = 0; i < constraintCount; i++) {\n                for (let ii = 0; ii < ikCount; ii++) {\n                    let constraint = ikConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortIkConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (let ii = 0; ii < transformCount; ii++) {\n                    let constraint = transformConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortTransformConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (let ii = 0; ii < pathCount; ii++) {\n                    let constraint = pathConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortPathConstraint(constraint);\n                        continue outer;\n                    }\n                }\n            }\n\n        for (let i = 0, n = bones.length; i < n; i++)\n            this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint (constraint: IkConstraint) {\n        let target = constraint.target;\n        this.sortBone(target);\n\n        let constrained = constraint.bones;\n        let parent = constrained[0];\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n            let child = constrained[constrained.length - 1];\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n    }\n\n    sortPathConstraint (constraint: PathConstraint) {\n        let slot = constraint.target;\n        let slotIndex = slot.data.index;\n        let slotBone = slot.bone;\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n            this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let ii = 0, nn = this.data.skins.length; ii < nn; ii++)\n            this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);\n\n        let attachment = slot.getAttachment();\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        let constrained = constraint.bones;\n        let boneCount = constrained.length;\n        for (let ii = 0; ii < boneCount; ii++)\n            this.sortBone(constrained[ii]);\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++)\n            this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++)\n            constrained[ii].sorted = true;\n    }\n\n    sortTransformConstraint (constraint: TransformConstraint) {\n        this.sortBone(constraint.target);\n\n        let constrained = constraint.bones;\n        let boneCount = constrained.length;\n        for (let ii = 0; ii < boneCount; ii++)\n            this.sortBone(constrained[ii]);\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++)\n            this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++)\n            constrained[ii].sorted = true;\n    }\n\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n        let attachments = skin.attachments[slotIndex];\n        if (!attachments) return;\n        for (let key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        let pathBones = (<PathAttachment>attachment).bones;\n        if (pathBones == null)\n            this.sortBone(slotBone);\n        else {\n            let bones = this.bones;\n            let i = 0;\n            while (i < pathBones.length) {\n                let boneCount = pathBones[i++];\n                for (let n = i + boneCount; i < n; i++) {\n                    let boneIndex = pathBones[i];\n                    this.sortBone(bones[boneIndex]);\n                }\n            }\n        }\n    }\n\n    sortBone (bone: Bone) {\n        if (bone.sorted) return;\n        let parent = bone.parent;\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset (bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform () {\n        let updateCacheReset = this.updateCacheReset;\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n            let bone = updateCacheReset[i] as Bone;\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n            bone.appliedValid = true;\n        }\n        let updateCache = this._updateCache;\n        for (let i = 0, n = updateCache.length; i < n; i++)\n            updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose () {\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.mix = constraint.data.mix;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            let data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            let data = constraint.data;\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose () {\n        let slots = this.slots;\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone () {\n        if (this.bones.length == 0) return null;\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.data.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName (skinName: string) {\n        let skin = this.data.findSkin(skinName);\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin (newSkin: Skin) {\n        if (newSkin != null) {\n            if (this.skin != null)\n                newSkin.attachAll(this, this.skin);\n            else {\n                let slots = this.slots;\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    let slot = slots[i];\n                    let name = slot.data.attachmentName;\n                    if (name != null) {\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    }\n\n    /** @return May be null. */\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n        if (this.skin != null) {\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment (slotName: string, attachmentName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null)\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw new Error(\"Slot not found: \" + slotName);\n    }\n\n    /** @return May be null. */\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let ikConstraint = ikConstraints[i];\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB. */\n    getBounds (offset: Vector2, size: Vector2) {\n        if (offset == null) throw new Error(\"offset cannot be null.\");\n        if (size == null) throw new Error(\"size cannot be null.\");\n        let drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            let slot = drawOrder[i];\n            let vertices: ArrayLike<number> = null;\n            let attachment = slot.getAttachment();\n            if (attachment instanceof RegionAttachment)\n                vertices = (<RegionAttachment>attachment).updateWorldVertices(slot, false);\n            else if (attachment instanceof MeshAttachment) //\n                vertices = (<MeshAttachment>attachment).updateWorldVertices(slot, true);\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 8) {\n                    let x = vertices[ii], y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update (delta: number) {\n        this.time += delta;\n    }\n}\n","import {Utils, Pool} from \"./Utils\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {BoundingBoxAttachment} from \"./attachments\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SkeletonBounds {\r\n    minX = 0; minY = 0; maxX = 0; maxY = 0;\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n    polygons = new Array<ArrayLike<number>>();\r\n    private polygonPool = new Pool<ArrayLike<number>>(() => {\r\n        return Utils.newFloatArray(16);\r\n    });\r\n\r\n    update (skeleton: Skeleton, updateAabb: boolean) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        let boundingBoxes = this.boundingBoxes;\r\n        let polygons = this.polygons;\r\n        let polygonPool = this.polygonPool;\r\n        let slots = skeleton.slots;\r\n        let slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slot = slots[i];\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof BoundingBoxAttachment) {\r\n                let boundingBox = attachment as BoundingBoxAttachment;\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain();\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, polygon);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    }\r\n\r\n    aabbCompute () {\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            let polygon = polygons[i];\r\n            let vertices = polygon;\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                let x = vertices[ii];\r\n                let y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint (x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let minX = this.minX;\r\n        let minY = this.minY;\r\n        let maxX = this.maxX;\r\n        let maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        let m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton (bounds: SkeletonBounds) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint (x: number, y: number): BoundingBoxAttachment {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let vertexY = vertices[ii + 1];\r\n            let prevY = vertices[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                let vertexX = vertices[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\r\n     * true. */\r\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let width12 = x1 - x2, height12 = y1 - y2;\r\n        let det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\r\n            let det2 = x3 * y4 - y3 * x4;\r\n            let width34 = x3 - x4, height34 = y3 - y4;\r\n            let det3 = width12 * height34 - height12 * width34;\r\n            let x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                let y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon (boundingBox: BoundingBoxAttachment) {\r\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\r\n        let index = this.boundingBoxes.indexOf(boundingBox);\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    getWidth () {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    getHeight () {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Animation} from \"./Animation\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData} from \"./PathConstraintData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonData {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    width: number; height: number;\n    version: string; hash: string;\n\n    // Nonessential\n    fps = 0;\n    imagesPath: string;\n\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    }\n\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    }\n\n    findSkin (skinName: string) {\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\n        let skins = this.skins;\n        for (let i = 0, n = skins.length; i < n; i++) {\n            let skin = skins[i];\n            if (skin.name == skinName) return skin;\n        }\n        return null;\n    }\n\n    findEvent (eventDataName: string) {\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n        let events = this.events;\n        for (let i = 0, n = events.length; i < n; i++) {\n            let event = events[i];\n            if (event.name == eventDataName) return event;\n        }\n        return null;\n    }\n\n    findAnimation (animationName: string) {\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\n        let animations = this.animations;\n        for (let i = 0, n = animations.length; i < n; i++) {\n            let animation = animations[i];\n            if (animation.name == animationName) return animation;\n        }\n        return null;\n    }\n\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraintIndex (pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\n            if (pathConstraints[i].name == pathConstraintName) return i;\n        return -1;\n    }\n}\n","import {SkeletonData} from \"./SkeletonData\";\nimport {BoneData, TransformMode} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Event} from \"./Event\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData, PositionMode, SpacingMode, RotateMode} from \"./PathConstraintData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from \"./attachments\";\nimport {Utils, Color, ArrayLike} from \"./Utils\";\nimport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nimport {BlendMode} from \"./BlendMode\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor (attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData (json: string | any ): SkeletonData {\n        let scale = this.scale;\n        let skeletonData = new SkeletonData();\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\n\n        // Skeleton\n        let skeletonMap = root.skeleton;\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                let boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n                }\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\n\n                //this is legacy\n                if (boneMap.hasOwnProperty(\"inheritScale\") || boneMap.hasOwnProperty(\"inheritRotation\")) {\n                    //before 3.5\n                    data.transformMode = SkeletonJson.transformModeLegacy(\n                        this.getValue(boneMap, \"inheritRotation\", true),\n                        this.getValue(boneMap, \"inheritScale\", true));\n                } else {\n                    //after 3.5\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n                }\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                let slotMap = root.slots[i];\n                let slotName: string = slotMap.name;\n                let boneName: string = slotMap.bone;\n                let boneData = skeletonData.findBone(boneName);\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                let color: string = this.getValue(slotMap, \"color\", null);\n                if (color != null) data.color.setFromString(color);\n\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                let constraintMap = root.ik[i];\n                let data = new IkConstraintData(constraintMap.name);\n                data.order = this.getValue(constraintMap, \"order\", 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                let constraintMap = root.transform[i];\n                let data = new TransformConstraintData(constraintMap.name);\n                data.order = this.getValue(constraintMap, \"order\", 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                let constraintMap = root.path[i];\n                let data = new PathConstraintData(constraintMap.name);\n                data.order = this.getValue(constraintMap, \"order\", 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.position = this.getValue(constraintMap, \"position\", 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let skinName in root.skins) {\n                let skinMap = root.skins[skinName]\n                let skin = new Skin(skinName);\n                for (let slotName in skinMap) {\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                    let slotMap = skinMap[slotName];\n                    for (let entryName in slotMap) {\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            let linkedMesh = this.linkedMeshes[i];\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (let eventName in root.events) {\n                let eventMap = root.events[eventName];\n                let data = new EventData(eventName);\n                data.intValue = this.getValue(eventMap, \"int\", 0);\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\n                data.stringValue = this.getValue(eventMap, \"string\", null);\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (let animationName in root.animations) {\n                let animationMap = root.animations[animationName];\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string): Attachment {\n        let scale = this.scale;\n        name = this.getValue(map, \"name\", name);\n\n        let type = this.getValue(map, \"type\", \"region\");\n\n        switch (type) {\n            case \"region\": {\n                let path = this.getValue(map, \"path\", name);\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, \"x\", 0) * scale;\n                region.y = this.getValue(map, \"y\", 0) * scale;\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\n                region.rotation = this.getValue(map, \"rotation\", 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) region.color.setFromString(color);\n\n                return region;\n            }\n            case \"boundingbox\": {\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) box.color.setFromString(color);\n                return box;\n            }\n            //weightedmesh is deprecated but who cares\n            case \"weightedmesh\":\n            case \"skinnedmesh\":\n            case \"mesh\":\n            case \"linkedmesh\": {\n                let path = this.getValue(map, \"path\", name);\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                let color = this.getValue(map, \"color\", null);\n                if (color != null) mesh.color.setFromString(color);\n\n                let parent: string = this.getValue(map, \"parent\", null);\n                if (parent != null) {\n                    mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\n                    return mesh;\n                }\n\n                let uvs: Array<number> = map.uvs;\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = uvs;\n                // mesh.updateUVs();\n\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                return mesh;\n            }\n            case \"path\": {\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\n                if (path == null) return null;\n                path.closed = this.getValue(map, \"closed\", false);\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\n                let vertexCount = map.vertexCount;\n                this.readVertices(map, path, vertexCount << 1);\n\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n                for (let i = 0; i < map.lengths.length; i++)\n                    lengths[i++] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) path.color.setFromString(color);\n                return path;\n            }\n        }\n        return null;\n    }\n\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n        let scale = this.scale;\n        attachment.worldVerticesLength = verticesLength;\n        let vertices: Array<number> = map.vertices;\n        if (verticesLength == vertices.length) {\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++)\n                    vertices[i] *= scale;\n            }\n            attachment.vertices = Utils.toFloatArray(vertices);\n            return;\n        }\n        let weights = new Array<number>();\n        let bones = new Array<number>();\n        for (let i = 0, n = vertices.length; i < n;) {\n            let boneCount = vertices[i++];\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\n        let scale = this.scale;\n        let timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (let slotName in map.slots) {\n                let slotMap = map.slots[slotName];\n                let slotIndex = skeletonData.findSlotIndex(slotName);\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                for (let timelineName in slotMap) {\n                    let timelineMap = slotMap[timelineName];\n                    if (timelineName == \"color\") {\n                        let timeline = new ColorTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let color = new Color();\n                            color.setFromString(valueMap.color);\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n\n                    } else if (timelineName = \"attachment\") {\n                        let timeline = new AttachmentTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (let boneName in map.bones) {\n                let boneMap = map.bones[boneName];\n                let boneIndex = skeletonData.findBoneIndex(boneName);\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                for (let timelineName in boneMap) {\n                    let timelineMap = boneMap[timelineName];\n                    if (timelineName === \"rotate\") {\n                        let timeline = new RotateTimeline(timelineMap.length);\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"scale\")\n                            timeline = new ScaleTimeline(timelineMap.length);\n                        else if (timelineName === \"shear\")\n                            timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n\n                    } else\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (let constraintName in map.ik) {\n                let constraintMap = map.ik[constraintName];\n                let constraint = skeletonData.findIkConstraint(constraintName);\n                let timeline = new IkConstraintTimeline(constraintMap.length);\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (let constraintName in map.transform) {\n                let constraintMap = map.transform[constraintName];\n                let constraint = skeletonData.findTransformConstraint(constraintName);\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration,\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.paths) {\n            for (let constraintName in map.paths) {\n                let constraintMap = map.paths[constraintName];\n                let index = skeletonData.findPathConstraintIndex(constraintName);\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                let data = skeletonData.pathConstraints[index];\n                for (let timelineName in constraintMap) {\n                    let timelineMap = constraintMap[timelineName];\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"spacing\") {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === \"mix\") {\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                                this.getValue(valueMap, \"translateMix\", 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (let deformName in map.deform) {\n                let deformMap = map.deform[deformName];\n                let skin = skeletonData.findSkin(deformName);\n                if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                for (let slotName in deformMap) {\n                    let slotMap = deformMap[slotName];\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                    for (let timelineName in slotMap) {\n                        let timelineMap = slotMap[timelineName];\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                        let weighted = attachment.bones != null;\n                        let vertices = attachment.vertices;\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n                        let timeline = new DeformTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            let valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\n                            if (verticesValue == null)\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\n                                        deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++)\n                                        deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\n            let slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                let drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0, unchangedIndex = 0;\n                    for (let i = 0; i < offsets.length; i++) {\n                        let offsetMap = offsets[i];\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--)\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            let timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n            for (let i = 0; i < map.events.length; i++) {\n                let eventMap = map.events[i];\n                let eventData = skeletonData.findEvent(eventMap.name);\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                let event = new Event(eventMap.time, eventData);\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error(\"Error while parsing animation, duration is NaN\");\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.curve) return;\n        if (map.curve === \"stepped\")\n            timeline.setStepped(frameIndex);\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n            let curve: Array<number> = map.curve;\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n    }\n\n    getValue (map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString (str: string): number {\n        if (str === 'multiply') return PIXI.BLEND_MODES.MULTIPLY;\n        if (str === 'additive') return PIXI.BLEND_MODES.ADD;\n        if (str === 'screen') return PIXI.BLEND_MODES.SCREEN;\n        if (str === 'normal') return PIXI.BLEND_MODES.NORMAL;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"fixed\") return PositionMode.Fixed;\n        if (str == \"percent\") return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"length\") return SpacingMode.Length;\n        if (str == \"fixed\") return SpacingMode.Fixed;\n        if (str == \"percent\") return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"tangent\") return RotateMode.Tangent;\n        if (str == \"chain\") return RotateMode.Chain;\n        if (str == \"chainscale\") return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n\n    static transformModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == \"normal\") return TransformMode.Normal;\n        if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\n        if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\n        if (str == \"noscale\") return TransformMode.NoScale;\n        if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\n        throw new Error(`Unknown transform mode: ${str}`);\n    }\n\n    static transformModeLegacy(inheritRotation: boolean, inheritScale: boolean) {\n        if (inheritRotation && inheritScale) {\n            return TransformMode.Normal;\n        } else if (inheritRotation) {\n            return TransformMode.InheritRotation;\n        } else if (inheritScale) {\n            return TransformMode.InheritScale;\n        } else {\n            return TransformMode.OnlyTranslation;\n        }\n    }\n}\n\nclass LinkedMesh {\n    parent: string; skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n    }\n}\n","import {Attachment} from \"./attachments\";\nimport {Skeleton} from \"./Skeleton\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n\n    addAttachment (slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\n        let attachments = this.attachments;\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, name: string): Attachment {\n        let dictionary = this.attachments[slotIndex];\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            let slot = skeleton.slots[i];\n            let slotAttachment = slot.getAttachment();\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                let dictionary = oldSkin.attachments[slotIndex];\n                for (let key in dictionary) {\n                    let skinAttachment:Attachment = dictionary[key];\n                    if (slotAttachment == skinAttachment) {\n                        let attachment = this.getAttachment(slotIndex, name);\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import {Attachment} from \"./attachments\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Color} from \"./Utils\";\r\nimport {TextureRegion} from \"./Texture\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Slot {\r\n    //this is for PIXI\r\n    currentMesh: any;\r\n    currentSprite: any;\r\n    meshes: any;\r\n    currentMeshName: String;\r\n    sprites: any;\r\n    currentSpriteName: String;\r\n    blendMode: number;\r\n    //assign hack region a bit later\r\n    tempRegion: TextureRegion;\r\n    tempAttachment: Attachment;\r\n\r\n    //canon\r\n    data: SlotData;\r\n    bone: Bone;\r\n    color: Color;\r\n    attachment: Attachment;\r\n    private attachmentTime: number;\r\n    attachmentVertices = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (bone == null) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.blendMode = data.blendMode;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\r\n     * @param attachment May be null. */\r\n    setAttachment (attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    }\r\n\r\n    setAttachmentTime (time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** Returns the time since the attachment was set. */\r\n    getAttachmentTime (): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.data.attachmentName == null)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\nimport {Color} from \"./Utils\";\r\nimport {BlendMode} from \"./BlendMode\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: BoneData;\r\n    color = new Color(1, 1, 1, 1);\r\n    attachmentName: string;\r\n    blendMode: number;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n","export abstract class Texture {\r\n    protected _image: HTMLImageElement;\r\n\r\n    constructor (image: HTMLImageElement) {\r\n        this._image = image;\r\n    }\r\n\r\n    getImage (): HTMLImageElement {\r\n        return this._image;\r\n    }\r\n\r\n    abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\r\n    abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\r\n    abstract dispose (): void;\r\n\r\n\r\n    public static filterFromString (text: string): TextureFilter {\r\n        switch (text.toLowerCase()) {\r\n            case \"nearest\": return TextureFilter.Nearest;\r\n            case \"linear\": return TextureFilter.Linear;\r\n            case \"mipmap\": return TextureFilter.MipMap;\r\n            case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n            case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n            case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n            case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n            default: throw new Error(`Unknown texture filter ${text}`);\r\n        }\r\n    }\r\n\r\n    public static wrapFromString (text: string): TextureWrap {\r\n        switch (text.toLowerCase()) {\r\n            case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n            case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n            case \"repeat\": return TextureWrap.Repeat;\r\n            default: throw new Error(`Unknown texture wrap ${text}`);\r\n        }\r\n    }\r\n}\r\n\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\nexport class TextureRegion {\r\n    texture: PIXI.Texture;\r\n\r\n    //thats for overrides\r\n    size: PIXI.Rectangle = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            return tex.crop.width;\r\n        }\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            return tex.crop.height;\r\n        }\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return this.texture._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return this.texture._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return this.texture._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return this.texture._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        var tex = this.texture;\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        var tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            if (tex.trim) {\r\n                return tex.trim.width;\r\n            }\r\n            return tex.crop.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            if (tex.trim) {\r\n                return tex.trim.height;\r\n            }\r\n            return tex.crop.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n}\r\n","import {Disposable, Map} from \"./Utils\";\r\nimport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: PIXI.Texture) {\r\n        let pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new TextureAtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null)\r\n            throw new Error(\"textureLoader cannot be null.\");\r\n\r\n        let reader = new TextureAtlasReader(atlasText);\r\n        let tuple = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n\r\n        let iterateParser = () => {\r\n            while (true) {\r\n                let line = reader.readLine();\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                line = line.trim();\r\n                if (line.length == 0)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    }\r\n                    // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = Texture.filterFromString(tuple[0]);\r\n                    page.magFilter = Texture.filterFromString(tuple[1]);\r\n\r\n                    let direction = reader.readValue();\r\n                    page.uWrap = TextureWrap.ClampToEdge;\r\n                    page.vWrap = TextureWrap.ClampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = TextureWrap.Repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = TextureWrap.Repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = TextureWrap.Repeat;\r\n\r\n                    textureLoader(line, (texture: PIXI.BaseTexture) => {\r\n                        page.baseTexture = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        this.pages.push(page);\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    this.pages.push(page);\r\n                    break;\r\n                } else {\r\n                    let region: TextureAtlasRegion = new TextureAtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    let x = parseInt(tuple[0]);\r\n                    let y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    let width = parseInt(tuple[0]);\r\n                    let height = parseInt(tuple[1]);\r\n\r\n                    let resolution = page.baseTexture.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    let originalWidth = parseInt(tuple[0]) / resolution;\r\n                    let originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    let offsetX = parseInt(tuple[0]) / resolution;\r\n                    let offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    this.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index: number = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length)\r\n            return null;\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readValue(): string {\r\n        let line = this.readLine();\r\n        let colon = line.indexOf(\":\");\r\n        if (colon == -1)\r\n            throw new Error(\"Invalid line: \" + line);\r\n        return line.substring(colon + 1).trim();\r\n    }\r\n\r\n    readTuple(tuple: Array<string>): number {\r\n        let line = this.readLine();\r\n        let colon = line.indexOf(\":\");\r\n        if (colon == -1)\r\n            throw new Error(\"Invalid line: \" + line);\r\n        let i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++) {\r\n            let comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = line.substring(lastMatch).trim();\r\n        return i + 1;\r\n    }\r\n}\r\n\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter;\r\n    magFilter: TextureFilter;\r\n    uWrap: TextureWrap;\r\n    vWrap: TextureWrap;\r\n    baseTexture: PIXI.BaseTexture;\r\n    width: number;\r\n    height: number;\r\n\r\n    public setFilters() {\r\n        let tex = this.baseTexture;\r\n        let filter = this.minFilter;\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = true;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n","import {TransformConstraintData} from \"./TransformConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Vector2, MathUtils} from \"./Utils\";\nimport {Skeleton} from \"./Skeleton\";\nimport {Constraint} from \"./Constraint\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraint implements Constraint {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    temp = new Vector2();\n\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n        let target = this.target;\n        let ta = target.matrix.a, tb = target.matrix.c, tc = target.matrix.b, td = target.matrix.d;\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            let m = bone.matrix;\n            let modified = false;\n\n            if (rotateMix != 0) {\n                let a = m.a, b = m.c, c = m.b, d = m.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + this.data.offsetRotation * MathUtils.degRad;\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                let cos = Math.cos(r), sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                let temp = this.temp;\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                m.tx += (temp.x - m.tx) * translateMix;\n                m.ty += (temp.y - m.ty) * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = Math.sqrt(m.a * m.a + m.b * m.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                m.a *= s;\n                m.b *= s;\n                s = Math.sqrt(m.c * m.c + m.d * m.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                m.c *= s;\n                m.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                let b = m.c, d = m.d;\n                let by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(m.b, m.a));\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r = by + (r + this.data.offsetShearY * MathUtils.degRad) * shearMix;\n                let s = Math.sqrt(b * b + d * d);\n                m.c = Math.cos(r) * s;\n                m.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    getOrder () {\n        return this.data.order;\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport interface Map<T> {\n    [key: string]: T;\n}\n\nexport interface Disposable {\n    dispose (): void;\n}\n\nexport class Color {\n    public static WHITE = new Color(1, 1, 1, 1);\n    public static RED = new Color(1, 0, 0, 1);\n    public static GREEN = new Color(0, 1, 0, 1);\n    public static BLUE = new Color(0, 0, 1, 1);\n    public static MAGENTA = new Color(1, 0, 1, 1);\n\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n    }\n\n    set (r: number, g: number, b: number, a: number) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.clamp();\n        return this;\n    }\n\n    setFromColor (c: Color) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n        return this;\n    }\n\n    setFromString (hex: string) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n        this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n        return this;\n    }\n\n    add (r: number, g: number, b: number, a: number) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n        this.clamp();\n        return this;\n    }\n\n    clamp () {\n        if (this.r < 0) this.r = 0;\n        else if (this.r > 1) this.r = 1;\n\n        if (this.g < 0) this.g = 0;\n        else if (this.g > 1) this.g = 1;\n\n        if (this.b < 0) this.b = 0;\n        else if (this.b > 1) this.b = 1;\n\n        if (this.a < 0) this.a = 0;\n        else if (this.a > 1) this.a = 1;\n        return this;\n    }\n}\n\nexport class MathUtils {\n    static PI = 3.1415927;\n    static PI2 = MathUtils.PI * 2;\n    static radiansToDegrees = 180 / MathUtils.PI;\n    static radDeg = MathUtils.radiansToDegrees;\n    static degreesToRadians = MathUtils.PI / 180;\n    static degRad = MathUtils.degreesToRadians;\n\n    static clamp (value: number, min: number, max: number) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n\n    static cosDeg (degrees: number) {\n        return Math.cos(degrees * MathUtils.degRad);\n    }\n\n    static sinDeg (degrees: number) {\n        return Math.sin(degrees * MathUtils.degRad);\n    }\n\n    static signum (value: number): number {\n        return value >= 0 ? 1 : -1;\n    }\n\n    static toInt (x: number) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n    }\n\n    static cbrt (x: number) {\n        var y = Math.pow(Math.abs(x), 1/3);\n        return x < 0 ? -y : y;\n    }\n}\n\nexport class Utils {\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n            dest[j] = source[i];\n        }\n    }\n\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n        let oldSize = array.length;\n        if (oldSize == size) return array;\n        array.length = size;\n        if (oldSize < size) {\n            for (let i = oldSize; i < size; i++) array[i] = value;\n        }\n        return array;\n    }\n\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\n        let array = new Array<T>(size);\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\n        return array;\n    }\n\n    static newFloatArray (size: number): ArrayLike<number> {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Float32Array(size)\n        } else {\n             let array = new Array<number>(size);\n             for (let i = 0; i < array.length; i++) array[i] = 0;\n             return array;\n        }\n    }\n\n    static toFloatArray (array: Array<number>) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n    }\n}\n\nexport class DebugUtils {\n    static logBones(skeleton: Skeleton) {\n        for (let i = 0; i < skeleton.bones.length; i++) {\n            let bone = skeleton.bones[i];\n            let m = bone.matrix;\n            console.log(bone.data.name + \", \" + m.a + \", \" + m.b + \", \" + m.c + \", \" + m.d + \", \" + m.tx + \", \" + m.ty);\n        }\n    }\n}\n\nexport class Pool<T> {\n    private items = new Array<T>();\n    private instantiator: () => T;\n\n    constructor (instantiator: () => T) {\n        this.instantiator = instantiator;\n    }\n\n    obtain () {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n    }\n\n    free (item: T) {\n        this.items.push(item);\n    }\n\n    freeAll (items: ArrayLike<T>) {\n        for (let i = 0; i < items.length; i++) this.items[i] = items[i];\n    }\n\n    clear () {\n        this.items.length = 0;\n    }\n}\n\nexport class Vector2 {\n    constructor (public x = 0, public y = 0) {\n    }\n\n    set (x: number, y: number): Vector2 {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    length () {\n        let x = this.x;\n        let y = this.y;\n        return Math.sqrt(x * x + y * y);\n    }\n\n    normalize () {\n        let len = this.length();\n        if (len != 0) {\n            this.x /= len;\n            this.y /= len;\n        }\n        return this;\n    }\n}\n\nexport class TimeKeeper {\n    maxDelta = 0.064;\n    framesPerSecond = 0;\n    delta = 0;\n    totalTime = 0;\n\n    private lastTime = Date.now() / 1000;\n    private frameCount = 0;\n    private frameTime = 0;\n\n    update () {\n        var now = Date.now() / 1000;\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n\n        this.frameCount++;\n        if (this.frameTime > 1) {\n            this.framesPerSecond = this.frameCount / this.frameTime;\n            this.frameTime = 0;\n            this.frameCount = 0;\n        }\n    }\n}\n\nexport interface ArrayLike<T> {\n    length: number;\n    [n: number]: T;\n}\n","import {Slot} from \"../Slot\";\nimport {ArrayLike} from \"../Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport abstract class Attachment {\n    name: string;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n\nexport abstract class VertexAttachment extends Attachment {\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n\n    constructor (name: string) {\n        super(name);\n    }\n\n    computeWorldVertices (slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVerticesWith (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number) {\n        count += offset;\n        let skeleton = slot.bone.skeleton;\n        let deformArray = slot.attachmentVertices;\n        let vertices = this.vertices;\n        let bones = this.bones;\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            let bone = slot.bone;\n            let m = bone.matrix;\n            let x = m.tx;\n            let y = m.ty;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            for (let v = start, w = offset; w < count; v += 2, w += 2) {\n                let vx = vertices[v], vy = vertices[v + 1];\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n            return;\n        }\n        let v = 0, skip = 0;\n        for (let i = 0; i < start; i += 2) {\n            let n = bones[v];\n            v += n + 1;\n            skip += n;\n        }\n        let skeletonBones = skeleton.bones;\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += 2) {\n                let wx = 0, wy = 0;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            let deform = deformArray;\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += 2) {\n                let wx = 0, wy = 0;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n    applyDeform (sourceAttachment: VertexAttachment) {\n        return this == sourceAttachment;\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport enum AttachmentType {\r\n    Region, BoundingBox, Mesh, LinkedMesh, Path\r\n}\r\n","import {VertexAttachment} from \"./Attachment\";\r\nimport {Color} from \"../Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n","import {VertexAttachment} from \"./Attachment\";\nimport {TextureRegion} from \"../Texture\";\nimport {Color, Utils, ArrayLike} from \"../Utils\";\nimport {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class MeshAttachment extends VertexAttachment {\n    region: TextureRegion;\n    path: string;\n    regionUVs: ArrayLike<number>;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    hullLength: number;\n    private parentMesh: MeshAttachment;\n    inheritDeform = false;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\n        return [];\n        //nothing\n    }\n\n    updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\n        let regionUVs = this.regionUVs;\n        let n = regionUVs.length;\n        if (!uvs || uvs.length != n) {\n            uvs = Utils.newFloatArray(n);\n        }\n\n        if (region == null) {\n            return;\n        }\n\n        let texture = region.texture;\n        let r = texture._uvs;\n        let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        let x = region.offsetX, y = region.pixiOffsetY;\n\n        for (let i = 0; i < n; i += 2) {\n            let u = this.regionUVs[i], v = this.regionUVs[i + 1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n\n        return uvs;\n    }\n\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n}\n","import {VertexAttachment} from \"./Attachment\";\r\nimport {Color} from \"../Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class PathAttachment extends VertexAttachment {\r\n    lengths: Array<number>;\r\n    closed = false; constantSpeed = false;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n}\r\n","import {Attachment} from \"./Attachment\";\r\nimport {Color, Utils} from \"../Utils\";\r\nimport {TextureRegion} from \"../Texture\";\r\nimport {Slot} from \"../Slot\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class RegionAttachment extends Attachment {\r\n    x = 0; y = 0; scaleX = 1; scaleY = 1; rotation = 0; width = 0; height = 0;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    path: string;\r\n    region: TextureRegion;\r\n\r\n    constructor (name:string) {\r\n        super(name);\r\n    }\r\n\r\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\r\n        return [];\r\n        //nothing\r\n    }\r\n}\r\n","export {Attachment, VertexAttachment} from \"./Attachment\";\r\nexport {AttachmentLoader} from \"./AttachmentLoader\";\r\nexport {AttachmentType} from \"./AttachmentType\";\r\nexport {BoundingBoxAttachment} from \"./BoundingBoxAttachment\";\r\nexport {MeshAttachment} from \"./MeshAttachment\";\r\nexport {PathAttachment} from \"./PathAttachment\";\r\nexport {RegionAttachment} from \"./RegionAttachment\";\r\n","export * from \"./attachments\";\n\nexport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nexport {AnimationState} from \"./AnimationState\";\nexport {AnimationStateData} from \"./AnimationStateData\";\nexport {BlendMode} from \"./BlendMode\";\nexport {Bone} from \"./Bone\";\nexport {BoneData, TransformMode} from \"./BoneData\";\nexport {Constraint} from \"./Constraint\";\nexport {Event} from \"./Event\";\nexport {EventData} from \"./EventData\";\nexport {IkConstraint} from \"./IkConstraint\";\nexport {IkConstraintData} from \"./IkConstraintData\";\nexport {PathConstraint} from \"./PathConstraint\";\nexport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nexport {Skeleton} from \"./Skeleton\";\nexport {SkeletonBounds} from \"./SkeletonBounds\";\nexport {SkeletonData} from \"./SkeletonData\";\nexport {SkeletonJson} from \"./SkeletonJson\";\nexport {Skin} from \"./Skin\";\nexport {Slot} from \"./Slot\";\nexport {SlotData} from \"./SlotData\";\nexport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\nexport {TextureAtlas, TextureAtlasRegion} from \"./TextureAtlas\";\nexport {AtlasAttachmentLoader} from \"./AtlasAttachmentLoader\";\nexport {TransformConstraint} from \"./TransformConstraint\";\nexport {TransformConstraintData} from \"./TransformConstraintData\";\nexport {Updatable} from \"./Updatable\";\nexport {Disposable, Map, Utils, Pool, MathUtils, Color, Vector2} from \"./Utils\";\n","import * as spine from \"./core\";\n\nexport function atlasParser() {\n    return function (resource: PIXI.loaders.Resource, next: () => any) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\n        if (metadataAtlas === false) {\n            return next();\n        }\n        if (metadataAtlas && metadataAtlas.pages) {\n            //its an atlas!\n            var spineJsonParser = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(metadataAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = metadataAtlas;\n\n            return next();\n        }\n\n        var metadataAtlasSuffix = '.atlas';\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n        //remove the baseUrl\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n        //remove the baseUrl\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function () {\n            new spine.TextureAtlas(this.xhr.responseText, adapter, function(spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n\n                next();\n            });\n        });\n    };\n}\n\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: String, callback: (baseTexture: PIXI.BaseTexture) => any) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\n            callback(resource.texture.baseTexture);\n        });\n    }\n}\n\nexport function syncImageLoaderAdapter (baseUrl: any, crossOrigin: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: any, callback: any) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    }\n}\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n","import * as core from \"./core\";\r\nimport * as loaders from \"./loaders\";\r\n\r\nexport {core, loaders}\r\nexport {Spine, SpineMesh, SpineSprite} from \"./Spine\";\r\n"],"sourceRoot":"/source/"}