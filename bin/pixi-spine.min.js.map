{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/WeightedMeshAttachment.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/imageLoaderAdapter.js","src/loaders/index.js","src/loaders/syncImageLoaderAdapter.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","spine","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders",2,"Animation","name","timelines","duration","this","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil",3,"TrackEntry","AnimationState","stateData","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","getCurrent","./TrackEntry",4,"AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty",5,"AtlasReader","AtlasPage","AtlasRegion","syncImageLoaderAdapter","Atlas","atlasText","loaderFunction","callback","iterateParser","line","reader","readLine","self","trim","page","readTuple","tuple","width","parseInt","height","format","Format","minFilter","TextureFilter","magFilter","direction","readValue","uWrap","TextureWrap","clampToEdge","vWrap","repeat","texture","rendererObject","pages","console","log","region","rotate","x","y","v","u2","v2","resolution","abs","splits","pads","originalWidth","originalHeight","offsetX","offsetY","regions","baseUrl","crossOrigin","texturesLoading","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","../loaders/syncImageLoaderAdapter.js","./AtlasPage","./AtlasReader","./AtlasRegion",6,"RegionAttachment","MeshAttachment","WeightedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","regionOffsetX","regionOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","regionU","regionV","regionU2","regionV2","regionRotate","newWeightedMeshAttachment","SkinnedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./WeightedMeshAttachment",7,8,"text","lines","split","value","replace","colon","indexOf","substring","lastMatch","comma","substr",9,10,"Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves",11,"AttachmentType","boundingbox","mesh","weightedmesh","skinnedmesh","linkedmesh","weightedlinkedmesh",12,"Bone","boneData","parent","matrix","Matrix","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","flipX","flipY","worldSignX","worldSignY","updateWorldTransform","cos","degRad","sin","la","lb","lc","ld","m","c","b","d","tx","ty","signum","pa","pb","pc","pd","inheritRotation","inheritScale","temp","radDeg","psx","psy","za","zb","zc","zd","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY","getWorldRotationX","atan2","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","Object","defineProperties","worldX","get","worldY",13,"BoneData",14,"vertices","type","computeWorldVertices","bone","worldVertices","m00","m01","m10","m11","px","py","./AttachmentType",15,"ColorTimeline","g","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot",16,"setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY",17,"DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex",18,"Event","intValue","floatValue","stringValue",19,"EventData",20,"EventTimeline","frame",21,"FfdTimeline","frameVertices","slotAttachment","applyFFD","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev",22,"IkConstraint","bendDirection","bones","findBone","apply1","apply2","targetX","targetY","parentRotation","child","bendDir","offset1","offset2","sign2","csx","cy","pp","ppm","wx","wy","a1","a2","l1","l2","outer","acos","ta","aa","bb","ll","dd","c0","c1","c2","q","r0","r1","minAngle","minDist","Infinity","minX","minY","maxAngle","maxDist","maxX","maxY","dist","PI","angle","offset",23,"IkConstraintData",24,"IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix",25,"parentMesh","inheritFFD","uvs","regionUVs","triangles","hullLength","edges","Float32Array","verticesCount","vx","vy","sourceAttachment","setParentMesh",26,"updateOffset","regionScaleX","regionScaleY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices",27,"RotateTimeline","boneIndex","amount","prevFrameValue",28,"ScaleTimeline","prevFrameX","prevFrameY",29,"Slot","Skeleton","slotData","boneCache","updateCache","ikConstraintsCount","arrayCount","nonIkBones","cacheBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","ikConstraintName","./Bone","./IkConstraint","./Slot",30,"SkeletonBounds","polygonPool","polygons","boundingBoxes","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","x1","y1","x2","y2","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","../SpineRuntime",31,"SkeletonData","skins","animations","version","hash","findEvent","eventName",32,"LinkedMesh","SlotData","Skin","TranslateTimeline","SkeletonJsonParser","attachmentLoader","linkedMeshes","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","size","linkedMesh","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","ffd","meshMap","meshName","isMesh","verticesValue","j","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./SkeletonData","./Skin","./SlotData","./TranslateTimeline",33,"attachments","oldSkin",34,"_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas",35,"multiply","BLEND_MODES","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL",36,37,38,"weight","skeletonBones","w",39,"./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js",40,41,"spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","SlotContainerUpdateTransformV3","pt","worldTransform","wt","lt","localTransform","worldAlpha","_currentBounds","atlasParser","fromAtlas","resourceName","AnimCache","create","constructor","globalAutoUpdate","updateTransform","autoUpdateTransform","set","dt","children","undefined","visible","sprites","transform","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","copy","displayObjectUpdateTransform","tint","utils","rgb2hex","meshes","Date","now","timeDelta","descriptor","baseTexture","spriteRect","Rectangle","spriteTexture","Texture","Sprite","baseRotation","anchor","position","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","../loaders/atlasParser",42,"Loader","addPixiMiddleware","loader","use","./atlasParser",43,"Resource","imageLoaderAdapter","resource","isJson","atlasPath","url","lastIndexOf","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","metadata","spineMetadata","imageOptions","imageMetadata","adapter","add","res","xhr","responseText","spineAtlas","spineJsonParser","enableCaching","./imageLoaderAdapter",44,"namePrefix",45,"./Loader","./syncImageLoaderAdapter",46,"BaseTexture","fromImage"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n",null,"var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function (atlasText, loaderFunction, callback)\r\n{\r\n    //TODO: remove this legacy later\r\n    if (typeof loaderFunction !== \"function\") {\r\n        //old syntax\r\n        var baseUrl = loaderFunction;\r\n        var crossOrigin = callback;\r\n        loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n        callback = null;\r\n    }\r\n\r\n    this.pages = [];\r\n    this.regions = [];\r\n\r\n    this.texturesLoading = 0;\r\n\r\n    var self = this;\r\n\r\n    var reader = new spine.AtlasReader(atlasText);\r\n    var tuple = [];\r\n    tuple.length = 4;\r\n    var page = null;\r\n\r\n    iterateParser();\r\n\r\n    function iterateParser() {\r\n        while (true) {\r\n            var line = reader.readLine();\r\n            if (line === null) {\r\n                return callback && callback(self);\r\n            }\r\n            line = reader.trim(line);\r\n            if (!line.length)\r\n                page = null;\r\n            else if (!page) {\r\n                page = new spine.AtlasPage();\r\n                page.name = line;\r\n\r\n                if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                    page.width = parseInt(tuple[0]);\r\n                    page.height = parseInt(tuple[1]);\r\n                    reader.readTuple(tuple);\r\n                } else {\r\n                    //old format, detect width and height by texture\r\n                }\r\n                page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                reader.readTuple(tuple);\r\n                page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                var direction = reader.readValue();\r\n                page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                if (direction == \"x\")\r\n                    page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                else if (direction == \"y\")\r\n                    page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                else if (direction == \"xy\")\r\n                    page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                loaderFunction(line, function (texture) {\r\n                    page.rendererObject = texture;\r\n                    self.pages.push(page);\r\n                    if (!page.width || !page.height) {\r\n                        page.width = texture.width;\r\n                        page.height = texture.height;\r\n                        if (!page.width || !page.height) {\r\n                            console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                        }\r\n                    }\r\n                    iterateParser();\r\n                });\r\n                break;\r\n            } else {\r\n                var region = new spine.AtlasRegion();\r\n                region.name = line;\r\n                region.page = page;\r\n\r\n                region.rotate = reader.readValue() == \"true\";\r\n\r\n                reader.readTuple(tuple);\r\n                var x = parseInt(tuple[0]);\r\n                var y = parseInt(tuple[1]);\r\n\r\n                reader.readTuple(tuple);\r\n                var width = parseInt(tuple[0]);\r\n                var height = parseInt(tuple[1]);\r\n\r\n                region.u = x / page.width;\r\n                region.v = y / page.height;\r\n                if (region.rotate) {\r\n                    region.u2 = (x + height) / page.width;\r\n                    region.v2 = (y + width) / page.height;\r\n                } else {\r\n                    region.u2 = (x + width) / page.width;\r\n                    region.v2 = (y + height) / page.height;\r\n                }\r\n                //detected resolution\r\n                var resolution = page.rendererObject.resolution;\r\n                region.x = x / resolution;\r\n                region.y = y / resolution;\r\n                region.width = Math.abs(width) / resolution;\r\n                region.height = Math.abs(height) / resolution;\r\n\r\n                if (reader.readTuple(tuple) == 4) { // split is optional\r\n                    region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                        region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        reader.readTuple(tuple);\r\n                    }\r\n                }\r\n\r\n                region.originalWidth = parseInt(tuple[0]) / resolution;\r\n                region.originalHeight = parseInt(tuple[1]) / resolution;\r\n\r\n                reader.readTuple(tuple);\r\n                region.offsetX = parseInt(tuple[0]) / resolution;\r\n                region.offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                region.index = parseInt(reader.readValue());\r\n\r\n                self.regions.push(region);\r\n            }\r\n        }\r\n    }\r\n};\r\nspine.Atlas.prototype = {\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.u = region.x / page.width;\r\n            region.v = region.y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (region.x + region.height) / page.width;\r\n                region.v2 = (region.y + region.width) / page.height;\r\n            } else {\r\n                region.u2 = (region.x + region.width) / page.width;\r\n                region.v2 = (region.y + region.height) / page.height;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        attachment.regionU = region.u;\n        attachment.regionV = region.v;\n        attachment.regionU2 = region.u2;\n        attachment.regionV2 = region.v2;\n        attachment.regionRotate = region.rotate;\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.SkinnedMeshAttachment(name);\n        attachment.rendererObject = region;\n        attachment.regionU = region.u;\n        attachment.regionV = region.v;\n        attachment.regionU2 = region.u2;\n        attachment.regionV2 = region.v2;\n        attachment.regionRotate = region.rotate;\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    page: null,\r\n    name: null,\r\n    x: 0, y: 0,\r\n    width: 0, height: 0,\r\n    u: 0, v: 0, u2: 0, v2: 0,\r\n    offsetX: 0, offsetY: 0,\r\n    originalWidth: 0, originalHeight: 0,\r\n    index: 0,\r\n    rotate: false,\r\n    splits: null,\r\n    pads: null\r\n};\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n","var spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n\n        var cos = Math.cos(rotation * spine.degRad), sin = Math.sin(rotation * spine.degRad);\n        var la = cos * scaleX, lb = -sin * scaleY, lc = sin * scaleX, ld = cos * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else if (data.inheritRotation) { // No scale inheritance.\n            pa = 1;\n            pb = 0;\n            pc = 0;\n            pd = 1;\n            do {\n                cos = Math.cos(parent.rotationIK * spine.degRad);\n                sin = Math.sin(parent.rotationIK * spine.degRad);\n                var temp = pa * cos + pb * sin;\n                pb = pa * -sin + pb * cos;\n                pa = temp;\n                temp = pc * cos + pd * sin;\n                pd = pc * -sin + pd * cos;\n                pc = temp;\n\n                if (!parent.data.inheritRotation) break;\n                parent = parent.parent;\n            } while (parent != null);\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        } else if (data.inheritScale) { // No rotation inheritance.\n            pa = 1;\n            pb = 0;\n            pc = 0;\n            pd = 1;\n            do {\n                var r = parent.rotation;\n                cos = Math.cos(r * spine.radDeg);\n                sin = Math.sin(r * spine.radDeg);\n                var psx = parent.scaleX, psy = parent.scaleY;\n                var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                temp = pa * za + pb * zc;\n                pb = pa * zb + pb * zd;\n                pa = temp;\n                temp = pc * za + pd * zc;\n                pd = pc * zb + pd * zd;\n                pc = temp;\n\n                if (psx < 0) {\n                    r = -r;\n                    sin = -sin;\n                }\n                temp = pa * cos + pb * sin;\n                pb = pa * -sin + pb * cos;\n                pa = temp;\n                temp = pc * cos + pd * sin;\n                pd = pc * -sin + pd * cos;\n                pc = temp;\n\n                if (!parent.data.inheritScale) break;\n                parent = parent.parent;\n            } while (parent != null);\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        } else {\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n","var spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoundingBoxAttachment = function (name)\n{\n    this.name = name;\n    this.vertices = [];\n};\nspine.BoundingBoxAttachment.prototype = {\n    type: spine.AttachmentType.boundingbox,\n    computeWorldVertices: function (x, y, bone, worldVertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.a, m01 = bone.c, m10 = bone.b, m11 = bone.d;\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2)\n        {\n            var px = vertices[i];\n            var py = vertices[i + 1];\n            worldVertices[i] = px * m00 + py * m01 + x;\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\n        }\n    }\n};\nmodule.exports = spine.BoundingBoxAttachment;\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.FfdTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = [];\n    this.frames.length = frameCount;\n    this.frameVertices = [];\n    this.frameVertices.length = frameCount;\n};\nspine.FfdTimeline.prototype = {\n    slotIndex: 0,\n    attachment: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, vertices)\n    {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var slot = skeleton.slots[this.slotIndex];\n        var slotAttachment = slot.attachment;\n        if (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment)) return;\n\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameVertices = this.frameVertices;\n        var vertexCount = frameVertices[0].length;\n\n        var vertices = slot.attachmentVertices;\n        if (vertices.length != vertexCount) {\n            vertices = slot.attachmentVertices = [];\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\n            // Don't mix from uninitialized slot vertices.\n            alpha = 1;\n        }\n\n        if (time >= frames[frames.length - 1])\n        { // Time is after last frame.\n            var lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1)\n            {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] = lastVertices[i];\n            }\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\n\n        var prevVertices = frameVertices[frameIndex - 1];\n        var nextVertices = frameVertices[frameIndex];\n\n        if (alpha < 1)\n        {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n};\nmodule.exports = spine.FfdTimeline;\n\n","var spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n};\nmodule.exports = spine.IkConstraint;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        if (this.regionRotate)\n        {\n            for (var i = 0; i < n; i += 2)\n            {\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\n            }\n        } else {\n            for (var i = 0; i < n; i += 2)\n            {\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\n            }\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n\n        var arrayCount = ikConstraintsCount + 1;\n        var boneCache = this.boneCache;\n        if (boneCache.length > arrayCount) boneCache.length = arrayCount;\n        for (var i = 0, n = boneCache.length; i < n; i++)\n            boneCache[i].length = 0;\n        while (boneCache.length < arrayCount)\n            boneCache[boneCache.length] = [];\n\n        var nonIkBones = boneCache[0];\n        var bones = this.bones;\n\n        outer:\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            var current = bone;\n            do {\n                for (var ii = 0; ii < ikConstraintsCount; ii++)\n                {\n                    var ikConstraint = ikConstraints[ii];\n                    var parent = ikConstraint.bones[0];\n                    var child= ikConstraint.bones[ikConstraint.bones.length - 1];\n                    while (true)\n                    {\n                        if (current == child)\n                        {\n                            boneCache[ii].push(bone);\n                            boneCache[ii + 1].push(bone);\n                            continue outer;\n                        }\n                        if (child == parent) break;\n                        child = child.parent;\n                    }\n                }\n                current = current.parent;\n            } while (current);\n            nonIkBones[nonIkBones.length] = bone;\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var i = 0, last = this.boneCache.length - 1;\n        while (true)\n        {\n            var cacheBones = this.boneCache[i];\n            for (var ii = 0, nn = cacheBones.length; ii < nn; ii++)\n                cacheBones[ii].updateWorldTransform();\n            if (i == last) break;\n            this.ikConstraints[i].apply();\n            i++;\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (ikConstraintName)\n    {\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n            if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (ikConstraintName)\n    {\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n            if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];\n        return null;\n    }\n};\nmodule.exports = spine.SkeletonData;\n\n","var spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    this.attachmentLoader = attachmentLoader;\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw \"IK bone not found: \" + bones[ii];\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw \"Target bone not found: \" + ikMap[\"target\"];\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                mesh.updateUVs();\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                var uvs = this.getFloatArray(map, \"uvs\", 1);\n                var vertices = this.getFloatArray(map, \"vertices\", 1);\n                var weights = [];\n                var bones = [];\n                for (var i = 0, n = vertices.length; i < n; )\n                {\n                    var boneCount = vertices[i++] | 0;\n                    bones[bones.length] = boneCount;\n                    for (var nn = i + boneCount * 4; i < nn; )\n                    {\n                        bones[bones.length] = vertices[i];\n                        weights[weights.length] = vertices[i + 1] * scale;\n                        weights[weights.length] = vertices[i + 2] * scale;\n                        weights[weights.length] = vertices[i + 3];\n                        i += 4;\n                    }\n                }\n                mesh.bones = bones;\n                mesh.weights = weights;\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = uvs;\n                mesh.updateUVs();\n\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\")\n                        timeline = new spine.ScaleTimeline(values.length);\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.WeightedMeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.WeightedMeshAttachment.prototype = {\n    type: spine.AttachmentType.weightedmesh,\n    parentMesh: null,\n    inheritFFD: false,\n    bones: null,\n    weights: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function (u, v, u2, v2, rotate)\n    {\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        if (this.regionRotate)\n        {\n            for (var i = 0; i < n; i += 2)\n            {\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\n            }\n        } else {\n            for (var i = 0; i < n; i += 2)\n            {\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\n            }\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var skeletonBones = slot.bone.skeleton.bones;\n        var weights = this.weights;\n        var bones = this.bones;\n\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\n        var wx, wy, vx, vy, weight;\n        var m;\n        if (!slot.attachmentVertices.length)\n        {\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b];\n                    vy = weights[b + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        } else {\n            var ffd = slot.attachmentVertices;\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3, f += 2)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b] + ffd[f];\n                    vy = weights[b + 1] + ffd[f + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.weights = parentMesh.weights;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.WeightedMeshAttachment;\n\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n","module.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\n    signum: function(x) {\n        if (x>0) return 1;\n        if (x<0) return -1;\n        return 0;\n    }\n};\n\n","var spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                //PIXI v4.0\n                if (!slotContainer.transform._dirtyLocal) {\n                    slotContainer.transform = new PIXI.TransformStatic();\n                }\n                var transform = slotContainer.transform;\n                var lt = transform.localTransform;\n                transform._dirtyParentVersion = -1;\n                transform._dirtyLocal = 1;\n                transform._versionLocal = 1;\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var spriteRect = new PIXI.Rectangle(descriptor.x,\n                                        descriptor.y,\n                                        descriptor.rotate ? descriptor.height : descriptor.width,\n                                        descriptor.rotate ? descriptor.width : descriptor.height);\n    var spriteTexture = new PIXI.Texture(baseTexture, spriteRect);\n    var sprite = new PIXI.Sprite(spriteTexture);\n\n    var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;\n    sprite.scale.x = attachment.width / descriptor.originalWidth * attachment.scaleX;\n    sprite.scale.y = attachment.height / descriptor.originalHeight * attachment.scaleY;\n    sprite.rotation = baseRotation + (attachment.rotation * spine.degRad);\n    sprite.anchor.x = (0.5 * descriptor.originalWidth - descriptor.offsetX) / descriptor.width;\n    sprite.anchor.y = 1.0 - ((0.5 * descriptor.originalHeight - descriptor.offsetY) / descriptor.height);\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    if (descriptor.rotate) {\n        var x1 = sprite.scale.x;\n        sprite.scale.x = sprite.scale.y;\n        sprite.scale.y = x1;\n    }\n    sprite.scale.y = -sprite.scale.y;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata.spineMetadata\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata.imageMetadata\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching)\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = true;\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n","module.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n"],"sourceRoot":"./"}