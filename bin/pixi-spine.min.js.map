{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/FlipXTimeline.js","src/SpineRuntime/FlipYTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/SkinnedMeshAttachment.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","spine","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders",2,"Animation","name","timelines","duration","this","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil",3,"TrackEntry","AnimationState","stateData","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","getCurrent","./TrackEntry",4,"AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty",5,"AtlasReader","AtlasPage","AtlasRegion","Atlas","atlasText","baseUrl","crossOrigin","indexOf","pages","regions","texturesLoading","reader","tuple","page","line","readLine","trim","region","rotate","readValue","readTuple","x","parseInt","y","width","height","v","u2","v2","abs","splits","pads","originalWidth","originalHeight","offsetX","offsetY","format","Format","minFilter","TextureFilter","magFilter","direction","uWrap","TextureWrap","clampToEdge","vWrap","repeat","rendererObject","BaseTexture","fromImage","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","./AtlasPage","./AtlasReader","./AtlasRegion",6,"RegionAttachment","MeshAttachment","SkinnedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","regionOffsetX","regionOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","regionU","regionV","regionU2","regionV2","regionRotate","newSkinnedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./SkinnedMeshAttachment",7,8,"text","lines","split","value","replace","colon","substring","lastMatch","comma","substr",9,10,"Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves",11,"AttachmentType","boundingbox","mesh","skinnedmesh",12,"Bone","boneData","parent","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","flipX","flipY","m00","m01","worldX","m10","m11","worldY","worldRotation","worldScaleX","worldScaleY","worldFlipX","worldFlipY","updateWorldTransform","inheritScale","inheritRotation","skeletonFlipX","skeletonFlipY","radians","degRad","cos","sin","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY",13,"BoneData",14,"vertices","type","computeWorldVertices","bone","worldVertices","px","py","./AttachmentType",15,"ColorTimeline","g","b","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot",16,"setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY",17,"DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex",18,"Event","intValue","floatValue","stringValue",19,"EventData",20,"EventTimeline","frame",21,"FfdTimeline","frameVertices","vertexCount","attachmentVertices","lastVertices","prevVertices","nextVertices","prev",22,"FlipXTimeline","boneIndex","flip","bones",23,"FlipYTimeline",24,"IkConstraint","bendDirection","findBone","apply1","apply2","targetX","targetY","parentRotation","atan2","radDeg","child","childRotation","positionX","positionY","tempPosition","temp","parentParent","childX","childY","offset","len1","sqrt","len2","cosDenom","childAngle","acos","adjacent","opposite","parentAngle",25,"IkConstraintData",26,"IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix",27,"uvs","regionUVs","triangles","hullLength","edges","Float32Array","verticesCount","vx","vy",28,"updateOffset","regionScaleX","regionScaleY","localX2","localY2","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices",29,"RotateTimeline","angle","amount","prevFrameValue",30,"ScaleTimeline","prevFrameX","prevFrameY",31,"Slot","Skeleton","slotData","boneCache","updateCache","ikConstraintsCount","arrayCount","nonIkBones","outer","cacheBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","ikConstraintName","./Bone","./IkConstraint","./Slot",32,"SkeletonBounds","polygonPool","polygons","boundingBoxes","minX","minY","maxX","maxY","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","x1","y1","x2","y2","m","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","../SpineRuntime",33,"SkeletonData","skins","animations","version","hash","findEvent","eventName",34,"SlotData","Skin","TranslateTimeline","SkeletonJsonParser","attachmentLoader","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","field","ffd","meshMap","meshName","isMesh","verticesValue","j","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./FlipXTimeline","./FlipYTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./SkeletonData","./Skin","./SlotData","./TranslateTimeline",35,"attachments","oldSkin",36,"wx","wy","weight","skeletonBones","w",37,"_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas",38,"multiply","blendModes","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL",39,40,41,"./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js",42,"PI",43,"spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","atlasParser","fromAtlas","resourceName","AnimCache","Object","create","constructor","defineProperties","get","updateTransform","autoUpdateTransform","set","dt","children","undefined","visible","sprites","position","tint","utils","rgb2hex","meshes","Date","now","timeDelta","descriptor","baseTexture","spriteRect","math","Rectangle","spriteTexture","Texture","Sprite","baseRotation","anchor","texture","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","../loaders/atlasParser",44,"Loader","addPixiMiddleware","loader","use","./atlasParser",45,"Resource","async","resource","isJson","atlasPath","url","lastIndexOf","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","add","res","spineAtlas","xhr","responseText","spineJsonParser","enableCaching","each","done","hasLoaded","once",46,"./Loader"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n",null,"var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\n\r\nspine.Atlas = function (atlasText, baseUrl, crossOrigin)\r\n{\r\n    if (baseUrl && baseUrl.indexOf('/') !== baseUrl.length)\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n\r\n    this.pages = [];\r\n    this.regions = [];\r\n\r\n    this.texturesLoading = 0;\r\n\r\n    var self = this;\r\n\r\n    var reader = new spine.AtlasReader(atlasText);\r\n    var tuple = [];\r\n    tuple.length = 4;\r\n    var page = null;\r\n    while (true)\r\n    {\r\n        var line = reader.readLine();\r\n        if (line === null) break;\r\n        line = reader.trim(line);\r\n        if (!line.length)\r\n            page = null;\r\n        else if (!page)\r\n        {\r\n            page = new spine.AtlasPage();\r\n            page.name = line;\r\n\r\n            if (reader.readTuple(tuple) == 2)\r\n            { // size is only optional for an atlas packed with an old TexturePacker.\r\n                page.width = parseInt(tuple[0]);\r\n                page.height = parseInt(tuple[1]);\r\n                reader.readTuple(tuple);\r\n            }\r\n            page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n            reader.readTuple(tuple);\r\n            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n            var direction = reader.readValue();\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            if (direction == \"x\")\r\n                page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"y\")\r\n                page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"xy\")\r\n                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n            page.rendererObject = PIXI.BaseTexture.fromImage(baseUrl + line, crossOrigin);\r\n\r\n            this.pages.push(page);\r\n\r\n        } else {\r\n            var region = new spine.AtlasRegion();\r\n            region.name = line;\r\n            region.page = page;\r\n\r\n            region.rotate = reader.readValue() == \"true\";\r\n\r\n            reader.readTuple(tuple);\r\n            var x = parseInt(tuple[0]);\r\n            var y = parseInt(tuple[1]);\r\n\r\n            reader.readTuple(tuple);\r\n            var width = parseInt(tuple[0]);\r\n            var height = parseInt(tuple[1]);\r\n\r\n            region.u = x / page.width;\r\n            region.v = y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (x + height) / page.width;\r\n                region.v2 = (y + width) / page.height;\r\n            } else {\r\n                region.u2 = (x + width) / page.width;\r\n                region.v2 = (y + height) / page.height;\r\n            }\r\n            region.x = x;\r\n            region.y = y;\r\n            region.width = Math.abs(width);\r\n            region.height = Math.abs(height);\r\n\r\n            if (reader.readTuple(tuple) == 4)\r\n            { // split is optional\r\n                region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                if (reader.readTuple(tuple) == 4)\r\n                { // pad is optional, but only present with splits\r\n                    region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                    reader.readTuple(tuple);\r\n                }\r\n            }\r\n\r\n            region.originalWidth = parseInt(tuple[0]);\r\n            region.originalHeight = parseInt(tuple[1]);\r\n\r\n            reader.readTuple(tuple);\r\n            region.offsetX = parseInt(tuple[0]);\r\n            region.offsetY = parseInt(tuple[1]);\r\n\r\n            region.index = parseInt(reader.readValue());\r\n\r\n            this.regions.push(region);\r\n        }\r\n    }\r\n};\r\nspine.Atlas.prototype = {\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.u = region.x / page.width;\r\n            region.v = region.y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (region.x + region.height) / page.width;\r\n                region.v2 = (region.y + region.width) / page.height;\r\n            } else {\r\n                region.u2 = (region.x + region.width) / page.width;\r\n                region.v2 = (region.y + region.height) / page.height;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.AtlasAttachmentParser = function (atlas)\r\n{\r\n    this.atlas = atlas;\r\n};\r\nspine.AtlasAttachmentParser.prototype = {\r\n    newRegionAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\r\n        var attachment = new spine.RegionAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.MeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newSkinnedMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.SkinnedMeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newBoundingBoxAttachment: function (skin, name)\r\n    {\r\n        return new spine.BoundingBoxAttachment(name);\r\n    }\r\n};\r\nmodule.exports = spine.AtlasAttachmentParser;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    page: null,\r\n    name: null,\r\n    x: 0, y: 0,\r\n    width: 0, height: 0,\r\n    u: 0, v: 0, u2: 0, v2: 0,\r\n    offsetX: 0, offsetY: 0,\r\n    originalWidth: 0, originalHeight: 0,\r\n    index: 0,\r\n    rotate: false,\r\n    splits: null,\r\n    pads: null\r\n};\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = {\r\n    region: 0,\r\n    boundingbox: 1,\r\n    mesh: 2,\r\n    skinnedmesh: 3\r\n};\r\nmodule.exports = spine.AttachmentType;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = function (boneData, skeleton, parent)\r\n{\r\n    this.data = boneData;\r\n    this.skeleton = skeleton;\r\n    this.parent = parent;\r\n    this.setToSetupPose();\r\n};\r\nspine.Bone.yDown = false;\r\nspine.Bone.prototype = {\r\n    x: 0, y: 0,\r\n    rotation: 0, rotationIK: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    flipX: false, flipY: false,\r\n    m00: 0, m01: 0, worldX: 0, // a b x\r\n    m10: 0, m11: 0, worldY: 0, // c d y\r\n    worldRotation: 0,\r\n    worldScaleX: 1, worldScaleY: 1,\r\n    worldFlipX: false, worldFlipY: false,\r\n    updateWorldTransform: function ()\r\n    {\r\n        var parent = this.parent;\r\n        if (parent)\r\n        {\r\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\r\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\r\n            if (this.data.inheritScale)\r\n            {\r\n                this.worldScaleX = parent.worldScaleX * this.scaleX;\r\n                this.worldScaleY = parent.worldScaleY * this.scaleY;\r\n            } else {\r\n                this.worldScaleX = this.scaleX;\r\n                this.worldScaleY = this.scaleY;\r\n            }\r\n            this.worldRotation = this.data.inheritRotation ? (parent.worldRotation + this.rotationIK) : this.rotationIK;\r\n            this.worldFlipX = parent.worldFlipX != this.flipX;\r\n            this.worldFlipY = parent.worldFlipY != this.flipY;\r\n        } else {\r\n            var skeletonFlipX = this.skeleton.flipX, skeletonFlipY = this.skeleton.flipY;\r\n            this.worldX = skeletonFlipX ? -this.x : this.x;\r\n            this.worldY = (skeletonFlipY != spine.Bone.yDown) ? -this.y : this.y;\r\n            this.worldScaleX = this.scaleX;\r\n            this.worldScaleY = this.scaleY;\r\n            this.worldRotation = this.rotationIK;\r\n            this.worldFlipX = skeletonFlipX != this.flipX;\r\n            this.worldFlipY = skeletonFlipY != this.flipY;\r\n        }\r\n        var radians = this.worldRotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        if (this.worldFlipX)\r\n        {\r\n            this.m00 = -cos * this.worldScaleX;\r\n            this.m01 = sin * this.worldScaleY;\r\n        } else {\r\n            this.m00 = cos * this.worldScaleX;\r\n            this.m01 = -sin * this.worldScaleY;\r\n        }\r\n        if (this.worldFlipY != spine.Bone.yDown)\r\n        {\r\n            this.m10 = -sin * this.worldScaleX;\r\n            this.m11 = -cos * this.worldScaleY;\r\n        } else {\r\n            this.m10 = sin * this.worldScaleX;\r\n            this.m11 = cos * this.worldScaleY;\r\n        }\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.rotationIK = this.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.flipX = data.flipX;\r\n        this.flipY = data.flipY;\r\n    },\r\n    worldToLocal: function (world)\r\n    {\r\n        var dx = world[0] - this.worldX, dy = world[1] - this.worldY;\r\n        var m00 = this.m00, m10 = this.m10, m01 = this.m01, m11 = this.m11;\r\n        if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown))\r\n        {\r\n            m00 = -m00;\r\n            m11 = -m11;\r\n        }\r\n        var invDet = 1 / (m00 * m11 - m01 * m10);\r\n        world[0] = dx * m00 * invDet - dy * m01 * invDet;\r\n        world[1] = dy * m11 * invDet - dx * m10 * invDet;\r\n    },\r\n    localToWorld: function (local)\r\n    {\r\n        var localX = local[0], localY = local[1];\r\n        local[0] = localX * this.m00 + localY * this.m01 + this.worldX;\r\n        local[1] = localX * this.m10 + localY * this.m11 + this.worldY;\r\n    }\r\n};\r\nmodule.exports = spine.Bone;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.BoneData = function (name, parent)\r\n{\r\n    this.name = name;\r\n    this.parent = parent;\r\n};\r\nspine.BoneData.prototype = {\r\n    length: 0,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    inheritScale: true,\r\n    inheritRotation: true,\r\n    flipX: false, flipY: false\r\n};\r\nmodule.exports = spine.BoneData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (slot.attachment != this.attachment) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) alpha = 1;\r\n        vertices.length = vertexCount;\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipXTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipXTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipX = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipXTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipYTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipYTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipY = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipYTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.IkConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.mix = data.mix;\r\n    this.bendDirection = data.bendDirection;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = data.bones.length; i < n; i++)\r\n        this.bones.push(skeleton.findBone(data.bones[i].name));\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\nspine.IkConstraint.prototype = {\r\n    apply: function ()\r\n    {\r\n        var target = this.target;\r\n        var bones = this.bones;\r\n        switch (bones.length)\r\n        {\r\n        case 1:\r\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n};\r\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n * coordinate system. */\r\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\r\n{\r\n    var parentRotation = (!bone.data.inheritRotation || !bone.parent) ? 0 : bone.parent.worldRotation;\r\n    var rotation = bone.rotation;\r\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\r\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\r\n};\r\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n * target is specified in the world coordinate system.\r\n * @param child Any descendant bone of the parent. */\r\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDirection, alpha)\r\n{\r\n    var childRotation = child.rotation, parentRotation = parent.rotation;\r\n    if (!alpha)\r\n    {\r\n        child.rotationIK = childRotation;\r\n        parent.rotationIK = parentRotation;\r\n        return;\r\n    }\r\n    var positionX, positionY, tempPosition = spine.temp;\r\n    var parentParent = parent.parent;\r\n    if (parentParent)\r\n    {\r\n        tempPosition[0] = targetX;\r\n        tempPosition[1] = targetY;\r\n        parentParent.worldToLocal(tempPosition);\r\n        targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;\r\n        targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;\r\n    } else {\r\n        targetX -= parent.x;\r\n        targetY -= parent.y;\r\n    }\r\n    if (child.parent == parent)\r\n    {\r\n        positionX = child.x;\r\n        positionY = child.y;\r\n    } else {\r\n        tempPosition[0] = child.x;\r\n        tempPosition[1] = child.y;\r\n        child.parent.localToWorld(tempPosition);\r\n        parent.worldToLocal(tempPosition);\r\n        positionX = tempPosition[0];\r\n        positionY = tempPosition[1];\r\n    }\r\n    var childX = positionX * parent.worldScaleX, childY = positionY * parent.worldScaleY;\r\n    var offset = Math.atan2(childY, childX);\r\n    var len1 = Math.sqrt(childX * childX + childY * childY), len2 = child.data.length * child.worldScaleX;\r\n    // Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/\r\n    var cosDenom = 2 * len1 * len2;\r\n    if (cosDenom < 0.0001)\r\n    {\r\n        child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;\r\n        return;\r\n    }\r\n    var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;\r\n    if (cos < -1)\r\n        cos = -1;\r\n    else if (cos > 1)\r\n        cos = 1;\r\n    var childAngle = Math.acos(cos) * bendDirection;\r\n    var adjacent = len1 + len2 * cos, opposite = len2 * Math.sin(childAngle);\r\n    var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);\r\n    var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    parent.rotationIK = parentRotation + rotation * alpha;\r\n    rotation = (childAngle + offset) * spine.radDeg - childRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;\r\n};\r\nmodule.exports = spine.IkConstraint;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.MeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.MeshAttachment.prototype = {\r\n    type: spine.AttachmentType.mesh,\r\n    vertices: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function ()\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var bone = slot.bone;\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        var verticesCount = vertices.length;\r\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\r\n        for (var i = 0; i < verticesCount; i += 2)\r\n        {\r\n            var vx = vertices[i];\r\n            var vy = vertices[i + 1];\r\n            worldVertices[i] = vx * m00 + vy * m01 + x;\r\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.MeshAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.RegionAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.offset = [];\r\n    this.offset.length = 8;\r\n    this.uvs = [];\r\n    this.uvs.length = 8;\r\n};\r\nspine.RegionAttachment.prototype = {\r\n    type: spine.AttachmentType.region,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    width: 0, height: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    setUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var uvs = this.uvs;\r\n        if (rotate)\r\n        {\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v2;\r\n            uvs[4/*X3*/] = u;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v;\r\n            uvs[0/*X1*/] = u2;\r\n            uvs[1/*Y1*/] = v2;\r\n        } else {\r\n            uvs[0/*X1*/] = u;\r\n            uvs[1/*Y1*/] = v2;\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v;\r\n            uvs[4/*X3*/] = u2;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v2;\r\n        }\r\n    },\r\n    updateOffset: function ()\r\n    {\r\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\r\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\r\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\r\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\r\n        var localX2 = localX + this.regionWidth * regionScaleX;\r\n        var localY2 = localY + this.regionHeight * regionScaleY;\r\n        var radians = this.rotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        var localXCos = localX * cos + this.x;\r\n        var localXSin = localX * sin;\r\n        var localYCos = localY * cos + this.y;\r\n        var localYSin = localY * sin;\r\n        var localX2Cos = localX2 * cos + this.x;\r\n        var localX2Sin = localX2 * sin;\r\n        var localY2Cos = localY2 * cos + this.y;\r\n        var localY2Sin = localY2 * sin;\r\n        var offset = this.offset;\r\n        offset[0/*X1*/] = localXCos - localYSin;\r\n        offset[1/*Y1*/] = localYCos + localXSin;\r\n        offset[2/*X2*/] = localXCos - localY2Sin;\r\n        offset[3/*Y2*/] = localY2Cos + localXSin;\r\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\r\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\r\n        offset[6/*X4*/] = localX2Cos - localYSin;\r\n        offset[7/*Y4*/] = localYCos + localX2Sin;\r\n    },\r\n    computeVertices: function (x, y, bone, vertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var offset = this.offset;\r\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\r\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\r\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\r\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\r\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\r\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\r\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\r\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\r\n    }\r\n};\r\nmodule.exports = spine.RegionAttachment;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = require('./Bone');\r\nspine.Slot = require('./Slot');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.Skeleton = function (skeletonData)\r\n{\r\n    this.data = skeletonData;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\r\n    {\r\n        var boneData = skeletonData.bones[i];\r\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\r\n        this.bones.push(new spine.Bone(boneData, this, parent));\r\n    }\r\n\r\n    this.slots = [];\r\n    this.drawOrder = [];\r\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\r\n    {\r\n        var slotData = skeletonData.slots[i];\r\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\r\n        var slot = new spine.Slot(slotData, bone);\r\n        this.slots.push(slot);\r\n        this.drawOrder.push(i);\r\n    }\r\n\r\n    this.ikConstraints = [];\r\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\r\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\r\n\r\n    this.boneCache = [];\r\n    this.updateCache();\r\n};\r\nspine.Skeleton.prototype = {\r\n    x: 0, y: 0,\r\n    skin: null,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    time: 0,\r\n    flipX: false, flipY: false,\r\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\r\n    updateCache: function ()\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        var ikConstraintsCount = ikConstraints.length;\r\n\r\n        var arrayCount = ikConstraintsCount + 1;\r\n        var boneCache = this.boneCache;\r\n        if (boneCache.length > arrayCount) boneCache.length = arrayCount;\r\n        for (var i = 0, n = boneCache.length; i < n; i++)\r\n            boneCache[i].length = 0;\r\n        while (boneCache.length < arrayCount)\r\n            boneCache[boneCache.length] = [];\r\n\r\n        var nonIkBones = boneCache[0];\r\n        var bones = this.bones;\r\n\r\n        outer:\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            var current = bone;\r\n            do {\r\n                for (var ii = 0; ii < ikConstraintsCount; ii++)\r\n                {\r\n                    var ikConstraint = ikConstraints[ii];\r\n                    var parent = ikConstraint.bones[0];\r\n                    var child= ikConstraint.bones[ikConstraint.bones.length - 1];\r\n                    while (true)\r\n                    {\r\n                        if (current == child)\r\n                        {\r\n                            boneCache[ii].push(bone);\r\n                            boneCache[ii + 1].push(bone);\r\n                            continue outer;\r\n                        }\r\n                        if (child == parent) break;\r\n                        child = child.parent;\r\n                    }\r\n                }\r\n                current = current.parent;\r\n            } while (current);\r\n            nonIkBones[nonIkBones.length] = bone;\r\n        }\r\n    },\r\n    /** Updates the world transform for each bone. */\r\n    updateWorldTransform: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            bone.rotationIK = bone.rotation;\r\n        }\r\n        var i = 0, last = this.boneCache.length - 1;\r\n        while (true)\r\n        {\r\n            var cacheBones = this.boneCache[i];\r\n            for (var ii = 0, nn = cacheBones.length; ii < nn; ii++)\r\n                cacheBones[ii].updateWorldTransform();\r\n            if (i == last) break;\r\n            this.ikConstraints[i].apply();\r\n            i++;\r\n        }\r\n    },\r\n    /** Sets the bones and slots to their setup pose values. */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    },\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n        {\r\n            var ikConstraint = ikConstraints[i];\r\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\r\n            ikConstraint.mix = ikConstraint.data.mix;\r\n        }\r\n    },\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            slots[i].setToSetupPose(i);\r\n        }\r\n\r\n        this.resetDrawOrder();\r\n    },\r\n    /** @return May return null. */\r\n    getRootBone: function ()\r\n    {\r\n        return this.bones.length ? this.bones[0] : null;\r\n    },\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return slots[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    },\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skin = this.data.findSkin(skinName);\r\n        if (!skin) throw \"Skin not found: \" + skinName;\r\n        this.setSkin(skin);\r\n    },\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin: function (newSkin)\r\n    {\r\n        if (newSkin)\r\n        {\r\n            if (this.skin)\r\n                newSkin._attachAll(this, this.skin);\r\n            else\r\n            {\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                {\r\n                    var slot = slots[i];\r\n                    var name = slot.data.attachmentName;\r\n                    if (name)\r\n                    {\r\n                        var attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotName: function (slotName, attachmentName)\r\n    {\r\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\r\n    {\r\n        if (this.skin)\r\n        {\r\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    },\r\n    /** @param attachmentName May be null. */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slot = slots[i];\r\n            if (slot.data.name == slotName)\r\n            {\r\n                var attachment = null;\r\n                if (attachmentName)\r\n                {\r\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\r\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw \"Slot not found: \" + slotName;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (ikConstraintName)\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n            if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];\r\n        return null;\r\n    },\r\n    update: function (delta)\r\n    {\r\n        this.time += delta;\r\n    },\r\n    resetDrawOrder: function () {\r\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\r\n        {\r\n            this.drawOrder[i] = i;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skeleton;\r\n\r\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (ikConstraintName)\n    {\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n            if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];\n        return null;\n    }\n};\nmodule.exports = spine.SkeletonData;\n\n","var spine = require('../SpineUtil');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.BoneData = require('./BoneData');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.SlotData = require('./SlotData');\r\nspine.Skin = require('./Skin');\r\nspine.EventData = require('./EventData');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nspine.FlipXTimeline = require('./FlipXTimeline');\r\nspine.FlipYTimeline = require('./FlipYTimeline');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.Event = require('./Event');\r\nspine.Animation = require('./Animation');\r\nspine.SkeletonJsonParser = function (attachmentLoader)\r\n{\r\n    this.attachmentLoader = attachmentLoader;\r\n};\r\nspine.SkeletonJsonParser.prototype = {\r\n    scale: 1,\r\n    readSkeletonData: function (root, name)\r\n    {\r\n        var skeletonData = new spine.SkeletonData();\r\n        skeletonData.name = name;\r\n\r\n        // Skeleton.\r\n        var skeletonMap = root[\"skeleton\"];\r\n        if (skeletonMap)\r\n        {\r\n            skeletonData.hash = skeletonMap[\"hash\"];\r\n            skeletonData.version = skeletonMap[\"spine\"];\r\n            skeletonData.width = skeletonMap[\"width\"] || 0;\r\n            skeletonData.height = skeletonMap[\"height\"] || 0;\r\n        }\r\n\r\n        // Bones.\r\n        var bones = root[\"bones\"];\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var boneMap = bones[i];\r\n            var parent = null;\r\n            if (boneMap[\"parent\"])\r\n            {\r\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\r\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\r\n            }\r\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\r\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\r\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\r\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\r\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\r\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\r\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\r\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\r\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\r\n            skeletonData.bones.push(boneData);\r\n        }\r\n\r\n        // IK constraints.\r\n        var ik = root[\"ik\"];\r\n        if (ik)\r\n        {\r\n            for (var i = 0, n = ik.length; i < n; i++)\r\n            {\r\n                var ikMap = ik[i];\r\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\r\n\r\n                var bones = ikMap[\"bones\"];\r\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\r\n                {\r\n                    var bone = skeletonData.findBone(bones[ii]);\r\n                    if (!bone) throw \"IK bone not found: \" + bones[ii];\r\n                    ikConstraintData.bones.push(bone);\r\n                }\r\n\r\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\r\n                if (!ikConstraintData.target) throw \"Target bone not found: \" + ikMap[\"target\"];\r\n\r\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\r\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\r\n\r\n                skeletonData.ikConstraints.push(ikConstraintData);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        var slots = root[\"slots\"];\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slotMap = slots[i];\r\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\r\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\r\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\r\n\r\n            var color = slotMap[\"color\"];\r\n            if (color)\r\n            {\r\n                slotData.r = this.toColor(color, 0);\r\n                slotData.g = this.toColor(color, 1);\r\n                slotData.b = this.toColor(color, 2);\r\n                slotData.a = this.toColor(color, 3);\r\n            }\r\n\r\n            slotData.attachmentName = slotMap[\"attachment\"];\r\n\r\n\r\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\r\n\r\n            skeletonData.slots.push(slotData);\r\n        }\r\n\r\n        // Skins.\r\n        var skins = root[\"skins\"];\r\n        for (var skinName in skins)\r\n        {\r\n            if (!skins.hasOwnProperty(skinName)) continue;\r\n            var skinMap = skins[skinName];\r\n            var skin = new spine.Skin(skinName);\r\n            for (var slotName in skinMap)\r\n            {\r\n                if (!skinMap.hasOwnProperty(slotName)) continue;\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var slotEntry = skinMap[slotName];\r\n                for (var attachmentName in slotEntry)\r\n                {\r\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\r\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\r\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\r\n                }\r\n            }\r\n            skeletonData.skins.push(skin);\r\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n        }\r\n\r\n        // Events.\r\n        var events = root[\"events\"];\r\n        for (var eventName in events)\r\n        {\r\n            if (!events.hasOwnProperty(eventName)) continue;\r\n            var eventMap = events[eventName];\r\n            var eventData = new spine.EventData(eventName);\r\n            eventData.intValue = eventMap[\"int\"] || 0;\r\n            eventData.floatValue = eventMap[\"float\"] || 0;\r\n            eventData.stringValue = eventMap[\"string\"] || null;\r\n            skeletonData.events.push(eventData);\r\n        }\r\n\r\n        // Animations.\r\n        var animations = root[\"animations\"];\r\n        for (var animationName in animations)\r\n        {\r\n            if (!animations.hasOwnProperty(animationName)) continue;\r\n            this.readAnimation(animationName, animations[animationName], skeletonData);\r\n        }\r\n\r\n        return skeletonData;\r\n    },\r\n    readAttachment: function (skin, name, map)\r\n    {\r\n        name = map[\"name\"] || name;\r\n\r\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\r\n        var path = map[\"path\"] || name;\r\n\r\n        var scale = this.scale;\r\n        if (type == spine.AttachmentType.region)\r\n        {\r\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n            if (!region) return null;\r\n            region.path = path;\r\n            region.x = (map[\"x\"] || 0) * scale;\r\n            region.y = (map[\"y\"] || 0) * scale;\r\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\r\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\r\n            region.rotation = map[\"rotation\"] || 0;\r\n            region.width = (map[\"width\"] || 0) * scale;\r\n            region.height = (map[\"height\"] || 0) * scale;\r\n\r\n            var color = map[\"color\"];\r\n            if (color)\r\n            {\r\n                region.r = this.toColor(color, 0);\r\n                region.g = this.toColor(color, 1);\r\n                region.b = this.toColor(color, 2);\r\n                region.a = this.toColor(color, 3);\r\n            }\r\n\r\n            region.updateOffset();\r\n            return region;\r\n        } else if (type == spine.AttachmentType.mesh)\r\n        {\r\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n            if (!mesh) return null;\r\n            mesh.path = path;\r\n            mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\r\n            mesh.triangles = this.getIntArray(map, \"triangles\");\r\n            mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\r\n            mesh.updateUVs();\r\n\r\n            color = map[\"color\"];\r\n            if (color)\r\n            {\r\n                mesh.r = this.toColor(color, 0);\r\n                mesh.g = this.toColor(color, 1);\r\n                mesh.b = this.toColor(color, 2);\r\n                mesh.a = this.toColor(color, 3);\r\n            }\r\n\r\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n            mesh.width = (map[\"width\"] || 0) * scale;\r\n            mesh.height = (map[\"height\"] || 0) * scale;\r\n            return mesh;\r\n        } else if (type == spine.AttachmentType.skinnedmesh)\r\n        {\r\n            var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);\r\n            if (!mesh) return null;\r\n            mesh.path = path;\r\n\r\n            var uvs = this.getFloatArray(map, \"uvs\", 1);\r\n            var vertices = this.getFloatArray(map, \"vertices\", 1);\r\n            var weights = [];\r\n            var bones = [];\r\n            for (var i = 0, n = vertices.length; i < n; )\r\n            {\r\n                var boneCount = vertices[i++] | 0;\r\n                bones[bones.length] = boneCount;\r\n                for (var nn = i + boneCount * 4; i < nn; )\r\n                {\r\n                    bones[bones.length] = vertices[i];\r\n                    weights[weights.length] = vertices[i + 1] * scale;\r\n                    weights[weights.length] = vertices[i + 2] * scale;\r\n                    weights[weights.length] = vertices[i + 3];\r\n                    i += 4;\r\n                }\r\n            }\r\n            mesh.bones = bones;\r\n            mesh.weights = weights;\r\n            mesh.triangles = this.getIntArray(map, \"triangles\");\r\n            mesh.regionUVs = uvs;\r\n            mesh.updateUVs();\r\n\r\n            color = map[\"color\"];\r\n            if (color)\r\n            {\r\n                mesh.r = this.toColor(color, 0);\r\n                mesh.g = this.toColor(color, 1);\r\n                mesh.b = this.toColor(color, 2);\r\n                mesh.a = this.toColor(color, 3);\r\n            }\r\n\r\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n            mesh.width = (map[\"width\"] || 0) * scale;\r\n            mesh.height = (map[\"height\"] || 0) * scale;\r\n            return mesh;\r\n        } else if (type == spine.AttachmentType.boundingbox)\r\n        {\r\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n            var vertices = map[\"vertices\"];\r\n            for (var i = 0, n = vertices.length; i < n; i++)\r\n                attachment.vertices.push(vertices[i] * scale);\r\n            return attachment;\r\n        }\r\n        throw \"Unknown attachment type: \" + type;\r\n    },\r\n    readAnimation: function (name, map, skeletonData)\r\n    {\r\n        var timelines = [];\r\n        var duration = 0;\r\n\r\n        var slots = map[\"slots\"];\r\n        for (var slotName in slots)\r\n        {\r\n            if (!slots.hasOwnProperty(slotName)) continue;\r\n            var slotMap = slots[slotName];\r\n            var slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n            for (var timelineName in slotMap)\r\n            {\r\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\r\n                var values = slotMap[timelineName];\r\n                if (timelineName == \"color\")\r\n                {\r\n                    var timeline = new spine.ColorTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var color = valueMap[\"color\"];\r\n                        var r = this.toColor(color, 0);\r\n                        var g = this.toColor(color, 1);\r\n                        var b = this.toColor(color, 2);\r\n                        var a = this.toColor(color, 3);\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\r\n\r\n                } else if (timelineName == \"attachment\")\r\n                {\r\n                    var timeline = new spine.AttachmentTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\r\n                } else\r\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\r\n            }\r\n        }\r\n\r\n        var bones = map[\"bones\"];\r\n        for (var boneName in bones)\r\n        {\r\n            if (!bones.hasOwnProperty(boneName)) continue;\r\n            var boneIndex = skeletonData.findBoneIndex(boneName);\r\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\r\n            var boneMap = bones[boneName];\r\n\r\n            for (var timelineName in boneMap)\r\n            {\r\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\r\n                var values = boneMap[timelineName];\r\n                if (timelineName == \"rotate\")\r\n                {\r\n                    var timeline = new spine.RotateTimeline(values.length);\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\r\n\r\n                } else if (timelineName == \"translate\" || timelineName == \"scale\")\r\n                {\r\n                    var timeline;\r\n                    var timelineScale = 1;\r\n                    if (timelineName == \"scale\")\r\n                        timeline = new spine.ScaleTimeline(values.length);\r\n                    else\r\n                    {\r\n                        timeline = new spine.TranslateTimeline(values.length);\r\n                        timelineScale = this.scale;\r\n                    }\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\r\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n\r\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\r\n                {\r\n                    var x = timelineName == \"flipX\";\r\n                    var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var field = x ? \"x\" : \"y\";\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[field] || false);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\r\n                } else\r\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\r\n            }\r\n        }\r\n\r\n        var ikMap = map[\"ik\"];\r\n        for (var ikConstraintName in ikMap)\r\n        {\r\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\r\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\r\n            var values = ikMap[ikConstraintName];\r\n            var timeline = new spine.IkConstraintTimeline(values.length);\r\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = values.length; i < n; i++)\r\n            {\r\n                var valueMap = values[i];\r\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\r\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\r\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\r\n                this.readCurve(timeline, frameIndex, valueMap);\r\n                frameIndex++;\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n        }\r\n\r\n        var ffd = map[\"ffd\"];\r\n        for (var skinName in ffd)\r\n        {\r\n            var skin = skeletonData.findSkin(skinName);\r\n            var slotMap = ffd[skinName];\r\n            for (slotName in slotMap)\r\n            {\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var meshMap = slotMap[slotName];\r\n                for (var meshName in meshMap)\r\n                {\r\n                    var values = meshMap[meshName];\r\n                    var timeline = new spine.FfdTimeline(values.length);\r\n                    var attachment = skin.getAttachment(slotIndex, meshName);\r\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\r\n                    var vertexCount;\r\n                    if (isMesh)\r\n                        vertexCount = attachment.vertices.length;\r\n                    else\r\n                        vertexCount = attachment.weights.length / 3 * 2;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var vertices;\r\n                        if (!valueMap[\"vertices\"])\r\n                        {\r\n                            if (isMesh)\r\n                                vertices = attachment.vertices;\r\n                            else\r\n                            {\r\n                                vertices = [];\r\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            }\r\n                        } else {\r\n                            var verticesValue = valueMap[\"vertices\"];\r\n                            vertices = [];\r\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            var start = valueMap[\"offset\"] || 0;\r\n                            var nn = verticesValue.length;\r\n                            if (this.scale == 1)\r\n                            {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii];\r\n                            } else {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\r\n                            }\r\n                            if (isMesh)\r\n                            {\r\n                                var meshVertices = attachment.vertices;\r\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\r\n                                    vertices[ii] += meshVertices[ii];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines[timelines.length] = timeline;\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        var drawOrderValues = map[\"drawOrder\"];\r\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\r\n        if (drawOrderValues)\r\n        {\r\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\r\n            var slotCount = skeletonData.slots.length;\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\r\n            {\r\n                var drawOrderMap = drawOrderValues[i];\r\n                var drawOrder = null;\r\n                if (drawOrderMap[\"offsets\"])\r\n                {\r\n                    drawOrder = [];\r\n                    drawOrder.length = slotCount;\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        drawOrder[ii] = -1;\r\n                    var offsets = drawOrderMap[\"offsets\"];\r\n                    var unchanged = [];\r\n                    unchanged.length = slotCount - offsets.length;\r\n                    var originalIndex = 0, unchangedIndex = 0;\r\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\r\n                    {\r\n                        var offsetMap = offsets[ii];\r\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\r\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        var events = map[\"events\"];\r\n        if (events)\r\n        {\r\n            var timeline = new spine.EventTimeline(events.length);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = events.length; i < n; i++)\r\n            {\r\n                var eventMap = events[i];\r\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\r\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\r\n                var event = new spine.Event(eventData);\r\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\r\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\r\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\r\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n    },\r\n    readCurve: function (timeline, frameIndex, valueMap)\r\n    {\r\n        var curve = valueMap[\"curve\"];\r\n        if (!curve)\r\n            timeline.curves.setLinear(frameIndex);\r\n        else if (curve == \"stepped\")\r\n            timeline.curves.setStepped(frameIndex);\r\n        else if (curve instanceof Array)\r\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n    },\r\n    toColor: function (hexString, colorIndex)\r\n    {\r\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\r\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\r\n    },\r\n    getFloatArray: function (map, name, scale)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Float32Array(list.length);\r\n        var i = 0, n = list.length;\r\n        if (scale == 1)\r\n        {\r\n            for (; i < n; i++)\r\n                values[i] = list[i];\r\n        } else {\r\n            for (; i < n; i++)\r\n                values[i] = list[i] * scale;\r\n        }\r\n        return values;\r\n    },\r\n    getIntArray: function (map, name)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Uint16Array(list.length);\r\n        for (var i = 0, n = list.length; i < n; i++)\r\n            values[i] = list[i] | 0;\r\n        return values;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonJsonParser;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkinnedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.SkinnedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.skinnedmesh,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, bone, vx, vy, weight;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.SkinnedMeshAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.blendModes.MULTIPLY,\r\n    'screen': PIXI.blendModes.SCREEN,\r\n    'additive': PIXI.blendModes.ADD,\r\n    'normal': PIXI.blendModes.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.blendModes.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.1\r\n *\r\n * Copyright (c) 2013, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable and\r\n * non-transferable license to install, execute and perform the Spine Runtimes\r\n * Software (the \"Software\") solely for internal use. Without the written\r\n * permission of Esoteric Software (typically granted by licensing Spine), you\r\n * may not (a) modify, translate, adapt or otherwise create derivative works,\r\n * improvements of the Software or develop new applications using the Software\r\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\r\n * trademark, patent or other intellectual property or proprietary rights\r\n * notices on or in the Software, including any copy thereof. Redistributions\r\n * in binary or source form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.AnimationStateData = require('./AnimationStateData');\r\nspine.AnimationState = require('./AnimationState');\r\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\r\nspine.Atlas = require('./Atlas');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoneData = require('./BoneData');\r\nspine.Bone = require('./Bone');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.Curves = require('./Curves');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventData = require('./EventData');\r\nspine.Event = require('./Event');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.FlipXTimeline = require('./FlipXTimeline');\r\nspine.FlipYTimeline = require('./FlipYTimeline');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.SkeletonBounds = require('./SkeletonBounds');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.Skeleton = require('./Skeleton');\r\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\r\nspine.Skin = require('./Skin.js');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.SlotData = require('./SlotData');\r\nspine.Slot = require('./Slot');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nmodule.exports = spine;\r\n","module.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array\r\n};\r\n\r\n","var spine = require('../SpineRuntime');\r\nvar atlasParser = require('../loaders/atlasParser');\r\n\r\n/* Esoteric Software SPINE wrapper for pixi.js */\r\nspine.Bone.yDown = true;\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * var spineAnimation = new PIXI.Spine(spineData);\r\n * ```\r\n *\r\n * @class\r\n * @extends Container\r\n * @memberof PIXI.spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nfunction Spine(spineData)\r\n{\r\n    PIXI.Container.call(this);\r\n\r\n    if (!spineData)\r\n    {\r\n        throw new Error('The spineData param is required.');\r\n    }\r\n\r\n    if ((typeof spineData) === \"string\")\r\n    {\r\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n    }\r\n\r\n    /**\r\n     * The spineData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.spineData = spineData;\r\n\r\n    /**\r\n     * A spine Skeleton object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.skeleton = new spine.Skeleton(spineData);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    /**\r\n     * A spine AnimationStateData object created from the spine data passed in the constructor\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.stateData = new spine.AnimationStateData(spineData);\r\n\r\n    /**\r\n     * A spine AnimationState object created from the spine AnimationStateData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.state = new spine.AnimationState(this.stateData);\r\n\r\n    /**\r\n     * An array of containers\r\n     *\r\n     * @member {Container[]}\r\n     */\r\n    this.slotContainers = [];\r\n\r\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\r\n    {\r\n        var slot = this.skeleton.slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = new PIXI.Container();\r\n        this.slotContainers.push(slotContainer);\r\n        this.addChild(slotContainer);\r\n\r\n        if (attachment instanceof spine.RegionAttachment)\r\n        {\r\n            var spriteName = attachment.rendererObject.name;\r\n            var sprite = this.createSprite(slot, attachment);\r\n            slot.currentSprite = sprite;\r\n            slot.currentSpriteName = spriteName;\r\n            slotContainer.addChild(sprite);\r\n        }\r\n        else if (attachment instanceof spine.MeshAttachment)\r\n        {\r\n            var mesh = this.createMesh(slot, attachment);\r\n            slot.currentMesh = mesh;\r\n            slot.currentMeshName = attachment.name;\r\n            slotContainer.addChild(mesh);\r\n        }\r\n        else\r\n        {\r\n            continue;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Should the Spine object update its transforms\r\n     *\r\n     * @member {boolean}\r\n     */\r\n    this.autoUpdate = true;\r\n}\r\n\r\nSpine.fromAtlas = function(resourceName) {\r\n    var skeletonData = atlasParser.AnimCache[resourceName];\r\n\r\n    if (!skeletonData)\r\n    {\r\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\r\n    }\r\n\r\n    return new Spine(skeletonData);\r\n}\r\n\r\nSpine.prototype = Object.create(PIXI.Container.prototype);\r\nSpine.prototype.constructor = Spine;\r\nmodule.exports = Spine;\r\n\r\nObject.defineProperties(Spine.prototype, {\r\n    /**\r\n     * If this flag is set to true, the spine animation will be autoupdated every time\r\n     * the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoupdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof Spine#\r\n     * @default true\r\n     */\r\n    autoUpdate: {\r\n        get: function ()\r\n        {\r\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Update the spine skeleton and its animations by delta time (dt)\r\n *\r\n * @param dt {number} Delta time. Time by which the animation should be updated\r\n */\r\nSpine.prototype.update = function (dt)\r\n{\r\n    this.state.update(dt);\r\n    this.state.apply(this.skeleton);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    var drawOrder = this.skeleton.drawOrder;\r\n    var slots = this.skeleton.slots;\r\n\r\n    for (var i = 0, n = drawOrder.length; i < n; i++)\r\n    {\r\n        this.children[i] = this.slotContainers[drawOrder[i]];\r\n    }\r\n\r\n    for (i = 0, n = slots.length; i < n; i++)\r\n    {\r\n        var slot = slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = this.slotContainers[i];\r\n\r\n        if (!attachment)\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n\r\n        var type = attachment.type;\r\n        if (type === spine.AttachmentType.region)\r\n        {\r\n            if (attachment.rendererObject)\r\n            {\r\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\r\n                {\r\n                    var spriteName = attachment.rendererObject.name;\r\n                    if (slot.currentSprite !== undefined)\r\n                    {\r\n                        slot.currentSprite.visible = false;\r\n                    }\r\n                    slot.sprites = slot.sprites || {};\r\n                    if (slot.sprites[spriteName] !== undefined)\r\n                    {\r\n                        slot.sprites[spriteName].visible = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        var sprite = this.createSprite(slot, attachment);\r\n                        slotContainer.addChild(sprite);\r\n                    }\r\n                    slot.currentSprite = slot.sprites[spriteName];\r\n                    slot.currentSpriteName = spriteName;\r\n                }\r\n            }\r\n\r\n            var bone = slot.bone;\r\n\r\n            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\r\n            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\r\n            slotContainer.scale.x = bone.worldScaleX;\r\n            slotContainer.scale.y = bone.worldScaleY;\r\n\r\n            slotContainer.rotation = -(slot.bone.worldRotation * spine.degRad);\r\n            slot.currentSprite.blendMode = slot.blendMode;\r\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\r\n        }\r\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\r\n        {\r\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\r\n            {\r\n                var meshName = attachment.name;\r\n                if (slot.currentMesh !== undefined)\r\n                {\r\n                    slot.currentMesh.visible = false;\r\n                }\r\n\r\n                slot.meshes = slot.meshes || {};\r\n\r\n                if (slot.meshes[meshName] !== undefined)\r\n                {\r\n                    slot.meshes[meshName].visible = true;\r\n                }\r\n                else\r\n                {\r\n                    var mesh = this.createMesh(slot, attachment);\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n\r\n                slot.currentMesh = slot.meshes[meshName];\r\n                slot.currentMeshName = meshName;\r\n            }\r\n\r\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\r\n\r\n        }\r\n        else\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n        slotContainer.visible = true;\r\n\r\n        slotContainer.alpha = slot.a;\r\n    }\r\n};\r\n\r\n/**\r\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n *\r\n * @private\r\n */\r\nSpine.prototype.autoUpdateTransform = function ()\r\n{\r\n    this.lastTime = this.lastTime || Date.now();\r\n    var timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n    this.lastTime = Date.now();\r\n\r\n    this.update(timeDelta);\r\n\r\n    PIXI.Container.prototype.updateTransform.call(this);\r\n};\r\n\r\n/**\r\n * Create a new sprite to be used with spine.RegionAttachment\r\n *\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createSprite = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var baseTexture = descriptor.page.rendererObject;\r\n    var spriteRect = new PIXI.math.Rectangle(descriptor.x,\r\n                                        descriptor.y,\r\n                                        descriptor.rotate ? descriptor.height : descriptor.width,\r\n                                        descriptor.rotate ? descriptor.width : descriptor.height);\r\n    var spriteTexture = new PIXI.Texture(baseTexture, spriteRect);\r\n    var sprite = new PIXI.Sprite(spriteTexture);\r\n\r\n    var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;\r\n    sprite.scale.x = descriptor.width / descriptor.originalWidth * attachment.scaleX;\r\n    sprite.scale.y = descriptor.height / descriptor.originalHeight * attachment.scaleY;\r\n    sprite.rotation = baseRotation - (attachment.rotation * spine.degRad);\r\n    sprite.anchor.x = sprite.anchor.y = 0.5;\r\n    sprite.alpha = attachment.a;\r\n\r\n    slot.sprites = slot.sprites || {};\r\n    slot.sprites[descriptor.name] = sprite;\r\n    return sprite;\r\n};\r\n\r\n/**\r\n * Creates a Strip from the spine data\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createMesh = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var baseTexture = descriptor.page.rendererObject;\r\n    var texture = new PIXI.Texture(baseTexture);\r\n\r\n    var strip = new PIXI.mesh.Mesh(\r\n        texture,\r\n        new Float32Array(attachment.uvs.length),\r\n        new Float32Array(attachment.uvs),\r\n        new Uint16Array(attachment.triangles),\r\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\r\n\r\n    strip.canvasPadding = 1.5;\r\n\r\n    strip.alpha = attachment.a;\r\n\r\n    slot.meshes = slot.meshes || {};\r\n    slot.meshes[attachment.name] = strip;\r\n\r\n    return strip;\r\n};\r\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\n    async = PIXI.utils.async,\n    spine = require('../SpineRuntime');\n\nvar atlasParser = module.exports = function () {\n    return function (resource, next) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\n            // create a spine atlas using the loaded text\n            var spineAtlas = new spine.Atlas(this.xhr.responseText, baseUrl, res.crossOrigin);\n\n            // spine animation\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = spineAtlas;\n            if (atlasParser.enableCaching)\n                atlasParser.AnimCache[resource.name] = resource.spineData;\n\n            // Go through each spineAtlas.pages and wait for page.rendererObject (a baseTexture) to\n            // load. Once all loaded, then call the next function.\n            async.each(spineAtlas.pages, function (page, done) {\n                if (page.rendererObject.hasLoaded) {\n                    done();\n                }\n                else {\n                    page.rendererObject.once('loaded', done);\n                }\n            }, next);\n        });\n    };\n};\n\natlasParser.AnimCache = {};\natlasParser.enableCaching = true;\n","module.exports = {\n    atlasParser: require('./atlasParser'),\n    Loader: require('./Loader')\n};\n"],"sourceRoot":"./"}