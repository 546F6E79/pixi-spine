{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/Spine.ts","src/core/Animation.ts","src/core/AnimationState.ts","src/core/AnimationStateData.ts","src/core/BlendMode.ts","src/core/Bone.ts","src/core/BoneData.ts","src/core/Event.ts","src/core/EventData.ts","src/core/IkConstraint.ts","src/core/IkConstraintData.ts","src/core/PathConstraint.ts","src/core/PathConstraintData.ts","src/core/Skeleton.ts","src/core/SkeletonBounds.ts","src/core/SkeletonData.ts","src/core/SkeletonJson.ts","src/core/Skin.ts","src/core/Slot.ts","src/core/SlotData.ts","src/core/Texture.ts","src/core/TextureAtlas.ts","src/core/TextureAtlasAttachmentLoader.ts","src/core/TransformConstraint.ts","src/core/TransformConstraintData.ts","src/core/Utils.ts","src/core/attachments/Attachment.ts","src/core/attachments/AttachmentType.ts","src/core/attachments/BoundingBoxAttachment.ts","src/core/attachments/MeshAttachment.ts","src/core/attachments/PathAttachment.ts","src/core/attachments/RegionAttachment.ts","src/core/attachments/index.ts","src/core/index.ts","src/loaders.ts","src/index.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","PIXI","spine","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","SlotContainerUpdateTransformV3","pt","parent","worldTransform","wt","lt","localTransform","b","c","d","tx","ty","worldAlpha","alpha","_currentBounds","TransformBase","Bone","yDown","tempRgb","SpineSprite","_super","tex","__extends","Sprite","SpineMesh","texture","vertices","uvs","indices","drawMode","mesh","Mesh","Spine","spineData","hackTextureBySlotName","slotName","size","index","skeleton","findSlotIndex","hackTextureBySlotIndex","Skeleton","updateWorldTransform","stateData","AnimationStateData","state","AnimationState","slotContainers","slots","slot","attachment","slotContainer","Container","push","addChild","RegionAttachment","spriteName","region","name","sprite","createSprite","currentSprite","currentSpriteName","MeshAttachment","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","Float32Array","Object","defineProperty","prototype","updateTransform","autoUpdateTransform","value","utils","rgb2hex","hex2rgb","update","dt","apply","drawOrder","children","data","r0","g0","b0","attColor","color","ar","visible","sprites","undefined","transform","lt_1","matrix2d","_dirtyVersion","version","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","bone","matrix","copy","x","y","Matrix","displayObjectUpdateTransform","tint","blendMode","meshName","meshes","computeWorldVertices","VERSION","setSpriteRegion","scale","width","originalWidth","height","originalHeight","scaleX","scaleY","setMeshRegion","updateUVs","dirty","globalAutoUpdate","lastTime","Date","now","timeDelta","tempAttachment","tempRegion","rotation","MathUtils","degRad","anchor","strip","regionUVs","Uint16Array","triangles","DRAW_MODES","TRIANGLES","canvasPadding","slotIndex","TextureRegion","Utils_1","attachments_1","Animation","timelines","duration","time","loop","events","mix","binarySearch","values","target","step","low","high","current","linearSearch","last","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","type","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","getCurvePercent","percent","clamp","start","prevX","prevY","RotateTimeline","frames","setFrame","degrees","ROTATION","bones","boneIndex","ENTRIES","amount_1","PREV_ROTATION","frame","prevRotation","frameTime","PREV_TIME","amount","TranslateTimeline","X","Y","PREV_X","PREV_Y","ScaleTimeline","ShearTimeline","shearX","shearY","ColorTimeline","R","G","B","A","PREV_R","PREV_G","PREV_B","PREV_A","add","set","AttachmentTimeline","attachmentNames","Array","attachmentName","setAttachment","getAttachment","EventTimeline","event","firedEvents","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","arrayCopy","DeformTimeline","frameVertices","slotAttachment","VertexAttachment","applyDeform","vertexCount","verticesArray","attachmentVertices","setArraySize","lastVertices","prevVertices","nextVertices","prev","IkConstraintTimeline","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","ikConstraintIndex","PREV_MIX","Math","floor","PREV_BEND_DIRECTION","TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","transformConstraintIndex","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","rotate","translate","shear","PathConstraintPositionTimeline","VALUE","pathConstraints","pathConstraintIndex","PREV_VALUE","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","tracks","listeners","timeScale","delta","next","nextTime","delay","nextDelta","setCurrent","endTime","clearTrack","previous","previousDelta","mixTime","listenerCount","animation","previousTime","mixDuration","ii","nn","event_1","listener","iii","count","toInt","complete","clearTracks","trackIndex","end","freeAll","entry","expandToIndex","getMix","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","TrackEntry","addAnimation","addAnimationWith","hasAnimationByName","getCurrent","addListener","removeListener","indexOf","splice","clearListeners","reset","isComplete","AnimationStateAdapter","loopCount","animationToMixTime","defaultMix","setMix","fromName","toName","from","to","setMixWith","key","BlendMode","appliedRotation","worldSignX","worldSignY","sorted","setToSetupPose","updateWorldTransformWith","rotationY","la","cosDeg","lb","lc","sinDeg","ld","m","flipX","flipY","signum","pa","pb","pc","pd","inheritRotation","inheritScale","cos","sin","temp","psx","psy","za","zb","zc","zd","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldToLocalRotationX","pm","worldToLocalRotationY","rotateWorld","updateLocalTransform","det","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","worldToLocal","world","invDet","localToWorld","local","BoneData","Event","EventData","IkConstraint","level","findBone","apply1","worldX","worldY","apply2","targetX","targetY","pp","rotationIK","child","bendDir","px","py","csx","os1","os2","s2","cx","cy","cwx","cwy","abs","ppm","l1","l2","a1","a2","outer","acos","aa","bb","dd","ta","c1","c2","q","r1","minAngle","minDist","minX","minY","maxAngle","maxDist","maxX","maxY","PI","angle","os","IkConstraintData","PathConstraintData_1","PathConstraint","spaces","positions","lengths","segments","findSlot","PathAttachment","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","length_1","max","computeWorldPositions","positionMode","PositionMode","Percent","skeletonX","skeletonY","boneX","boneY","offsetRotation","tip","Chain","p","length_2","length_3","PI2","path","percentPosition","percentSpacing","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","pathLength_1","curve","space","BEFORE","computeWorldVerticesWith","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","x1","y1","x2","y2","w","curveLength","segment","length_5","length_6","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Slot_1","Bone_1","IkConstraint_1","TransformConstraint_1","PathConstraint_1","_updateCache","boneData","parent_1","slotData","Slot","ikConstraintsSorted","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","Color","updateCache","ikCount","ik","other","sortBone","constrained","parent_2","sortReset","slotBone","skin","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","attachments","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBounds","offset","POSITIVE_INFINITY","NEGATIVE_INFINITY","updateWorldVertices","min","SkeletonBounds","boundingBoxes","polygons","polygonPool","Pool","updateAabb","slotCount","BoundingBoxAttachment","boundingBox","polygon","obtain","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonData","animations","findEvent","eventDataName","findPathConstraintIndex","pathConstraintName","SkeletonData_1","BoneData_1","SlotData_1","Event_1","IkConstraintData_1","TransformConstraintData_1","Skin_1","EventData_1","Animation_1","SkeletonJson","attachmentLoader","linkedMeshes","readSkeletonData","json","root","JSON","parse","skeletonMap","hash","imagesPath","images","boneMap","parentName","getValue","slotMap","SlotData","setFromString","blendModeFromString","constraintMap","j","targetName","TransformConstraintData","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","setParentMesh","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","newRegionAttachment","box","newBoundingBoxAttachment","readVertices","newMeshAttachment","parent_3","inheritDeform","LinkedMesh","hullLength","newPathAttachment","newArray","toFloatArray","weights","timelineName","timelineMap","timeline","valueMap","readCurve","timelineScale","paths","deform","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","isNaN","toString","prop","defaultValue","str","BLEND_MODES","MULTIPLY","ADD","SCREEN","NORMAL","toLowerCase","dictionary","oldSkin","skinAttachment","attachmentTime","setAttachmentTime","getAttachmentTime","setFromColor","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","crop","trim","orig","_uvs","x0","y0","console","warn","spineOffsetY","Texture_1","TextureAtlas","atlasText","textureLoader","callback","pages","regions","addSpineAtlas","load","_this","reader","TextureAtlasReader","tuple","page","iterateParser","line","readLine","TextureAtlasPage","readTuple","parseInt","minFilter","magFilter","direction","readValue","uWrap","vWrap","baseTexture","hasLoaded","setFilters","realWidth","realHeight","log","TextureAtlasRegion","resolution","Rectangle","frame2","clone","_updateUvs","findRegion","dispose","lines","split","colon","substring","lastMatch","comma","substr","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","arguments","TextureAtlasAttachmentLoader","atlas","Vector2","tm","tb","tc","td","bs","ts","by","hex","charAt","WHITE","RED","GREEN","BLUE","MAGENTA","ceil","cbrt","pow","radiansToDegrees","degreesToRadians","source","sourceStart","dest","destStart","numElements","array","oldSize","SUPPORTS_TYPED_ARRAYS","DebugUtils","logBones","instantiator","items","pop","free","item","clear","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Attachment","worldVertices","deformArray","v","skip","skeletonBones","wx","wy","vx","vy","weight","v_1","sourceAttachment","AttachmentType","Attachment_1","tempColor","premultipliedAlpha","w1","h1","w2","h2","pixiOffsetY","parentMesh","getParentMesh","AttachmentType_1","BoundingBoxAttachment_1","MeshAttachment_1","PathAttachment_1","RegionAttachment_1","__export","AnimationState_1","AnimationStateData_1","BlendMode_1","Skeleton_1","SkeletonBounds_1","SkeletonJson_1","TextureAtlas_1","TextureAtlasAttachmentLoader_1","atlasParser","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","lastIndexOf","replace","baseUrl","atlasOptions","crossOrigin","xhrType","loaders","Resource","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","imageLoaderAdapter","xhr","responseText","loader","namePrefix","syncImageLoaderAdapter","BaseTexture","fromImage","Loader","addPixiMiddleware","use","core","Spine_1"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import * as spine from \"./core\";\nimport {atlasParser} from \"./loaders\";\nimport {Attachment, VertexAttachment} from \"./core/attachments/Attachment\";\nimport {TextureAtlasRegion} from \"./core/TextureAtlas\";\nvar TransformBase = PIXI.TransformBase;\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\nlet tempRgb = [0, 0, 0];\n\nexport class SpineSprite extends PIXI.Sprite {\n    region: spine.TextureRegion;\n\n    constructor(tex: PIXI.Texture) {\n        super(tex);\n    }\n}\n\nexport class SpineMesh extends PIXI.mesh.Mesh {\n    region: spine.TextureRegion;\n\n    constructor(texture: PIXI.Texture, vertices?: ArrayLike<number>, uvs?: ArrayLike<number>, indices?: ArrayLike<number>, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport class Spine extends PIXI.Container {\n    static globalAutoUpdate: boolean = true;\n\n    tintRgb: ArrayLike<number>;\n    spineData: spine.SkeletonData;\n    skeleton: spine.Skeleton;\n    stateData: spine.AnimationStateData;\n    state: spine.AnimationState;\n    slotContainers: Array<PIXI.Container>;\n\n    constructor(spineData: spine.SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if ((typeof spineData) === \"string\") {\n            throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.skeleton = new spine.Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n\n        /**\n         * A spine AnimationStateData object created from the spine data passed in the constructor\n         *\n         * @member {object}\n         */\n        this.stateData = new spine.AnimationStateData(spineData);\n\n        /**\n         * A spine AnimationState object created from the spine AnimationStateData object\n         *\n         * @member {object}\n         */\n        this.state = new spine.AnimationState(this.stateData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            var slot = this.skeleton.slots[i];\n            var attachment : any = slot.attachment;\n            var slotContainer = new PIXI.Container();\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n\n            if (attachment instanceof spine.RegionAttachment) {\n                var spriteName = attachment.region.name;\n                var sprite = this.createSprite(slot, attachment);\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                var mesh = this.createMesh(slot, attachment);\n                slot.currentMesh = mesh;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            }\n            else {\n                continue;\n            }\n\n        }\n\n        /**\n         * Should the Spine object update its transforms\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof PIXI.spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof PIXI.spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n    }\n\n    set autoUpdate(value: boolean) {\n        this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return PIXI.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n        this.skeleton.updateWorldTransform();\n\n        let drawOrder = this.skeleton.drawOrder;\n        let slots = this.skeleton.slots;\n\n        for (var i = 0, n = drawOrder.length; i < n; i++) {\n            this.children[i] = this.slotContainers[drawOrder[i].data.index];\n        }\n\n        var r0 = this.tintRgb[0];\n        var g0 = this.tintRgb[1];\n        var b0 = this.tintRgb[2];\n\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slot = slots[i];\n            var attachment = slot.attachment;\n            var slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            var attColor = (attachment as any).color;\n            if (attachment instanceof spine.RegionAttachment) {\n                let region = (attachment as spine.RegionAttachment).region;\n                if (region) {\n                    let ar = region as TextureAtlasRegion;\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                        var spriteName = ar.name;\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        }\n                        else {\n                            var sprite = this.createSprite(slot, attachment);\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n                    }\n                }\n\n                if (slotContainer.transform) {\n                    var transform = slotContainer.transform;\n                    let lt : PIXI.Matrix;\n                    if (slotContainer.transform.matrix2d) {\n                        //gameofbombs pixi fork\n                        lt = transform.matrix2d;\n                        transform._dirtyVersion++;\n                        transform.version = transform._dirtyVersion;\n                        transform.isStatic = true;\n                        transform.operMode = 0;\n                    } else {\n                        if (TransformBase) {\n                            //PIXI v4.0\n                            if (transform.position) {\n                                transform = new PIXI.TransformBase();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                        } else {\n                            //PIXI v4.0rc\n                            if (!transform._dirtyLocal) {\n                                transform = new PIXI.TransformStatic();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                            transform._dirtyParentVersion = -1;\n                            transform._dirtyLocal = 1;\n                            transform._versionLocal = 1;\n                        }\n                    }\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                } else {\n                    //PIXI v3\n                    var lt = slotContainer.localTransform || new PIXI.Matrix();\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                    slotContainer.localTransform = lt;\n                    slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                }\n                tempRgb[0] = r0 * slot.color.r * attColor.r;\n                tempRgb[1] = g0 * slot.color.g * attColor.g;\n                tempRgb[2] = b0 * slot.color.b * attColor.b;\n                slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                slot.currentSprite.blendMode = slot.blendMode;\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                    var meshName = attachment.name;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                    }\n\n                    slot.meshes = slot.meshes || {};\n\n                    if (slot.meshes[meshName] !== undefined) {\n                        slot.meshes[meshName].visible = true;\n                    }\n                    else {\n                        var mesh = this.createMesh(slot, attachment);\n                        slotContainer.addChild(mesh);\n                    }\n\n                    slot.currentMesh = slot.meshes[meshName];\n                    slot.currentMeshName = meshName;\n                }\n                (attachment as VertexAttachment).computeWorldVertices(slot, slot.currentMesh.vertices);\n                if (PIXI.VERSION[0] !== '3') {\n                    // PIXI version 4\n                    // slot.currentMesh.dirty++;\n                    //only for PIXI v4\n                    var tintRgb = slot.currentMesh.tintRgb;\n                    tintRgb[0] = r0 * slot.color.r * attColor.r;\n                    tintRgb[1] = g0 * slot.color.g * attColor.g;\n                    tintRgb[2] = b0 * slot.color.b * attColor.b;\n                }\n                slot.currentMesh.blendMode = slot.blendMode;\n            }\n            else {\n                slotContainer.visible = false;\n                continue;\n            }\n            slotContainer.visible = true;\n\n            slotContainer.alpha = slot.color.a;\n        }\n    };\n\n    private setSpriteRegion(attachment: spine.RegionAttachment, sprite: SpineSprite, region: spine.TextureRegion) {\n        sprite.region = region;\n        sprite.texture = region.texture;\n        if (!region.size) {\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n        } else {\n            //hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: spine.MeshAttachment, mesh: SpineMesh, region: spine.TextureRegion) {\n        mesh.region = region;\n        mesh.texture = region.texture;\n        attachment.updateUVs(region, mesh.uvs);\n        // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n        // } else {\n            // PIXI version 3\n        mesh.dirty++;\n        // }\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (Spine.globalAutoUpdate) {\n            this.lastTime = this.lastTime || Date.now();\n            var timeDelta = (Date.now() - this.lastTime) * 0.001;\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        PIXI.Container.prototype.updateTransform.call(this);\n    };\n\n    /**\n     * Create a new sprite to be used with spine.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: spine.Slot, attachment: spine.RegionAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        var texture = region.texture;\n        var sprite = new SpineSprite(texture);\n        sprite.rotation = attachment.rotation * spine.MathUtils.degRad;\n        sprite.anchor.x = 0.5;\n        sprite.anchor.y = 0.5;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        sprite.region = attachment.region;\n        this.setSpriteRegion(attachment, sprite, attachment.region);\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[attachment.name] = sprite;\n        return sprite;\n    };\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: spine.Slot, attachment: spine.MeshAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        let strip = new SpineMesh(\n            region.texture,\n            new Float32Array(attachment.regionUVs.length),\n            new Float32Array(attachment.regionUVs.length),\n            new Uint16Array(attachment.triangles),\n            PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n        strip.canvasPadding = 1.5;\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        this.setMeshRegion(attachment, strip, region);\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.name] = strip;\n        return strip;\n    };\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var slot = this.skeleton.slots[slotIndex];\n        if (!slot) {\n            return false;\n        }\n        var attachment: any = slot.attachment;\n        var region: spine.TextureRegion = attachment.region;\n        if (texture) {\n            region = new spine.TextureRegion();\n            region.texture = texture;\n            region.size = size;\n        }\n        if (slot.currentSprite && slot.currentSprite.region != region) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n            slot.currentSprite.region = region;\n        } else\n        if (slot.currentMesh && slot.currentMesh.region != region) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        } else {\n            slot.tempRegion = region;\n            slot.tempAttachment = attachment;\n        }\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName = function (slotName: String, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var index = this.skeleton.findSlotIndex(slotName);\n        if (index == -1) {\n            return false;\n        }\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n}\n\nfunction SlotContainerUpdateTransformV3() {\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n}\n","import {Event} from \"./Event\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Utils, MathUtils, Color} from \"./Utils\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {VertexAttachment, Attachment} from \"./attachments\";\nimport {Slot} from \"./Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Animation {\n    name: string;\n    timelines: Array<Timeline>;\n    duration: number;\n\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n    }\n\n    mix (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n    }\n\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n        if (high == 0) return step;\n        let current = high >>> 1;\n        while (true) {\n            if (values[(current + 1) * step] <= target)\n                low = current + 1;\n            else\n                high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step)\n            if (values[i] > target) return i;\n        return -1;\n    }\n}\n\nexport interface Timeline {\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    constructor (frameCount: number) {\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    getFrameCount () {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    setLinear (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    setStepped (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    getCurveType (frameIndex: number): number {\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        let type = this.curves[index];\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let curves = this.curves;\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx, y = dfy;\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    getCurvePercent (frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        let curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let type = curves[i];\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number, prevY: number;\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        let y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n            let amount = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent((frame >> 1) - 1,\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let amount = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (prevRotation + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n}\n\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n    static X = 1; static Y = 2;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length + TranslateTimeline.PREV_X] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length + TranslateTimeline.PREV_Y] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n        let prevX = frames[frame + TranslateTimeline.PREV_X];\n        let prevY = frames[frame + TranslateTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n        bone.x += (bone.data.x + prevX + (frames[frame + TranslateTimeline.X] - prevX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevY + (frames[frame + TranslateTimeline.Y] - prevY) * percent - bone.y) * alpha;\n    }\n}\n\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length + ScaleTimeline.PREV_X] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length + ScaleTimeline.PREV_Y] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n        let prevX = frames[frame + ScaleTimeline.PREV_X];\n        let prevY = frames[frame + ScaleTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n        bone.scaleX += (bone.data.scaleX * (prevX + (frames[frame + ScaleTimeline.X] - prevX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevY + (frames[frame + ScaleTimeline.Y] - prevY) * percent) - bone.scaleY) * alpha;\n    }\n}\n\nexport class ShearTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n            bone.shearX += (bone.data.shearX + frames[frames.length + ShearTimeline.PREV_X] - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY + frames[frames.length + ShearTimeline.PREV_Y] - bone.shearY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n        let prevX = frames[frame + ShearTimeline.PREV_X];\n        let prevY = frames[frame + ShearTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n        bone.shearX += (bone.data.shearX + (prevX + (frames[frame + ShearTimeline.X] - prevX) * percent) - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + (prevY + (frames[frame + ShearTimeline.Y] - prevY) * percent) - bone.shearY) * alpha;\n    }\n}\n\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n    static R = 1; static G = 2; static B = 3; static A = 4;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let r = 0, g = 0, b = 0, a = 0;\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        let color: Color = skeleton.slots[this.slotIndex].color;\n        if (alpha < 1)\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        else\n            color.set(r, g, b, a);\n    }\n}\n\nexport class AttachmentTimeline implements Timeline {\n    slotIndex: number;\n    frames: ArrayLike<number> // time, ...\n    attachmentNames: Array<string>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameIndex = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        let attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex]\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nexport class EventTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    events: Array<Event>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > lastTime and <= time. */\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        if (firedEvents == null) return;\n        let frames = this.frames;\n        let frameCount = this.frames.length;\n\n        if (lastTime > time) { // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (lastTime < frames[0])\n            frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            let frameTime = frames[frame];\n            while (frame > 0) { // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++)\n            firedEvents.push(this.events[frame]);\n    }\n}\n\nexport class DrawOrderTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    drawOrders: Array<Array<number>>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe.\n     * @param drawOrder May be null to use bind pose draw order. */\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frame = frames.length - 1;\n        else\n            frame = Animation.binarySearch(frames, time) - 1;\n\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\n        let slots: Array<Slot> = skeleton.slots;\n        let drawOrderToSetupIndex = this.drawOrders[frame];\n        if (drawOrderToSetupIndex == null)\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\nexport class DeformTimeline extends CurveTimeline {\n    frames: ArrayLike<number>; // time, ...\n    frameVertices: Array<ArrayLike<number>>;\n    slotIndex: number;\n    attachment: VertexAttachment;\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let slot: Slot = skeleton.slots[this.slotIndex];\n        let slotAttachment: Attachment = slot.getAttachment();\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameVertices = this.frameVertices;\n        let vertexCount = frameVertices[0].length;\n\n        let verticesArray: Array<number> = slot.attachmentVertices;\n        if (verticesArray.length != vertexCount) alpha = 1; // Don't mix from uninitialized slot vertices.\n        let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\n            let lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1) {\n                for (let i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else\n                Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time);\n        let prevVertices = frameVertices[frame - 1];\n        let nextVertices = frameVertices[frame];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha < 1) {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n}\n\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\n    static MIX = 1; static BEND_DIRECTION = 2;\n\n    ikConstraintIndex: number;\n    frames: ArrayLike<number>; // time, mix, bendDirection, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time, mix and bend direction of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n            constraint.bendDirection = Math.floor(frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n    }\n}\n\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n    transformConstraintIndex: number;\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + TransformConstraintTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + TransformConstraintTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i + TransformConstraintTimeline.PREV_SCALE] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i + TransformConstraintTimeline.PREV_SHEAR] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n        let rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n        let translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n        let scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n        let shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n        constraint.rotateMix += (rotate + (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent - constraint.shearMix) * alpha;\n    }\n}\n\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.position += (frames[i + PathConstraintPositionTimeline.PREV_VALUE] - constraint.position) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n        let position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n        constraint.position += (position + (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent - constraint.position) * alpha;\n    }\n}\n\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.spacing += (frames[i + PathConstraintSpacingTimeline.PREV_VALUE] - constraint.spacing) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n        let spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n        constraint.spacing += (spacing + (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent - constraint.spacing) * alpha;\n    }\n}\n\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n    static ROTATE = 1; static TRANSLATE = 2;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + PathConstraintMixTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + PathConstraintMixTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n        let rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n        let translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n        constraint.rotateMix += (rotate + (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\nimport {MathUtils, Utils} from \"./Utils\";\nimport {Animation} from \"./Animation\";\nimport {AnimationStateData} from \"./AnimationStateData\";\nimport {Event} from \"./Event\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationState {\n    data: AnimationStateData;\n    tracks = new Array<TrackEntry>();\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    timeScale = 1;\n\n    constructor (data: AnimationStateData = null) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n    }\n\n    update (delta: number) {\n        delta *= this.timeScale;\n        for (let i = 0; i < this.tracks.length; i++) {\n            let current = this.tracks[i];\n            if (current == null) continue;\n\n            let next = current.next;\n            if (next != null) {\n                let nextTime = current.lastTime - next.delay;\n                if (nextTime >= 0) {\n                    let nextDelta = delta * next.timeScale;\n                    next.time = nextTime + nextDelta; // For start event to see correct time.\n                    current.time += delta * current.timeScale; // For end event to see correct time.\n                    this.setCurrent(i, next);\n                    next.time -= nextDelta; // Prevent increasing time twice, below.\n                    current = next;\n                }\n            } else if (!current.loop && current.lastTime >= current.endTime) {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                this.clearTrack(i);\n                continue;\n            }\n\n            current.time += delta * current.timeScale;\n            if (current.previous != null) {\n                let previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n        }\n    }\n\n    apply (skeleton: Skeleton) {\n        let events = this.events;\n        let listenerCount = this.listeners.length;\n\n        for (let i = 0; i < this.tracks.length; i++) {\n            let current = this.tracks[i];\n            if (current == null) continue;\n\n            events.length = 0;\n\n            let time = current.time;\n            let lastTime = current.lastTime;\n            let endTime = current.endTime;\n            let loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            let previous = current.previous;\n            if (previous == null)\n                current.animation.mix(skeleton, lastTime, time, loop, events, current.mix);\n            else {\n                let previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                let alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1) {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, lastTime, time, loop, events, alpha);\n            }\n\n            for (let ii = 0, nn = events.length; ii < nn; ii++) {\n                let event = events[ii];\n                if (current.listener != null) current.listener.event(i, event);\n                for (let iii = 0; iii < listenerCount; iii++)\n                    this.listeners[iii].event(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {\n                let count = MathUtils.toInt(time / endTime);\n                if (current.listener != null) current.listener.complete(i, count);\n                for (let ii = 0, nn = this.listeners.length; ii < nn; ii++)\n                    this.listeners[ii].complete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    }\n\n    clearTracks () {\n        for (let i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    }\n\n    clearTrack (trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        let current = this.tracks[trackIndex];\n        if (current == null) return;\n\n        if (current.listener != null) current.listener.end(trackIndex);\n        for (let i = 0, n = this.listeners.length; i < n; i++)\n            this.listeners[i].end(trackIndex);\n\n        this.tracks[trackIndex] = null;\n\n        this.freeAll(current);\n    }\n\n    freeAll (entry: TrackEntry) {\n        while (entry != null) {\n            let next = entry.next;\n            entry = next;\n        }\n    }\n\n    expandToIndex (index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.setArraySize(this.tracks, index - this.tracks.length + 1, null);\n        this.tracks.length = index + 1;\n        return null;\n    }\n\n    setCurrent (index: number, entry: TrackEntry) {\n        let current = this.expandToIndex(index);\n        if (current != null) {\n            let previous = current.previous;\n            current.previous = null;\n\n            if (current.listener != null) current.listener.end(index);\n            for (let i = 0, n = this.listeners.length; i < n; i++)\n                this.listeners[i].end(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0) {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous != null && current.mixTime / current.mixDuration < 0.5) {\n                    entry.previous = previous;\n                    previous = current;\n                } else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.listener != null) entry.listener.start(index);\n        for (let i = 0, n = this.listeners.length; i < n; i++)\n            this.listeners[i].start(index);\n    }\n\n    /** @see #setAnimation(int, Animation, boolean) */\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\n        let current = this.expandToIndex(trackIndex);\n        if (current != null) this.freeAll(current.next);\n\n        let entry = new TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    }\n\n    /** {@link #addAnimation(int, Animation, boolean, float)} */\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    hasAnimationByName(animationName: string): boolean\n    {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n    }\n\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        let entry = new TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        let last = this.expandToIndex(trackIndex);\n        if (last != null) {\n            while (last.next != null)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0) {\n            if (last != null)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** @return May be null. */\n    getCurrent (trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all animations. */\n    addListener (listener: AnimationStateListener) {\n        if (listener == null) throw new Error(\"listener cannot be null.\");\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n    removeListener (listener: AnimationStateListener) {\n        let index = this.listeners.indexOf(listener);\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    clearListeners () {\n        this.listeners.length = 0;\n    }\n}\n\nexport class TrackEntry {\n    next: TrackEntry; previous: TrackEntry;\n    animation: Animation;\n    loop = false;\n    delay = 0; time = 0; lastTime = -1; endTime = 0; timeScale = 1;\n    mixTime = 0; mixDuration = 0;\n    listener: AnimationStateListener;\n    mix = 1;\n\n    reset () {\n        this.next = null;\n        this.previous = null;\n        this.animation = null;\n        this.listener = null;\n        this.timeScale = 1;\n        this.lastTime = -1; // Trigger events on frame zero.\n        this.time = 0;\n    }\n\n    /** Returns true if the current time is greater than the end time, regardless of looping. */\n    isComplete () : boolean {\n        return this.time >= this.endTime;\n    }\n}\n\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    event (trackIndex: number, event: Event) {\n    }\n\n    complete (trackIndex: number, loopCount: number) {\n    }\n\n    start (trackIndex: number) {\n    }\n\n    end (trackIndex: number) {\n    }\n}\n\nexport interface AnimationStateListener {\n    /** Invoked when the current animation triggers an event. */\n    event (trackIndex: number, event: Event): void;\n\n    /** Invoked when the current animation has completed.\n     * @param loopCount The number of times the animation reached the end. */\n    complete (trackIndex: number, loopCount: number): void;\n\n    /** Invoked just after the current animation is set. */\n    start (trackIndex: number): void;\n\n    /** Invoked just before the current animation is replaced. */\n    end (trackIndex: number): void;\n}\n","import {Animation} from \"./Animation\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationStateData {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = { };\n    defaultMix = 0;\n\n    constructor (skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n        this.skeletonData = skeletonData;\n    }\n\n    setMix (fromName: string, toName: string, duration: number) {\n        let from = this.skeletonData.findAnimation(fromName);\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\n        let to = this.skeletonData.findAnimation(toName);\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\n        this.setMixWith(from, to, duration);\n    }\n\n    setMixWith (from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error(\"from cannot be null.\");\n        if (to == null) throw new Error(\"to cannot be null.\");\n        let key = from.name + to.name;\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix (from: Animation, to: Animation) {\n        let key = from.name + to.name;\n        let value = this.animationToMixTime[key];\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport enum BlendMode {\n    Normal,\n    Additive,\n    Multiply,\n    Screen\n}\n","import {Updatable} from \"./Updatable\";\nimport {BoneData} from \"./BoneData\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils, Vector2} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Bone implements Updatable {\n    static yDown: boolean = false;\n    //be careful! Spine b,c is c,b in pixi matrix\n    matrix = new PIXI.Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0; y = 0; rotation = 0; scaleX = 0; scaleY = 0; shearX = 0; shearY = 0;\n    appliedRotation = 0;\n\n    worldSignX = 0; worldSignY = 0;\n\n    sorted = false;\n\n    /** @param parent May be null. */\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.appliedRotation = rotation;\n\n        let rotationY = rotation + 90 + shearY;\n        let la = MathUtils.cosDeg(rotation + shearX) * scaleX, lb = MathUtils.cosDeg(rotationY) * scaleY;\n        let lc = MathUtils.sinDeg(rotation + shearX) * scaleX, ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) { // Root bone.\n            let skeleton = this.skeleton;\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = MathUtils.signum(scaleX);\n            this.worldSignY = MathUtils.signum(scaleY);\n            return;\n        }\n\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * MathUtils.signum(scaleX);\n        this.worldSignY = parent.worldSignY * MathUtils.signum(scaleY);\n\n        if (this.data.inheritRotation && this.data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (this.data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\n                    let temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (this.data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\n                    let psx = parent.scaleX, psy = parent.scaleY;\n                    let za = cos * psx, zb = sin * psy, zc = sin * psx, zd = cos * psy;\n                    let temp = pa * za + pb * zc;\n                    pb = pb * zd - pa * zb;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pd * zd - pc * zb;\n                    pc = temp;\n\n                    if (psx >= 0) sin = -sin;\n                    temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (this.skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (this.skeleton.flipY !== Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    }\n\n    setToSetupPose () {\n        let data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX () {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY () {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX () {\n        return Math.sqrt(this.matrix.a * this.matrix.a + this.matrix.b * this.matrix.b) * this.worldSignX;\n    }\n\n    getWorldScaleY () {\n        return Math.sqrt(this.matrix.c * this.matrix.c + this.matrix.d * this.matrix.d) * this.worldSignY;\n    }\n\n    worldToLocalRotationX () {\n        let parent = this.parent;\n        if (parent == null) return this.rotation;\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d, a = this.matrix.a, c = this.matrix.b;\n        return Math.atan2(pa * c - pc * a, pd * a - pb * c) * MathUtils.radDeg;\n    }\n\n    worldToLocalRotationY () {\n        let parent = this.parent;\n        if (parent == null) return this.rotation;\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.b, pc = pm.c, pd = pm.d, b = this.matrix.c, d = this.matrix.d;\n        return Math.atan2(pa * d - pc * b, pd * b - pb * d) * MathUtils.radDeg;\n    }\n\n    rotateWorld (degrees: number) {\n        let m = this.matrix;\n        let a = this.matrix.a, b = m.c, c = m.b, d = m.d;\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n        m.a = cos * a - sin * c;\n        m.c = cos * b - sin * d;\n        m.b = sin * a + cos * c;\n        m.d = sin * b + cos * d;\n    }\n\n    /** Computes the local transform from the world transform. This can be useful to perform processing on the local transform\n     * after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some redundant information is lost by the world transform, such as -1,-1 scale versus 180 rotation. The computed local\n     * transform values may differ from the original values but are functionally the same. */\n    updateLocalTransform () {\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) {\n            this.x = m.tx;\n            this.y = m.ty;\n            this.rotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.scaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.scaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            let det = m.a * m.d - m.b * m.c;\n            this.shearX = 0;\n            this.shearY = Math.atan2(m.a * m.c + m.b * m.d, det) * MathUtils.radDeg;\n            return;\n        }\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d;\n        let pid = 1 / (pa * pd - pb * pc);\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n        this.x = (dx * pd * pid - dy * pb * pid);\n        this.y = (dy * pa * pid - dx * pc * pid);\n        let ia = pid * pd;\n        let id = pid * pa;\n        let ib = pid * pb;\n        let ic = pid * pc;\n        let ra = ia * m.a - ib * m.b;\n        let rb = ia * m.c - ib * m.d;\n        let rc = id * m.b - ic * m.a;\n        let rd = id * m.d - ic * m.c;\n        this.shearX = 0;\n        this.scaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.scaleX > 0.0001) {\n            let det = ra * rd - rb * rc;\n            this.scaleY = det / this.scaleX;\n            this.shearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.rotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.scaleX = 0;\n            this.scaleY = Math.sqrt(rb * rb + rd * rd);\n            this.shearY = 0;\n            this.rotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n        this.appliedRotation = this.rotation;\n    }\n\n    worldToLocal (world: Vector2) {\n        let m = this.matrix;\n        let a = m.a, b = m.c, c = m.b, d = m.d;\n        let invDet = 1 / (a * d - b * c);\n        let x = world.x - m.tx, y = world.y - m.ty;\n        world.x = (x * d * invDet - y * b * invDet);\n        world.y = (y * a * invDet - x * c * invDet);\n        return world;\n    }\n\n    localToWorld (local: Vector2) {\n        let m = this.matrix;\n        let x = local.x, y = local.y;\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n        return local;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0; y = 0; rotation = 0; scaleX = 1; scaleY = 1; shearX = 0; shearY = 0;\n    inheritRotation = true; inheritScale = true;\n\n    constructor (index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n","import {EventData} from \"./EventData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Event {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n\n    constructor (time: number, data: EventData) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.time = time;\n        this.data = data;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class EventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraint implements Updatable {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    mix = 1;\n    bendDirection = 0;\n\n    level = 0;\n\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let target = this.target;\n        let bones = this.bones;\n        switch (bones.length) {\n        case 1:\n            this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\n        let pp = bone.parent.matrix;\n        let id = 1 / (pp.a * pp.d - pp.b * pp.c);\n        let x = targetX - pp.tx, y = targetY - pp.ty;\n        let tx = (x * pp.d - y * pp.c) * id - bone.x, ty = (y * pp.a - x * pp.b) * id - bone.y;\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.shearX - bone.rotation;\n        if (bone.scaleX < 0) rotationIK += 180;\n        if (rotationIK > 180)\n            rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        bone.updateWorldTransformWith(bone.x, bone.y, bone.rotation + rotationIK * alpha, bone.scaleX, bone.scaleY, bone.shearX,\n            bone.shearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n            return;\n        }\n        let px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX;\n        let os1 = 0, os2 = 0, s2 = 0;\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else\n            os2 = 0;\n        let pm = parent.matrix;\n        let cx = child.x, cy = 0, cwx = 0, cwy = 0, a = pm.a, b = pm.c, c = pm.b, d = pm.d;\n        let u = Math.abs(psx - psy) <= 0.0001;\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pm.tx;\n            cwy = c * cx + pm.ty;\n        } else {\n            cy = child.y;\n            cwx = a * cx + b * cy + pm.tx;\n            cwy = c * cx + d * cy + pm.ty;\n        }\n        let pp = parent.parent;\n        let ppm = parent.parent.matrix;\n        a = ppm.a;\n        b = ppm.c;\n        c = ppm.b;\n        d = ppm.d;\n        let id = 1 / (a * d - b * c), x = targetX - ppm.tx, y = targetY - ppm.ty;\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n        x = cwx - ppm.tx;\n        y = cwy - ppm.ty;\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n        outer:\n        if (u) {\n            l2 *= psx;\n            let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            let c1 = -2 * bb * l1, c2 = bb - aa;\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                let r0 = q / c2, r1 = c / q;\n                let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            let minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;\n            let maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            x = l1 + a;\n            d = x * x;\n            if (d > maxDist) {\n                maxAngle = 0;\n                maxDist = d;\n                maxX = x;\n            }\n            x = l1 - a;\n            d = x * x;\n            if (d < minDist) {\n                minAngle = MathUtils.PI;\n                minDist = d;\n                minX = x;\n            }\n            let angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            y = b * Math.sin(angle);\n            d = x * x + y * y;\n            if (d < minDist) {\n                minAngle = angle;\n                minDist = d;\n                minX = x;\n                minY = y;\n            }\n            if (d > maxDist) {\n                maxAngle = angle;\n                maxDist = d;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        let os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.rotation;\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180)\n            a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.scaleX, parent.scaleY, 0, 0);\n        rotation = child.rotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.shearX) * s2 + os2 - rotation;\n        if (a2 > 180)\n            a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.scaleX, child.scaleY, child.shearX, child.shearY);\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    mix = 1;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Slot} from \"./Slot\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathAttachment} from \"./attachments\";\nimport {Utils, MathUtils} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraint implements Updatable {\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\n\n    spaces = new Array<number>(); positions = new Array<number>();\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n    segments = new Array<number>();\n\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let attachment = this.target.getAttachment();\n        if (!(attachment instanceof PathAttachment)) return;\n\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\n        let translate = translateMix > 0, rotate = rotateMix > 0;\n        if (!translate && !rotate) return;\n\n        let data = this.data;\n        let spacingMode = data.spacingMode;\n        let lengthSpacing = spacingMode == SpacingMode.Length;\n        let rotateMode = data.rotateMode;\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n        let bones = this.bones;\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\n        let spacing = this.spacing;\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n;) {\n                let bone = bones[i];\n                let m = bone.matrix;\n                let length = bone.data.length, x = length * m.a, y = length * m.b;\n                length = Math.sqrt(x * x + y * y);\n                if (scale) lengths[i] = length;\n                spaces[++i] = lengthSpacing ? Math.max(0, length + spacing) : spacing;\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++)\n                spaces[i] = spacing;\n        }\n\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\n        let skeleton = this.target.bone.skeleton;\n        let skeletonX = skeleton.x, skeletonY = skeleton.y;\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n        let tip = rotateMode == RotateMode.Chain && offsetRotation == 0;\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            let bone = bones[i];\n            let m = bone.matrix;\n            m.tx += (boneX - skeletonX - bone.worldX) * translateMix;\n            m.ty += (boneY - skeletonY - bone.worldY) * translateMix;\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n            if (scale) {\n                let length = lengths[i];\n                if (length != 0) {\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n                    m.a *= s;\n                    m.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                let a = m.a, b = m.c, c = m.b, d = m.d, r = 0, cos = 0, sin = 0;\n                if (tangents)\n                    r = positions[p - 1];\n                else if (spaces[i + 1] == 0)\n                    r = positions[p + 2];\n                else\n                    r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a) - offsetRotation * MathUtils.degRad;\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    let length = bone.data.length;\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                }\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n            }\n        }\n    }\n\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\n        percentSpacing: boolean) {\n        let target = this.target;\n        let position = this.position;\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\n        let closed = path.closed;\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            let lengths = path.lengths;\n            curveCount -= closed ? 1 : 2;\n            let pathLength = lengths[curveCount];\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                let space = spaces[i];\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVerticesWith(target, 2, 4, world, 0);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (;; curve++) {\n                    let length = lengths[curve];\n                    if (p > length) continue;\n                    if (curve == 0)\n                        p /= length;\n                    else {\n                        let prev = lengths[curve - 1];\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);\n                        path.computeWorldVerticesWith(target, 0, 4, world, 4);\n                    } else\n                        path.computeWorldVerticesWith(target, curve * 6 + 2, 8, world, 0);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n                    tangents || (i > 0 && space == 0));\n            }\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);\n            path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);\n        }\n\n        // Curve lengths.\n        let curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++)\n                spaces[i] *= pathLength;\n        }\n\n        let segments = this.segments;\n        let curveLength = 0;\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            let space = spaces[i];\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (;; curve++) {\n                let length = curves[curve];\n                if (p > length) continue;\n                if (curve == 0)\n                    p /= length;\n                else {\n                    let prev = curves[curve - 1];\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (;; segment++) {\n                let length = segments[segment];\n                if (p > length) continue;\n                if (segment == 0)\n                    p /= length;\n                else {\n                    let prev = segments[segment - 1];\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n        return out;\n    }\n\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n        out: Array<number>, o: number, tangents: boolean) {\n        if (p == 0) p = 0.0001;\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number; spacing: number; rotateMix: number; translateMix: number;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n\nexport enum PositionMode {\n    Fixed, Percent\n}\n\nexport enum SpacingMode {\n    Length, Fixed, Percent\n}\n\nexport enum RotateMode {\n    Tangent, Chain, ChainScale\n}\n","import {Slot} from \"./Slot\";\nimport {Bone} from \"./Bone\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Color, Utils, Vector2} from \"./Utils\";\nimport {Skin} from \"./Skin\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Updatable} from \"./Updatable\";\nimport {Attachment, PathAttachment, RegionAttachment, MeshAttachment} from \"./attachments\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skeleton {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>; ikConstraintsSorted: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    flipX = false; flipY = false;\n    x = 0; y = 0;\n\n    constructor (data: SkeletonData) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            let boneData = data.bones[i];\n            let bone: Bone;\n            if (boneData.parent == null)\n                bone = new Bone(boneData, this, null);\n            else {\n                let parent = this.bones[boneData.parent.index];\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            let slotData = data.slots[i];\n            let bone = this.bones[slotData.boneData.index];\n            let slot = new Slot(slotData, bone);\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        this.ikConstraintsSorted = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            let ikConstraintData = data.ikConstraints[i];\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            let transformConstraintData = data.transformConstraints[i];\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            let pathConstraintData = data.pathConstraints[i];\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache () {\n        let updateCache = this._updateCache;\n        updateCache.length = 0;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].sorted = false;\n\n        // IK first, lowest hierarchy depth first.\n        let ikConstraints = this.ikConstraintsSorted;\n        ikConstraints.length = 0;\n        for (let i = 0; i < this.ikConstraints.length; i++)\n            ikConstraints.push(this.ikConstraints[i]);\n        let ikCount = ikConstraints.length;\n        for (let i = 0, level = 0, n = ikCount; i < n; i++) {\n            let ik = ikConstraints[i];\n            let bone = ik.bones[0].parent;\n            for (level = 0; bone != null; level++)\n                bone = bone.parent;\n            ik.level = level;\n        }\n        for (let i = 1, ii = 0; i < ikCount; i++) {\n            let ik = ikConstraints[i];\n            let level = ik.level;\n            for (ii = i - 1; ii >= 0; ii--) {\n                let other = ikConstraints[ii];\n                if (other.level < level) break;\n                ikConstraints[ii + 1] = other;\n            }\n            ikConstraints[ii + 1] = ik;\n        }\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            let target = constraint.target;\n            this.sortBone(target);\n\n            let constrained = constraint.bones;\n            let parent = constrained[0];\n            this.sortBone(parent);\n\n            updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            constrained[constrained.length - 1].sorted = true;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n\n            let slot = constraint.target;\n            let slotIndex = slot.data.index;\n            let slotBone = slot.bone;\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n            for (let ii = 0, nn = this.data.skins.length; ii < nn; ii++)\n                this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);\n\n            let attachment = slot.getAttachment();\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortBone(constrained[ii]);\n\n            updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n\n            this.sortBone(constraint.target);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortBone(constrained[ii]);\n\n            updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++)\n            this.sortBone(bones[i]);\n    }\n\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n        let attachments = skin.attachments[slotIndex];\n        if (!attachments) return;\n        for (let key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        let pathBones = (<PathAttachment>attachment).bones;\n        if (pathBones == null)\n            this.sortBone(slotBone);\n        else {\n            let bones = this.bones;\n            for (let i = 0; i < pathBones.length; i++) {\n                let boneIndex = pathBones[i];\n                this.sortBone(bones[boneIndex]);\n            }\n        }\n    }\n\n    sortBone (bone: Bone) {\n        if (bone.sorted) return;\n        let parent = bone.parent;\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset (bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform () {\n        let updateCache = this._updateCache;\n        for (let i = 0, n = updateCache.length; i < n; i++)\n            updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose () {\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.mix = constraint.data.mix;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            let data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            let data = constraint.data;\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose () {\n        let slots = this.slots;\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone () {\n        if (this.bones.length == 0) return null;\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.data.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName (skinName: string) {\n        let skin = this.data.findSkin(skinName);\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin (newSkin: Skin) {\n        if (newSkin != null) {\n            if (this.skin != null)\n                newSkin.attachAll(this, this.skin);\n            else {\n                let slots = this.slots;\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    let slot = slots[i];\n                    let name = slot.data.attachmentName;\n                    if (name != null) {\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    }\n\n    /** @return May be null. */\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n        if (this.skin != null) {\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment (slotName: string, attachmentName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null)\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw new Error(\"Slot not found: \" + slotName);\n    }\n\n    /** @return May be null. */\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let ikConstraint = ikConstraints[i];\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB. */\n    getBounds (offset: Vector2, size: Vector2) {\n        if (offset == null) throw new Error(\"offset cannot be null.\");\n        if (size == null) throw new Error(\"size cannot be null.\");\n        let drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            let slot = drawOrder[i];\n            let vertices: ArrayLike<number> = null;\n            let attachment = slot.getAttachment();\n            if (attachment instanceof RegionAttachment)\n                vertices = (<RegionAttachment>attachment).updateWorldVertices(slot, false);\n            else if (attachment instanceof MeshAttachment) //\n                vertices = (<MeshAttachment>attachment).updateWorldVertices(slot, true);\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 8) {\n                    let x = vertices[ii], y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update (delta: number) {\n        this.time += delta;\n    }\n}\n","import {Utils, Pool} from \"./Utils\";\nimport {Skeleton} from \"./Skeleton\";\nimport {BoundingBoxAttachment} from \"./attachments\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonBounds {\n    minX = 0; minY = 0; maxX = 0; maxY = 0;\n    boundingBoxes = new Array<BoundingBoxAttachment>();\n    polygons = new Array<ArrayLike<number>>();\n    private polygonPool = new Pool<ArrayLike<number>>(() => {\n        return Utils.newFloatArray(16);\n    });\n\n    update (skeleton: Skeleton, updateAabb: boolean) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        let boundingBoxes = this.boundingBoxes;\n        let polygons = this.polygons;\n        let polygonPool = this.polygonPool;\n        let slots = skeleton.slots;\n        let slotCount = slots.length;\n\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (let i = 0; i < slotCount; i++) {\n            let slot = slots[i];\n            let attachment = slot.getAttachment();\n            if (attachment instanceof BoundingBoxAttachment) {\n                let boundingBox = attachment as BoundingBoxAttachment;\n                boundingBoxes.push(boundingBox);\n\n                let polygon = polygonPool.obtain();\n                if (polygon.length != boundingBox.worldVerticesLength) {\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                }\n                polygons.push(polygon);\n                boundingBox.computeWorldVertices(slot, polygon);\n            }\n        }\n\n        if (updateAabb) this.aabbCompute();\n    }\n\n    aabbCompute () {\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            let polygon = polygons[i];\n            let vertices = polygon;\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                let x = vertices[ii];\n                let y = vertices[ii + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint (x: number, y: number) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        let m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        let x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton (bounds: SkeletonBounds) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    }\n\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n    containsPoint (x: number, y: number): BoundingBoxAttachment {\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++)\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n        return null;\n    }\n\n    /** Returns true if the polygon contains the point. */\n    containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\n        let vertices = polygon;\n        let nn = polygon.length;\n\n        let prevIndex = nn - 2;\n        let inside = false;\n        for (let ii = 0; ii < nn; ii += 2) {\n            let vertexY = vertices[ii + 1];\n            let prevY = vertices[prevIndex + 1];\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                let vertexX = vertices[ii];\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n        return inside;\n    }\n\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\n     * true. */\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++)\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n        return null;\n    }\n\n    /** Returns true if the polygon contains any part of the line segment. */\n    intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\n        let vertices = polygon;\n        let nn = polygon.length;\n\n        let width12 = x1 - x2, height12 = y1 - y2;\n        let det1 = x1 * y2 - y1 * x2;\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n        for (let ii = 0; ii < nn; ii += 2) {\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\n            let det2 = x3 * y4 - y3 * x4;\n            let width34 = x3 - x4, height34 = y3 - y4;\n            let det3 = width12 * height34 - height12 * width34;\n            let x = (det1 * width34 - width12 * det2) / det3;\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                let y = (det1 * height34 - height12 * det2) / det3;\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n        return false;\n    }\n\n    /** Returns the polygon for the specified bounding box, or null. */\n    getPolygon (boundingBox: BoundingBoxAttachment) {\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n        let index = this.boundingBoxes.indexOf(boundingBox);\n        return index == -1 ? null : this.polygons[index];\n    }\n\n    getWidth () {\n        return this.maxX - this.minX;\n    }\n\n    getHeight () {\n        return this.maxY - this.minY;\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Animation} from \"./Animation\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData} from \"./PathConstraintData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonData {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    width: number; height: number;\n    version: string; hash: string; imagesPath: string;\n\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    }\n\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    }\n\n    findSkin (skinName: string) {\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\n        let skins = this.skins;\n        for (let i = 0, n = skins.length; i < n; i++) {\n            let skin = skins[i];\n            if (skin.name == skinName) return skin;\n        }\n        return null;\n    }\n\n    findEvent (eventDataName: string) {\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n        let events = this.events;\n        for (let i = 0, n = events.length; i < n; i++) {\n            let event = events[i];\n            if (event.name == eventDataName) return event;\n        }\n        return null;\n    }\n\n    findAnimation (animationName: string) {\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\n        let animations = this.animations;\n        for (let i = 0, n = animations.length; i < n; i++) {\n            let animation = animations[i];\n            if (animation.name == animationName) return animation;\n        }\n        return null;\n    }\n\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraintIndex (pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\n            if (pathConstraints[i].name == pathConstraintName) return i;\n        return -1;\n    }\n}\n","import {SkeletonData} from \"./SkeletonData\";\nimport {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Event} from \"./Event\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData, PositionMode, SpacingMode, RotateMode} from \"./PathConstraintData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from \"./attachments\";\nimport {Utils, Color} from \"./Utils\";\nimport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nimport {BlendMode} from \"./BlendMode\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor (attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData (json: string | any ): SkeletonData {\n        let scale = this.scale;\n        let skeletonData = new SkeletonData();\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\n\n        // Skeleton\n        let skeletonMap = root.skeleton;\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                let boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n                }\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                data.inheritRotation = this.getValue(boneMap, \"inheritRotation\", true);\n                data.inheritScale = this.getValue(boneMap, \"inheritScale\", true);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                let slotMap = root.slots[i];\n                let slotName: string = slotMap.name;\n                let boneName: string = slotMap.bone;\n                let boneData = skeletonData.findBone(boneName);\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                let color: string = this.getValue(slotMap, \"color\", null);\n                if (color != null) data.color.setFromString(color);\n\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                let constraintMap = root.ik[i];\n                let data = new IkConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                let constraintMap = root.transform[i];\n                let data = new TransformConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                let constraintMap = root.path[i];\n                let data = new PathConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.position = this.getValue(constraintMap, \"position\", 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let skinName in root.skins) {\n                let skinMap = root.skins[skinName]\n                let skin = new Skin(skinName);\n                for (let slotName in skinMap) {\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                    let slotMap = skinMap[slotName];\n                    for (let entryName in slotMap) {\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            let linkedMesh = this.linkedMeshes[i];\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (let eventName in root.events) {\n                let eventMap = root.events[eventName];\n                let data = new EventData(eventName);\n                data.intValue = this.getValue(eventMap, \"int\", 0);\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\n                data.stringValue = this.getValue(eventMap, \"string\", null);\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (let animationName in root.animations) {\n                let animationMap = root.animations[animationName];\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string): Attachment {\n        let scale = this.scale;\n        name = this.getValue(map, \"name\", name);\n\n        let type = this.getValue(map, \"type\", \"region\");\n\n        switch (type) {\n            case \"region\": {\n                let path = this.getValue(map, \"path\", name);\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, \"x\", 0) * scale;\n                region.y = this.getValue(map, \"y\", 0) * scale;\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\n                region.rotation = this.getValue(map, \"rotation\", 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) region.color.setFromString(color);\n\n                return region;\n            }\n            case \"boundingbox\": {\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) box.color.setFromString(color);\n                return box;\n            }\n            case \"mesh\":\n            case \"linkedmesh\": {\n                let path = this.getValue(map, \"path\", name);\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                let color = this.getValue(map, \"color\", null);\n                if (color != null) mesh.color.setFromString(color);\n\n                let parent: string = this.getValue(map, \"parent\", null);\n                if (parent != null) {\n                    mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\n                    return mesh;\n                }\n\n                let uvs: Array<number> = map.uvs;\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = uvs;\n                // mesh.updateUVs();\n\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                return mesh;\n            }\n            case \"path\": {\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\n                if (path == null) return null;\n                path.closed = this.getValue(map, \"closed\", false);\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\n                let vertexCount = map.vertexCount;\n                this.readVertices(map, path, vertexCount << 1);\n\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n                for (let i = 0; i < map.lengths.length; i++)\n                    lengths[i++] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) path.color.setFromString(color);\n                return path;\n            }\n        }\n        return null;\n    }\n\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n        let scale = this.scale;\n        attachment.worldVerticesLength = verticesLength;\n        let vertices: Array<number> = map.vertices;\n        if (verticesLength == vertices.length) {\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++)\n                    vertices[i] *= scale;\n            }\n            attachment.vertices = Utils.toFloatArray(vertices);\n            return;\n        }\n        let weights = new Array<number>();\n        let bones = new Array<number>();\n        for (let i = 0, n = vertices.length; i < n;) {\n            let boneCount = vertices[i++];\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\n        let scale = this.scale;\n        let timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (let slotName in map.slots) {\n                let slotMap = map.slots[slotName];\n                let slotIndex = skeletonData.findSlotIndex(slotName);\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                for (let timelineName in slotMap) {\n                    let timelineMap = slotMap[timelineName];\n                    if (timelineName == \"color\") {\n                        let timeline = new ColorTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let color = new Color();\n                            color.setFromString(valueMap.color);\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n\n                    } else if (timelineName = \"attachment\") {\n                        let timeline = new AttachmentTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (let boneName in map.bones) {\n                let boneMap = map.bones[boneName];\n                let boneIndex = skeletonData.findBoneIndex(boneName);\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                for (let timelineName in boneMap) {\n                    let timelineMap = boneMap[timelineName];\n                    if (timelineName === \"rotate\") {\n                        let timeline = new RotateTimeline(timelineMap.length);\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"scale\")\n                            timeline = new ScaleTimeline(timelineMap.length);\n                        else if (timelineName === \"shear\")\n                            timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n\n                    } else\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (let constraintName in map.ik) {\n                let constraintMap = map.ik[constraintName];\n                let constraint = skeletonData.findIkConstraint(constraintName);\n                let timeline = new IkConstraintTimeline(constraintMap.length);\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (let constraintName in map.transform) {\n                let constraintMap = map.transform[constraintName];\n                let constraint = skeletonData.findTransformConstraint(constraintName);\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration,\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.paths) {\n            for (let constraintName in map.paths) {\n                let constraintMap = map.paths[constraintName];\n                let index = skeletonData.findPathConstraintIndex(constraintName);\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                let data = skeletonData.pathConstraints[index];\n                for (let timelineName in constraintMap) {\n                    let timelineMap = constraintMap[timelineName];\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"spacing\") {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === \"mix\") {\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                                this.getValue(valueMap, \"translateMix\", 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (let deformName in map.deform) {\n                let deformMap = map.deform[deformName];\n                let skin = skeletonData.findSkin(deformName);\n                if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                for (let slotName in deformMap) {\n                    let slotMap = deformMap[slotName];\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                    for (let timelineName in slotMap) {\n                        let timelineMap = slotMap[timelineName];\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                        let weighted = attachment.bones != null;\n                        let vertices = attachment.vertices;\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n                        let timeline = new DeformTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            let valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\n                            if (verticesValue == null)\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\n                                        deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++)\n                                        deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\n            let slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                let drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0, unchangedIndex = 0;\n                    for (let i = 0; i < offsets.length; i++) {\n                        let offsetMap = offsets[i];\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--)\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            let timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n            for (let i = 0; i < map.events.length; i++) {\n                let eventMap = map.events[i];\n                let eventData = skeletonData.findEvent(eventMap.name);\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                let event = new Event(eventMap.time, eventData);\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error(\"Error while parsing animation, duration is NaN\");\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.curve) return;\n        if (map.curve === \"stepped\")\n            timeline.setStepped(frameIndex);\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n            let curve: Array<number> = map.curve;\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n    }\n\n    getValue (map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString (str: string): number {\n        if (str === 'multiply') return PIXI.BLEND_MODES.MULTIPLY;\n        if (str === 'additive') return PIXI.BLEND_MODES.ADD;\n        if (str === 'screen') return PIXI.BLEND_MODES.SCREEN;\n        if (str === 'normal') return PIXI.BLEND_MODES.NORMAL;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"fixed\") return PositionMode.Fixed;\n        if (str == \"percent\") return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"length\") return SpacingMode.Length;\n        if (str == \"fixed\") return SpacingMode.Fixed;\n        if (str == \"percent\") return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"tangent\") return RotateMode.Tangent;\n        if (str == \"chain\") return RotateMode.Chain;\n        if (str == \"chainscale\") return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string; skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n    }\n}\n","import {Attachment} from \"./attachments\";\nimport {Skeleton} from \"./Skeleton\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n\n    addAttachment (slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\n        let attachments = this.attachments;\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, name: string): Attachment {\n        let dictionary = this.attachments[slotIndex];\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            let slot = skeleton.slots[i];\n            let slotAttachment = slot.getAttachment();\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                let dictionary = oldSkin.attachments[slotIndex];\n                for (let key in dictionary) {\n                    let skinAttachment:Attachment = dictionary[key];\n                    if (slotAttachment == skinAttachment) {\n                        let attachment = this.getAttachment(slotIndex, key);\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import {Attachment} from \"./attachments\";\nimport {SlotData} from \"./SlotData\";\nimport {Bone} from \"./Bone\";\nimport {Color} from \"./Utils\";\nimport {TextureRegion} from \"./Texture\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Slot {\n    //this is for PIXI\n    currentMesh: any;\n    currentSprite: any;\n    meshes: any;\n    currentMeshName: String;\n    sprites: any;\n    currentSpriteName: String;\n    blendMode: number;\n    //assign hack region a bit later\n    tempRegion: TextureRegion;\n    tempAttachment: Attachment;\n\n    //canon\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentVertices = new Array<number>();\n\n    constructor (data: SlotData, bone: Bone) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (bone == null) throw new Error(\"bone cannot be null.\");\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.blendMode = data.blendMode;\n        this.setToSetupPose();\n    }\n\n    /** @return May be null. */\n    getAttachment (): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment (attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    }\n\n    setAttachmentTime (time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime (): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose () {\n        this.color.setFromColor(this.data.color);\n        if (this.data.attachmentName == null)\n            this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {Color} from \"./Utils\";\nimport {BlendMode} from \"./BlendMode\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    attachmentName: string;\n    blendMode: number;\n\n    constructor (index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n","export abstract class Texture {\n    protected _image: HTMLImageElement;\n\n    constructor (image: HTMLImageElement) {\n        this._image = image;\n    }\n\n    getImage (): HTMLImageElement {\n        return this._image;\n    }\n\n    abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n    abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n    abstract dispose (): void;\n\n\n    public static filterFromString (text: string): TextureFilter {\n        switch (text.toLowerCase()) {\n            case \"nearest\": return TextureFilter.Nearest;\n            case \"linear\": return TextureFilter.Linear;\n            case \"mipmap\": return TextureFilter.MipMap;\n            case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n            case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n            case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n            case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n            default: throw new Error(`Unknown texture filter ${text}`);\n        }\n    }\n\n    public static wrapFromString (text: string): TextureWrap {\n        switch (text.toLowerCase()) {\n            case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n            case \"clamptoedge\": return TextureWrap.ClampToEdge;\n            case \"repeat\": return TextureWrap.Repeat;\n            default: throw new Error(`Unknown texture wrap ${text}`);\n        }\n    }\n}\n\nexport enum TextureFilter {\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\n    Linear = 9729, // WebGLRenderingContext.LINEAR\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\nexport enum TextureWrap {\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\n}\n\nexport class TextureRegion {\n    texture: PIXI.Texture;\n\n    //thats for overrides\n    size: PIXI.Rectangle = null;\n\n    get width(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            return tex.crop.width;\n        }\n        if (tex.trim) {\n            return tex.trim.width;\n        }\n        return tex.orig.width;\n    }\n\n    get height(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            return tex.crop.height;\n        }\n        if (tex.trim) {\n            return tex.trim.height;\n        }\n        return tex.orig.height;\n    }\n\n    get u(): number {\n        return this.texture._uvs.x0;\n    }\n\n    get v(): number {\n        return this.texture._uvs.y0;\n    }\n\n    get u2(): number {\n        return this.texture._uvs.x2;\n    }\n\n    get v2(): number {\n        return this.texture._uvs.y2;\n    }\n\n    get offsetX(): number {\n        const tex = this.texture;\n        return tex.trim ? tex.trim.x : 0;\n    }\n\n    get offsetY(): number {\n        console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n        return this.spineOffsetY;\n    }\n\n    get pixiOffsetY(): number {\n        const tex = this.texture;\n        return tex.trim ? tex.trim.y : 0;\n    }\n\n    get spineOffsetY(): number {\n        var tex = this.texture;\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n    }\n\n    get originalWidth(): number {\n        var tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.crop.width;\n        }\n        return tex.orig.width;\n    }\n\n    get originalHeight(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.crop.height;\n        }\n        return tex.orig.height;\n    }\n\n    get x(): number {\n        return this.texture.frame.x;\n    }\n\n    get y(): number {\n        return this.texture.frame.y;\n    }\n\n    get rotate(): boolean {\n        return this.texture.rotate !== 0;\n    }\n}\n","import {Disposable} from \"./Utils\";\nimport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TextureAtlas implements Disposable {\n    pages = new Array<TextureAtlasPage>();\n    regions = new Array<TextureAtlasRegion>();\n\n    constructor(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (atlasText) {\n            this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n    }\n\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\n        return this.load(atlasText, textureLoader, callback);\n    }\n\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (textureLoader == null)\n            throw new Error(\"textureLoader cannot be null.\");\n\n        let reader = new TextureAtlasReader(atlasText);\n        let tuple = new Array<string>(4);\n        let page: TextureAtlasPage = null;\n\n        let iterateParser = () => {\n            while (true) {\n                let line = reader.readLine();\n                if (line == null) {\n                    return callback && callback(this);\n                }\n                line = line.trim();\n                if (line.length == 0)\n                    page = null;\n                else if (!page) {\n                    page = new TextureAtlasPage();\n                    page.name = line;\n\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                        page.width = parseInt(tuple[0]);\n                        page.height = parseInt(tuple[1]);\n                        reader.readTuple(tuple);\n                    }\n                    // page.format = Format[tuple[0]]; we don't need format in WebGL\n\n                    reader.readTuple(tuple);\n                    page.minFilter = Texture.filterFromString(tuple[0]);\n                    page.magFilter = Texture.filterFromString(tuple[1]);\n\n                    let direction = reader.readValue();\n                    page.uWrap = TextureWrap.ClampToEdge;\n                    page.vWrap = TextureWrap.ClampToEdge;\n                    if (direction == \"x\")\n                        page.uWrap = TextureWrap.Repeat;\n                    else if (direction == \"y\")\n                        page.vWrap = TextureWrap.Repeat;\n                    else if (direction == \"xy\")\n                        page.uWrap = page.vWrap = TextureWrap.Repeat;\n\n                    textureLoader(line, (texture: PIXI.BaseTexture) => {\n                        page.baseTexture = texture;\n                        if (!texture.hasLoaded) {\n                            texture.width = page.width;\n                            texture.height = page.height;\n                        }\n                        this.pages.push(page);\n                        page.setFilters();\n\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                            }\n                        }\n                        iterateParser();\n                    });\n                    this.pages.push(page);\n                    break;\n                } else {\n                    let region: TextureAtlasRegion = new TextureAtlasRegion();\n                    region.name = line;\n                    region.page = page;\n\n                    let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\n\n                    reader.readTuple(tuple);\n                    let x = parseInt(tuple[0]);\n                    let y = parseInt(tuple[1]);\n\n                    reader.readTuple(tuple);\n                    let width = parseInt(tuple[0]);\n                    let height = parseInt(tuple[1]);\n\n                    let resolution = page.baseTexture.resolution;\n                    x /= resolution;\n                    y /= resolution;\n                    width /= resolution;\n                    height /= resolution;\n\n                    let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                    if (reader.readTuple(tuple) == 4) { // split is optional\n                        // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                            //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                            reader.readTuple(tuple);\n                        }\n                    }\n\n                    let originalWidth = parseInt(tuple[0]) / resolution;\n                    let originalHeight = parseInt(tuple[1]) / resolution;\n                    reader.readTuple(tuple);\n                    let offsetX = parseInt(tuple[0]) / resolution;\n                    let offsetY = parseInt(tuple[1]) / resolution;\n\n                    let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                    let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                    //TODO: pixiv3 uses different frame/crop/trim\n\n                    if (PIXI.VERSION[0] == '4') {\n                        // pixi v4.0.0\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                    } else {\n                        // pixi v3.0.11\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\n                        var crop = frame2.clone();\n                        trim.width = originalWidth;\n                        trim.height = originalHeight;\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                    }\n\n                    region.index = parseInt(reader.readValue());\n                    region.texture._updateUvs();\n\n                    this.regions.push(region);\n                }\n            }\n        }\n\n        iterateParser();\n    }\n\n    findRegion(name: string): TextureAtlasRegion {\n        for (let i = 0; i < this.regions.length; i++) {\n            if (this.regions[i].name == name) {\n                return this.regions[i];\n            }\n        }\n        return null;\n    }\n\n    dispose() {\n        for (let i = 0; i < this.pages.length; i++) {\n            this.pages[i].baseTexture.dispose();\n        }\n    }\n}\n\nclass TextureAtlasReader {\n    lines: Array<string>;\n    index: number = 0;\n\n    constructor(text: string) {\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n    }\n\n    readLine(): string {\n        if (this.index >= this.lines.length)\n            return null;\n        return this.lines[this.index++];\n    }\n\n    readValue(): string {\n        let line = this.readLine();\n        let colon = line.indexOf(\":\");\n        if (colon == -1)\n            throw new Error(\"Invalid line: \" + line);\n        return line.substring(colon + 1).trim();\n    }\n\n    readTuple(tuple: Array<string>): number {\n        let line = this.readLine();\n        let colon = line.indexOf(\":\");\n        if (colon == -1)\n            throw new Error(\"Invalid line: \" + line);\n        let i = 0, lastMatch = colon + 1;\n        for (; i < 3; i++) {\n            let comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) break;\n            tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n            lastMatch = comma + 1;\n        }\n        tuple[i] = line.substring(lastMatch).trim();\n        return i + 1;\n    }\n}\n\nexport class TextureAtlasPage {\n    name: string;\n    minFilter: TextureFilter;\n    magFilter: TextureFilter;\n    uWrap: TextureWrap;\n    vWrap: TextureWrap;\n    baseTexture: PIXI.BaseTexture;\n    width: number;\n    height: number;\n\n    public setFilters() {\n        let tex = this.baseTexture;\n        let filter = this.minFilter;\n        if (filter == TextureFilter.Linear) {\n            tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n        } else if (this.minFilter == TextureFilter.Nearest) {\n            tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        } else {\n            tex.mipmap = true;\n            if (filter == TextureFilter.MipMapNearestNearest) {\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n            } else {\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n            }\n        }\n    }\n}\n\nexport class TextureAtlasRegion extends TextureRegion {\n    page: TextureAtlasPage;\n    name: string;\n    index: number;\n}\n","import {Skin} from \"./Skin\";\nimport {AttachmentLoader, BoundingBoxAttachment, MeshAttachment, PathAttachment, RegionAttachment} from \"./attachments\";\nimport {TextureAtlas} from \"./TextureAtlas\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TextureAtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor (atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n        let attachment = new RegionAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment (skin: Skin, name: string, path: string) : MeshAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n        let attachment = new MeshAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment (skin: Skin, name: string) : BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment (skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Vector2, MathUtils} from \"./Utils\";\nimport {Skeleton} from \"./Skeleton\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraint implements Updatable {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    temp = new Vector2();\n\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n        let target = this.target;\n        let tm = target.matrix;\n        let ta = tm.a, tb = tm.c, tc = tm.b, td = tm.d;\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            let m = bone.matrix;\n\n            if (rotateMix > 0) {\n                let a = m.a, b = m.c, c = m.b, d = m.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + this.data.offsetRotation * MathUtils.degRad;\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                let cos = Math.cos(r), sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n            }\n\n            if (translateMix > 0) {\n                let temp = this.temp;\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                m.tx += (temp.x - bone.worldX) * translateMix;\n                m.ty += (temp.y - bone.worldY) * translateMix;\n            }\n\n            if (scaleMix > 0) {\n                let bs = Math.sqrt(m.a * m.a + m.b * m.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n                let s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleX) * scaleMix) / bs : 0;\n                m.a *= s;\n                m.b *= s;\n                bs = Math.sqrt(m.c * m.c + m.d * m.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleY) * scaleMix) / bs : 0;\n                m.c *= s;\n                m.d *= s;\n            }\n\n            if (shearMix > 0) {\n                let b = m.c, d = m.d;\n                let by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(m.b, m.a));\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r = by + (r + this.data.offsetShearY * MathUtils.degRad) * shearMix;\n                let s = Math.sqrt(b * b + d * d);\n                m.c = Math.cos(r) * s;\n                m.d = Math.sin(r) * s;\n            }\n        }\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport interface Map<T> {\n    [key: string]: T;\n}\n\nexport interface Disposable {\n    dispose (): void;\n}\n\nexport class Color {\n    public static WHITE = new Color(1, 1, 1, 1);\n    public static RED = new Color(1, 0, 0, 1);\n    public static GREEN = new Color(0, 1, 0, 1);\n    public static BLUE = new Color(0, 0, 1, 1);\n    public static MAGENTA = new Color(1, 0, 1, 1);\n\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n    }\n\n    set (r: number, g: number, b: number, a: number) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.clamp();\n        return this;\n    }\n\n    setFromColor (c: Color) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n        return this;\n    }\n\n    setFromString (hex: string) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n        this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n        return this;\n    }\n\n    add (r: number, g: number, b: number, a: number) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n        this.clamp();\n        return this;\n    }\n\n    clamp () {\n        if (this.r < 0) this.r = 0;\n        else if (this.r > 1) this.r = 1;\n\n        if (this.g < 0) this.g = 0;\n        else if (this.g > 1) this.g = 1;\n\n        if (this.b < 0) this.b = 0;\n        else if (this.b > 1) this.b = 1;\n\n        if (this.a < 0) this.a = 0;\n        else if (this.a > 1) this.a = 1;\n        return this;\n    }\n}\n\nexport class MathUtils {\n    static PI = 3.1415927;\n    static PI2 = MathUtils.PI * 2;\n    static radiansToDegrees = 180 / MathUtils.PI;\n    static radDeg = MathUtils.radiansToDegrees;\n    static degreesToRadians = MathUtils.PI / 180;\n    static degRad = MathUtils.degreesToRadians;\n\n    static clamp (value: number, min: number, max: number) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n\n    static cosDeg (degrees: number) {\n        return Math.cos(degrees * MathUtils.degRad);\n    }\n\n    static sinDeg (degrees: number) {\n        return Math.sin(degrees * MathUtils.degRad);\n    }\n\n    static signum (value: number): number {\n        return value >= 0 ? 1 : -1;\n    }\n\n    static toInt (x: number) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n    }\n\n    static cbrt (x: number) {\n        var y = Math.pow(Math.abs(x), 1/3);\n        return x < 0 ? -y : y;\n    }\n}\n\nexport class Utils {\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n            dest[j] = source[i];\n        }\n    }\n\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n        let oldSize = array.length;\n        if (oldSize == size) return array;\n        array.length = size;\n        if (oldSize < size) {\n            for (let i = oldSize; i < size; i++) array[i] = value;\n        }\n        return array;\n    }\n\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\n        let array = new Array<T>(size);\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\n        return array;\n    }\n\n    static newFloatArray (size: number): ArrayLike<number> {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Float32Array(size)\n        } else {\n             let array = new Array<number>(size);\n             for (let i = 0; i < array.length; i++) array[i] = 0;\n             return array;\n        }\n    }\n\n    static toFloatArray (array: Array<number>) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n    }\n}\n\nexport class DebugUtils {\n    static logBones(skeleton: Skeleton) {\n        for (let i = 0; i < skeleton.bones.length; i++) {\n            let bone = skeleton.bones[i];\n            let m = bone.matrix;\n            console.log(bone.data.name + \", \" + m.a + \", \" + m.b + \", \" + m.c + \", \" + m.d + \", \" + m.tx + \", \" + m.ty);\n        }\n    }\n}\n\nexport class Pool<T> {\n    private items = new Array<T>();\n    private instantiator: () => T;\n\n    constructor (instantiator: () => T) {\n        this.instantiator = instantiator;\n    }\n\n    obtain () {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n    }\n\n    free (item: T) {\n        this.items.push(item);\n    }\n\n    freeAll (items: ArrayLike<T>) {\n        for (let i = 0; i < items.length; i++) this.items[i] = items[i];\n    }\n\n    clear () {\n        this.items.length = 0;\n    }\n}\n\nexport class Vector2 {\n    constructor (public x = 0, public y = 0) {\n    }\n\n    set (x: number, y: number): Vector2 {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    length () {\n        let x = this.x;\n        let y = this.y;\n        return Math.sqrt(x * x + y * y);\n    }\n\n    normalize () {\n        let len = this.length();\n        if (len != 0) {\n            this.x /= len;\n            this.y /= len;\n        }\n        return this;\n    }\n}\n\nexport class TimeKeeper {\n    maxDelta = 0.064;\n    framesPerSecond = 0;\n    delta = 0;\n    totalTime = 0;\n\n    private lastTime = Date.now() / 1000;\n    private frameCount = 0;\n    private frameTime = 0;\n\n    update () {\n        var now = Date.now() / 1000;\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n\n        this.frameCount++;\n        if (this.frameTime > 1) {\n            this.framesPerSecond = this.frameCount / this.frameTime;\n            this.frameTime = 0;\n            this.frameCount = 0;\n        }\n    }\n}\n","import {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport abstract class Attachment {\n    name: string;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n\nexport abstract class VertexAttachment extends Attachment {\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n\n    constructor (name: string) {\n        super(name);\n    }\n\n    computeWorldVertices (slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVerticesWith (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number) {\n        count += offset;\n        let skeleton = slot.bone.skeleton;\n        let x = skeleton.x, y = skeleton.y;\n        let deformArray = slot.attachmentVertices;\n        let vertices = this.vertices;\n        let bones = this.bones;\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            let bone = slot.bone;\n            let m = bone.matrix;\n            x += m.tx;\n            y += m.ty;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            for (let v = start, w = offset; w < count; v += 2, w += 2) {\n                let vx = vertices[v], vy = vertices[v + 1];\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n            return;\n        }\n        let v = 0, skip = 0;\n        for (let i = 0; i < start; i += 2) {\n            let n = bones[v];\n            v += n + 1;\n            skip += n;\n        }\n        let skeletonBones = skeleton.bones;\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += 2) {\n                let wx = x, wy = y;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            let deform = deformArray;\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += 2) {\n                let wx = x, wy = y;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n    applyDeform (sourceAttachment: VertexAttachment) {\n        return this == sourceAttachment;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport enum AttachmentType {\n    Region, BoundingBox, Mesh, LinkedMesh, Path\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {Color} from \"../Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class BoundingBoxAttachment extends VertexAttachment {\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {TextureRegion} from \"../Texture\";\nimport {Color, Utils} from \"../Utils\";\nimport {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class MeshAttachment extends VertexAttachment {\n    region: TextureRegion;\n    path: string;\n    regionUVs: ArrayLike<number>;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    hullLength: number;\n    private parentMesh: MeshAttachment;\n    inheritDeform = false;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\n        return [];\n        //nothing\n    }\n\n    updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\n        let regionUVs = this.regionUVs;\n        let n = regionUVs.length;\n        if (!uvs || uvs.length != n) {\n            uvs = Utils.newFloatArray(n);\n        }\n\n        if (region == null) {\n            return;\n        }\n\n        let texture = region.texture;\n        let r = texture._uvs;\n        let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        let x = region.offsetX, y = region.pixiOffsetY;\n\n        for (let i = 0; i < n; i += 2) {\n            let u = this.regionUVs[i], v = this.regionUVs[i + 1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n\n        return uvs;\n    }\n\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {Color} from \"../Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathAttachment extends VertexAttachment {\n    lengths: Array<number>;\n    closed = false; constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor (name: string) {\n        super(name);\n    }\n}\n","import {Attachment} from \"./Attachment\";\nimport {Color, Utils} from \"../Utils\";\nimport {TextureRegion} from \"../Texture\";\nimport {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class RegionAttachment extends Attachment {\n    x = 0; y = 0; scaleX = 1; scaleY = 1; rotation = 0; width = 0; height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    region: TextureRegion;\n\n    constructor (name:string) {\n        super(name);\n    }\n\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\n        return [];\n        //nothing\n    }\n}\n","export {Attachment, VertexAttachment} from \"./Attachment\";\nexport {AttachmentLoader} from \"./AttachmentLoader\";\nexport {AttachmentType} from \"./AttachmentType\";\nexport {BoundingBoxAttachment} from \"./BoundingBoxAttachment\";\nexport {MeshAttachment} from \"./MeshAttachment\";\nexport {PathAttachment} from \"./PathAttachment\";\nexport {RegionAttachment} from \"./RegionAttachment\";\n","export * from \"./attachments\";\n\nexport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nexport {AnimationState} from \"./AnimationState\";\nexport {AnimationStateData} from \"./AnimationStateData\";\nexport {BlendMode} from \"./BlendMode\";\nexport {Bone} from \"./Bone\";\nexport {BoneData} from \"./BoneData\";\nexport {Event} from \"./Event\";\nexport {EventData} from \"./EventData\";\nexport {IkConstraint} from \"./IkConstraint\";\nexport {IkConstraintData} from \"./IkConstraintData\";\nexport {PathConstraint} from \"./PathConstraint\";\nexport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nexport {Skeleton} from \"./Skeleton\";\nexport {SkeletonBounds} from \"./SkeletonBounds\";\nexport {SkeletonData} from \"./SkeletonData\";\nexport {SkeletonJson} from \"./SkeletonJson\";\nexport {Skin} from \"./Skin\";\nexport {Slot} from \"./Slot\";\nexport {SlotData} from \"./SlotData\";\nexport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\nexport {TextureAtlas, TextureAtlasRegion} from \"./TextureAtlas\";\nexport {TextureAtlasAttachmentLoader} from \"./TextureAtlasAttachmentLoader\";\nexport {TransformConstraint} from \"./TransformConstraint\";\nexport {TransformConstraintData} from \"./TransformConstraintData\";\nexport {Updatable} from \"./Updatable\";\nexport {Disposable, Map, Utils, Pool, MathUtils, Color, Vector2} from \"./Utils\";\n","import * as spine from \"./core\";\n\nexport function atlasParser() {\n    return function (resource: PIXI.loaders.Resource, next: () => any) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\n        if (metadataAtlas === false) {\n            return next();\n        }\n        if (metadataAtlas && metadataAtlas.pages) {\n            //its an atlas!\n            var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(metadataAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = metadataAtlas;\n\n            return next();\n        }\n\n        var metadataAtlasSuffix = '.atlas';\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n        //remove the baseUrl\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n        //remove the baseUrl\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function () {\n            new spine.TextureAtlas(this.xhr.responseText, adapter, function(spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n\n                next();\n            });\n        });\n    };\n}\n\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: String, callback: (baseTexture: PIXI.BaseTexture) => any) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\n            callback(resource.texture.baseTexture);\n        });\n    }\n}\n\nexport function syncImageLoaderAdapter (baseUrl: any, crossOrigin: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: any, callback: any) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    }\n}\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n","import * as core from \"./core\";\nimport * as loaders from \"./loaders\";\n\nexport {core, loaders}\n\nexport {Spine, SpineMesh, SpineSprite} from \"./Spine\";\n\n"],"sourceRoot":"/source/"}