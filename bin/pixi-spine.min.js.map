{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/Spine.ts","src/core/Animation.ts","src/core/AnimationState.ts","src/core/AnimationStateData.ts","src/core/BlendMode.ts","src/core/Bone.ts","src/core/BoneData.ts","src/core/Event.ts","src/core/EventData.ts","src/core/IkConstraint.ts","src/core/IkConstraintData.ts","src/core/PathConstraint.ts","src/core/PathConstraintData.ts","src/core/Skeleton.ts","src/core/SkeletonBounds.ts","src/core/SkeletonData.ts","src/core/SkeletonJson.ts","src/core/Skin.ts","src/core/Slot.ts","src/core/SlotData.ts","src/core/Texture.ts","src/core/TextureAtlas.ts","src/core/TextureAtlasAttachmentLoader.ts","src/core/TransformConstraint.ts","src/core/TransformConstraintData.ts","src/core/Utils.ts","src/core/attachments/Attachment.ts","src/core/attachments/AttachmentType.ts","src/core/attachments/BoundingBoxAttachment.ts","src/core/attachments/MeshAttachment.ts","src/core/attachments/PathAttachment.ts","src/core/attachments/RegionAttachment.ts","src/core/attachments/index.ts","src/core/index.ts","src/loaders.ts","src/index.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","PIXI","spine","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","SlotContainerUpdateTransformV3","pt","parent","worldTransform","wt","lt","localTransform","b","c","d","tx","ty","worldAlpha","alpha","_currentBounds","TransformBase","Bone","yDown","tempRgb","SpineSprite","_super","tex","__extends","Sprite","SpineMesh","texture","vertices","uvs","indices","drawMode","mesh","Mesh","Spine","spineData","hackTextureBySlotName","slotName","size","index","skeleton","findSlotIndex","hackTextureBySlotIndex","Skeleton","updateWorldTransform","stateData","AnimationStateData","state","AnimationState","slotContainers","slots","slot","attachment","slotContainer","Container","push","addChild","RegionAttachment","spriteName","region","name","sprite","createSprite","currentSprite","currentSpriteName","MeshAttachment","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","Float32Array","Object","defineProperty","prototype","updateTransform","autoUpdateTransform","value","utils","rgb2hex","hex2rgb","update","dt","apply","drawOrder","children","data","r0","g0","b0","attColor","color","ar","visible","sprites","undefined","transform","lt_1","matrix2d","_dirtyVersion","version","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","bone","matrix","copy","x","y","Matrix","displayObjectUpdateTransform","tint","blendMode","meshName","meshes","computeWorldVertices","VERSION","setSpriteRegion","scale","width","originalWidth","height","originalHeight","scaleX","scaleY","setMeshRegion","updateUVs","dirty","globalAutoUpdate","lastTime","Date","now","timeDelta","tempAttachment","tempRegion","rotation","MathUtils","degRad","anchor","strip","regionUVs","Uint16Array","triangles","DRAW_MODES","TRIANGLES","canvasPadding","slotIndex","TextureRegion","Utils_1","attachments_1","Animation","timelines","duration","time","loop","events","mix","binarySearch","values","target","step","low","high","current","linearSearch","last","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","type","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","getCurvePercent","percent","clamp","start","prevX","prevY","RotateTimeline","frames","setFrame","degrees","ROTATION","bones","boneIndex","ENTRIES","amount_1","PREV_ROTATION","frame","prevRotation","frameTime","PREV_TIME","amount","TranslateTimeline","X","Y","PREV_X","PREV_Y","ScaleTimeline","ShearTimeline","shearX","shearY","ColorTimeline","R","G","B","A","PREV_R","PREV_G","PREV_B","PREV_A","add","set","AttachmentTimeline","attachmentNames","Array","attachmentName","setAttachment","getAttachment","EventTimeline","event","firedEvents","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","arrayCopy","DeformTimeline","frameVertices","slotAttachment","VertexAttachment","applyDeform","vertexCount","verticesArray","attachmentVertices","setArraySize","lastVertices","prevVertices","nextVertices","prev","IkConstraintTimeline","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","ikConstraintIndex","PREV_MIX","Math","floor","PREV_BEND_DIRECTION","TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","transformConstraintIndex","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","rotate","translate","shear","PathConstraintPositionTimeline","VALUE","pathConstraints","pathConstraintIndex","PREV_VALUE","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","tracks","timeScale","delta","next","nextTime","delay","nextDelta","setCurrent","endTime","clearTrack","previous","previousDelta","mixTime","animation","previousTime","mixDuration","ii","nn","event_1","onEvent","count","toInt","onComplete","clearTracks","trackIndex","onEnd","freeAll","entry","expandToIndex","getMix","onStart","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","TrackEntry","addAnimation","addAnimationWith","hasAnimation","getCurrent","setAnimationByName","deprecatedWarning1","console","warn","addAnimationByName","deprecatedWarning2","hasAnimationByName","deprecatedWarning3","reset","isComplete","animationToMixTime","defaultMix","setMix","fromName","toName","from","to","setMixWith","key","BlendMode","appliedRotation","worldSignX","worldSignY","sorted","setToSetupPose","updateWorldTransformWith","rotationY","la","cosDeg","lb","lc","sinDeg","ld","m","flipX","flipY","signum","pa","pb","pc","pd","inheritRotation","inheritScale","cos","sin","temp","psx","psy","za","zb","zc","zd","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldToLocalRotationX","pm","worldToLocalRotationY","rotateWorld","updateLocalTransform","det","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","worldToLocal","world","invDet","localToWorld","local","BoneData","Event","EventData","IkConstraint","level","findBone","apply1","worldX","worldY","apply2","targetX","targetY","pp","rotationIK","child","bendDir","px","py","csx","os1","os2","s2","cx","cy","cwx","cwy","abs","ppm","l1","l2","a1","a2","outer","acos","aa","bb","dd","ta","c1","c2","q","r1","minAngle","minDist","minX","minY","maxAngle","maxDist","maxX","maxY","PI","angle","os","IkConstraintData","PathConstraintData_1","PathConstraint","spaces","positions","lengths","segments","findSlot","PathAttachment","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","length_1","max","computeWorldPositions","positionMode","PositionMode","Percent","skeletonX","skeletonY","boneX","boneY","offsetRotation","tip","Chain","p","length_2","length_3","PI2","path","percentPosition","percentSpacing","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","pathLength_1","curve","space","BEFORE","computeWorldVerticesWith","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","x1","y1","x2","y2","w","curveLength","segment","length_5","length_6","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Slot_1","Bone_1","IkConstraint_1","TransformConstraint_1","PathConstraint_1","_updateCache","boneData","parent_1","slotData","Slot","ikConstraintsSorted","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","Color","updateCache","ikCount","ik","other","sortBone","constrained","parent_2","sortReset","slotBone","skin","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","attachments","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBounds","offset","POSITIVE_INFINITY","NEGATIVE_INFINITY","updateWorldVertices","min","SkeletonBounds","boundingBoxes","polygons","polygonPool","Pool","updateAabb","slotCount","BoundingBoxAttachment","boundingBox","polygon","obtain","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","indexOf","getWidth","getHeight","SkeletonData","animations","findEvent","eventDataName","findPathConstraintIndex","pathConstraintName","SkeletonData_1","BoneData_1","SlotData_1","Event_1","IkConstraintData_1","TransformConstraintData_1","Skin_1","EventData_1","Animation_1","SkeletonJson","attachmentLoader","linkedMeshes","readSkeletonData","json","root","JSON","parse","skeletonMap","hash","imagesPath","images","boneMap","parentName","getValue","slotMap","SlotData","setFromString","blendModeFromString","constraintMap","j","targetName","TransformConstraintData","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","setParentMesh","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","newRegionAttachment","box","newBoundingBoxAttachment","readVertices","newMeshAttachment","parent_3","inheritDeform","LinkedMesh","hullLength","newPathAttachment","newArray","toFloatArray","weights","timelineName","timelineMap","timeline","valueMap","readCurve","timelineScale","paths","deform","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","isNaN","toString","prop","defaultValue","str","BLEND_MODES","MULTIPLY","ADD","SCREEN","NORMAL","toLowerCase","dictionary","oldSkin","skinAttachment","attachmentTime","setAttachmentTime","getAttachmentTime","setFromColor","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","crop","trim","orig","_uvs","x0","y0","spineOffsetY","Texture_1","TextureAtlas","atlasText","textureLoader","callback","pages","regions","addSpineAtlas","addTexture","page","baseTexture","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","hasOwnProperty","substr","lastIndexOf","load","_this","reader","TextureAtlasReader","tuple","iterateParser","line","readLine","readTuple","parseInt","direction","readValue","hasLoaded","setFilters","log","resolution","Rectangle","frame2","clone","_updateUvs","findRegion","dispose","lines","split","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","arguments","TextureAtlasAttachmentLoader","atlas","Vector2","tm","tb","tc","td","bs","ts","by","hex","charAt","WHITE","RED","GREEN","BLUE","MAGENTA","ceil","cbrt","pow","radiansToDegrees","degreesToRadians","source","sourceStart","dest","destStart","numElements","array","oldSize","SUPPORTS_TYPED_ARRAYS","DebugUtils","logBones","instantiator","items","pop","free","item","clear","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Attachment","worldVertices","deformArray","v","skip","skeletonBones","wx","wy","vx","vy","weight","v_1","sourceAttachment","AttachmentType","Attachment_1","tempColor","premultipliedAlpha","w1","h1","w2","h2","pixiOffsetY","parentMesh","getParentMesh","AttachmentType_1","BoundingBoxAttachment_1","MeshAttachment_1","PathAttachment_1","RegionAttachment_1","__export","AnimationState_1","AnimationStateData_1","BlendMode_1","Skeleton_1","SkeletonBounds_1","SkeletonJson_1","TextureAtlas_1","TextureAtlasAttachmentLoader_1","atlasParser","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","replace","baseUrl","atlasOptions","crossOrigin","xhrType","loaders","Resource","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","imageLoaderAdapter","xhr","responseText","loader","namePrefix","syncImageLoaderAdapter","BaseTexture","fromImage","Loader","addPixiMiddleware","use","core","Spine_1"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import * as spine from \"./core\";\nimport {atlasParser} from \"./loaders\";\nimport {Attachment, VertexAttachment} from \"./core/attachments/Attachment\";\nimport {TextureAtlasRegion} from \"./core/TextureAtlas\";\nvar TransformBase = PIXI.TransformBase;\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\nlet tempRgb = [0, 0, 0];\n\nexport class SpineSprite extends PIXI.Sprite {\n    region: spine.TextureRegion;\n\n    constructor(tex: PIXI.Texture) {\n        super(tex);\n    }\n}\n\nexport class SpineMesh extends PIXI.mesh.Mesh {\n    region: spine.TextureRegion;\n\n    constructor(texture: PIXI.Texture, vertices?: ArrayLike<number>, uvs?: ArrayLike<number>, indices?: ArrayLike<number>, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport class Spine extends PIXI.Container {\n    static globalAutoUpdate: boolean = true;\n\n    tintRgb: ArrayLike<number>;\n    spineData: spine.SkeletonData;\n    skeleton: spine.Skeleton;\n    stateData: spine.AnimationStateData;\n    state: spine.AnimationState;\n    slotContainers: Array<PIXI.Container>;\n\n    constructor(spineData: spine.SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if ((typeof spineData) === \"string\") {\n            throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.skeleton = new spine.Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n\n        /**\n         * A spine AnimationStateData object created from the spine data passed in the constructor\n         *\n         * @member {object}\n         */\n        this.stateData = new spine.AnimationStateData(spineData);\n\n        /**\n         * A spine AnimationState object created from the spine AnimationStateData object\n         *\n         * @member {object}\n         */\n        this.state = new spine.AnimationState(this.stateData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            var slot = this.skeleton.slots[i];\n            var attachment : any = slot.attachment;\n            var slotContainer = new PIXI.Container();\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n\n            if (attachment instanceof spine.RegionAttachment) {\n                var spriteName = attachment.region.name;\n                var sprite = this.createSprite(slot, attachment);\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                var mesh = this.createMesh(slot, attachment);\n                slot.currentMesh = mesh;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            }\n            else {\n                continue;\n            }\n\n        }\n\n        /**\n         * Should the Spine object update its transforms\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof PIXI.spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof PIXI.spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n    }\n\n    set autoUpdate(value: boolean) {\n        this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return PIXI.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n        this.skeleton.updateWorldTransform();\n\n        let drawOrder = this.skeleton.drawOrder;\n        let slots = this.skeleton.slots;\n\n        for (var i = 0, n = drawOrder.length; i < n; i++) {\n            this.children[i] = this.slotContainers[drawOrder[i].data.index];\n        }\n\n        var r0 = this.tintRgb[0];\n        var g0 = this.tintRgb[1];\n        var b0 = this.tintRgb[2];\n\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slot = slots[i];\n            var attachment = slot.attachment;\n            var slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            var attColor = (attachment as any).color;\n            if (attachment instanceof spine.RegionAttachment) {\n                let region = (attachment as spine.RegionAttachment).region;\n                if (region) {\n                    let ar = region as TextureAtlasRegion;\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                        var spriteName = ar.name;\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        }\n                        else {\n                            var sprite = this.createSprite(slot, attachment);\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n                    }\n                }\n\n                if (slotContainer.transform) {\n                    var transform = slotContainer.transform;\n                    let lt : PIXI.Matrix;\n                    if (slotContainer.transform.matrix2d) {\n                        //gameofbombs pixi fork\n                        lt = transform.matrix2d;\n                        transform._dirtyVersion++;\n                        transform.version = transform._dirtyVersion;\n                        transform.isStatic = true;\n                        transform.operMode = 0;\n                    } else {\n                        if (TransformBase) {\n                            //PIXI v4.0\n                            if (transform.position) {\n                                transform = new PIXI.TransformBase();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                        } else {\n                            //PIXI v4.0rc\n                            if (!transform._dirtyLocal) {\n                                transform = new PIXI.TransformStatic();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                            transform._dirtyParentVersion = -1;\n                            transform._dirtyLocal = 1;\n                            transform._versionLocal = 1;\n                        }\n                    }\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                } else {\n                    //PIXI v3\n                    var lt = slotContainer.localTransform || new PIXI.Matrix();\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                    slotContainer.localTransform = lt;\n                    slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                }\n                tempRgb[0] = r0 * slot.color.r * attColor.r;\n                tempRgb[1] = g0 * slot.color.g * attColor.g;\n                tempRgb[2] = b0 * slot.color.b * attColor.b;\n                slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                slot.currentSprite.blendMode = slot.blendMode;\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                    var meshName = attachment.name;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                    }\n\n                    slot.meshes = slot.meshes || {};\n\n                    if (slot.meshes[meshName] !== undefined) {\n                        slot.meshes[meshName].visible = true;\n                    }\n                    else {\n                        var mesh = this.createMesh(slot, attachment);\n                        slotContainer.addChild(mesh);\n                    }\n\n                    slot.currentMesh = slot.meshes[meshName];\n                    slot.currentMeshName = meshName;\n                }\n                (attachment as VertexAttachment).computeWorldVertices(slot, slot.currentMesh.vertices);\n                if (PIXI.VERSION[0] !== '3') {\n                    // PIXI version 4\n                    // slot.currentMesh.dirty++;\n                    //only for PIXI v4\n                    var tintRgb = slot.currentMesh.tintRgb;\n                    tintRgb[0] = r0 * slot.color.r * attColor.r;\n                    tintRgb[1] = g0 * slot.color.g * attColor.g;\n                    tintRgb[2] = b0 * slot.color.b * attColor.b;\n                }\n                slot.currentMesh.blendMode = slot.blendMode;\n            }\n            else {\n                slotContainer.visible = false;\n                continue;\n            }\n            slotContainer.visible = true;\n\n            slotContainer.alpha = slot.color.a;\n        }\n    };\n\n    private setSpriteRegion(attachment: spine.RegionAttachment, sprite: SpineSprite, region: spine.TextureRegion) {\n        sprite.region = region;\n        sprite.texture = region.texture;\n        if (!region.size) {\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n        } else {\n            //hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: spine.MeshAttachment, mesh: SpineMesh, region: spine.TextureRegion) {\n        mesh.region = region;\n        mesh.texture = region.texture;\n        attachment.updateUVs(region, mesh.uvs);\n        // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n        // } else {\n            // PIXI version 3\n        mesh.dirty++;\n        // }\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (Spine.globalAutoUpdate) {\n            this.lastTime = this.lastTime || Date.now();\n            var timeDelta = (Date.now() - this.lastTime) * 0.001;\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        PIXI.Container.prototype.updateTransform.call(this);\n    };\n\n    /**\n     * Create a new sprite to be used with spine.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: spine.Slot, attachment: spine.RegionAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        var texture = region.texture;\n        var sprite = new SpineSprite(texture);\n        sprite.rotation = attachment.rotation * spine.MathUtils.degRad;\n        sprite.anchor.x = 0.5;\n        sprite.anchor.y = 0.5;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        sprite.region = attachment.region;\n        this.setSpriteRegion(attachment, sprite, attachment.region);\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[attachment.name] = sprite;\n        return sprite;\n    };\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: spine.Slot, attachment: spine.MeshAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        let strip = new SpineMesh(\n            region.texture,\n            new Float32Array(attachment.regionUVs.length),\n            new Float32Array(attachment.regionUVs.length),\n            new Uint16Array(attachment.triangles),\n            PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n        strip.canvasPadding = 1.5;\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        this.setMeshRegion(attachment, strip, region);\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.name] = strip;\n        return strip;\n    };\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var slot = this.skeleton.slots[slotIndex];\n        if (!slot) {\n            return false;\n        }\n        var attachment: any = slot.attachment;\n        var region: spine.TextureRegion = attachment.region;\n        if (texture) {\n            region = new spine.TextureRegion();\n            region.texture = texture;\n            region.size = size;\n        }\n        if (slot.currentSprite && slot.currentSprite.region != region) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n            slot.currentSprite.region = region;\n        } else\n        if (slot.currentMesh && slot.currentMesh.region != region) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        } else {\n            slot.tempRegion = region;\n            slot.tempAttachment = attachment;\n        }\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName = function (slotName: String, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var index = this.skeleton.findSlotIndex(slotName);\n        if (index == -1) {\n            return false;\n        }\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n}\n\nfunction SlotContainerUpdateTransformV3() {\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n}\n","import {Event} from \"./Event\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Utils, MathUtils, Color} from \"./Utils\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {VertexAttachment, Attachment} from \"./attachments\";\nimport {Slot} from \"./Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Animation {\n    name: string;\n    timelines: Array<Timeline>;\n    duration: number;\n\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n    }\n\n    mix (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        let timelines = this.timelines;\n        for (let i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n    }\n\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n        if (high == 0) return step;\n        let current = high >>> 1;\n        while (true) {\n            if (values[(current + 1) * step] <= target)\n                low = current + 1;\n            else\n                high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step)\n            if (values[i] > target) return i;\n        return -1;\n    }\n}\n\nexport interface Timeline {\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    constructor (frameCount: number) {\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    getFrameCount () {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    setLinear (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    setStepped (frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    getCurveType (frameIndex: number): number {\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        let type = this.curves[index];\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let curves = this.curves;\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx, y = dfy;\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    getCurvePercent (frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        let curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        let type = curves[i];\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number, prevY: number;\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        let y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\n}\n\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n            let amount = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent((frame >> 1) - 1,\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let amount = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (prevRotation + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n}\n\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n    static X = 1; static Y = 2;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length + TranslateTimeline.PREV_X] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length + TranslateTimeline.PREV_Y] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n        let prevX = frames[frame + TranslateTimeline.PREV_X];\n        let prevY = frames[frame + TranslateTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n        bone.x += (bone.data.x + prevX + (frames[frame + TranslateTimeline.X] - prevX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevY + (frames[frame + TranslateTimeline.Y] - prevY) * percent - bone.y) * alpha;\n    }\n}\n\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length + ScaleTimeline.PREV_X] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length + ScaleTimeline.PREV_Y] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n        let prevX = frames[frame + ScaleTimeline.PREV_X];\n        let prevY = frames[frame + ScaleTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n        bone.scaleX += (bone.data.scaleX * (prevX + (frames[frame + ScaleTimeline.X] - prevX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevY + (frames[frame + ScaleTimeline.Y] - prevY) * percent) - bone.scaleY) * alpha;\n    }\n}\n\nexport class ShearTimeline extends TranslateTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let bone = skeleton.bones[this.boneIndex];\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n            bone.shearX += (bone.data.shearX + frames[frames.length + ShearTimeline.PREV_X] - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY + frames[frames.length + ShearTimeline.PREV_Y] - bone.shearY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n        let prevX = frames[frame + ShearTimeline.PREV_X];\n        let prevY = frames[frame + ShearTimeline.PREV_Y];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n        bone.shearX += (bone.data.shearX + (prevX + (frames[frame + ShearTimeline.X] - prevX) * percent) - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + (prevY + (frames[frame + ShearTimeline.Y] - prevY) * percent) - bone.shearY) * alpha;\n    }\n}\n\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n    static R = 1; static G = 2; static B = 3; static A = 4;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let r = 0, g = 0, b = 0, a = 0;\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        let color: Color = skeleton.slots[this.slotIndex].color;\n        if (alpha < 1)\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        else\n            color.set(r, g, b, a);\n    }\n}\n\nexport class AttachmentTimeline implements Timeline {\n    slotIndex: number;\n    frames: ArrayLike<number> // time, ...\n    attachmentNames: Array<string>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameIndex = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        let attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex]\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nexport class EventTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    events: Array<Event>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > lastTime and <= time. */\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        if (firedEvents == null) return;\n        let frames = this.frames;\n        let frameCount = this.frames.length;\n\n        if (lastTime > time) { // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (lastTime < frames[0])\n            frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            let frameTime = frames[frame];\n            while (frame > 0) { // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++)\n            firedEvents.push(this.events[frame]);\n    }\n}\n\nexport class DrawOrderTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    drawOrders: Array<Array<number>>;\n\n    constructor (frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getFrameCount () {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe.\n     * @param drawOrder May be null to use bind pose draw order. */\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frame = frames.length - 1;\n        else\n            frame = Animation.binarySearch(frames, time) - 1;\n\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\n        let slots: Array<Slot> = skeleton.slots;\n        let drawOrderToSetupIndex = this.drawOrders[frame];\n        if (drawOrderToSetupIndex == null)\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\nexport class DeformTimeline extends CurveTimeline {\n    frames: ArrayLike<number>; // time, ...\n    frameVertices: Array<ArrayLike<number>>;\n    slotIndex: number;\n    attachment: VertexAttachment;\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let slot: Slot = skeleton.slots[this.slotIndex];\n        let slotAttachment: Attachment = slot.getAttachment();\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frameVertices = this.frameVertices;\n        let vertexCount = frameVertices[0].length;\n\n        let verticesArray: Array<number> = slot.attachmentVertices;\n        if (verticesArray.length != vertexCount) alpha = 1; // Don't mix from uninitialized slot vertices.\n        let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\n            let lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1) {\n                for (let i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else\n                Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time);\n        let prevVertices = frameVertices[frame - 1];\n        let nextVertices = frameVertices[frame];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha < 1) {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n}\n\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\n    static MIX = 1; static BEND_DIRECTION = 2;\n\n    ikConstraintIndex: number;\n    frames: ArrayLike<number>; // time, mix, bendDirection, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time, mix and bend direction of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n            constraint.bendDirection = Math.floor(frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\n    }\n}\n\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n    transformConstraintIndex: number;\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + TransformConstraintTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + TransformConstraintTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i + TransformConstraintTimeline.PREV_SCALE] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i + TransformConstraintTimeline.PREV_SHEAR] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n        let rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n        let translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n        let scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n        let shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n        constraint.rotateMix += (rotate + (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent - constraint.shearMix) * alpha;\n    }\n}\n\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2; static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.position += (frames[i + PathConstraintPositionTimeline.PREV_VALUE] - constraint.position) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n        let position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n        constraint.position += (position + (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent - constraint.position) * alpha;\n    }\n}\n\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor (frameCount: number) {\n        super(frameCount);\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.spacing += (frames[i + PathConstraintSpacingTimeline.PREV_VALUE] - constraint.spacing) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n        let spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n        constraint.spacing += (spacing + (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent - constraint.spacing) * alpha;\n    }\n}\n\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n    static ROTATE = 1; static TRANSLATE = 2;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor (frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\n        let frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n            let i = frames.length;\n            constraint.rotateMix += (frames[i + PathConstraintMixTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i + PathConstraintMixTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n        let rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n        let translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n        let frameTime = frames[frame];\n        let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n            1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n        constraint.rotateMix += (rotate + (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\n            * alpha;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\nimport {MathUtils, Utils} from \"./Utils\";\nimport {Animation} from \"./Animation\";\nimport {AnimationStateData} from \"./AnimationStateData\";\nimport {Event} from \"./Event\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationState {\n    data: AnimationStateData;\n    tracks = new Array<TrackEntry>();\n    events = new Array<Event>();\n    timeScale = 1;\n\n    constructor (data: AnimationStateData = null) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n    }\n\n    update (delta: number) {\n        delta *= this.timeScale;\n        for (let i = 0; i < this.tracks.length; i++) {\n            let current = this.tracks[i];\n            if (current == null) continue;\n\n            let next = current.next;\n            if (next != null) {\n                let nextTime = current.lastTime - next.delay;\n                if (nextTime >= 0) {\n                    let nextDelta = delta * next.timeScale;\n                    next.time = nextTime + nextDelta; // For start event to see correct time.\n                    current.time += delta * current.timeScale; // For end event to see correct time.\n                    this.setCurrent(i, next);\n                    next.time -= nextDelta; // Prevent increasing time twice, below.\n                    current = next;\n                }\n            } else if (!current.loop && current.lastTime >= current.endTime) {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                this.clearTrack(i);\n                continue;\n            }\n\n            current.time += delta * current.timeScale;\n            if (current.previous != null) {\n                let previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n        }\n    }\n\n    apply (skeleton: Skeleton) {\n        let events = this.events;\n\n        for (let i = 0; i < this.tracks.length; i++) {\n            let current = this.tracks[i];\n            if (current == null) continue;\n\n            events.length = 0;\n\n            let time = current.time;\n            let lastTime = current.lastTime;\n            let endTime = current.endTime;\n            let loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            let previous = current.previous;\n            if (previous == null)\n                current.animation.mix(skeleton, lastTime, time, loop, events, current.mix);\n            else {\n                let previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                let alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1) {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, lastTime, time, loop, events, alpha);\n            }\n\n            for (let ii = 0, nn = events.length; ii < nn; ii++) {\n                let event = events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {\n                let count = MathUtils.toInt(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    }\n\n    clearTracks () {\n        for (let i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    }\n\n    clearTrack (trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        let current = this.tracks[trackIndex];\n        if (current == null) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n\n        this.freeAll(current);\n    }\n\n    freeAll (entry: TrackEntry) {\n        while (entry != null) {\n            let next = entry.next;\n            entry = next;\n        }\n    }\n\n    expandToIndex (index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.setArraySize(this.tracks, index - this.tracks.length + 1, null);\n        this.tracks.length = index + 1;\n        return null;\n    }\n\n    setCurrent (index: number, entry: TrackEntry) {\n        let current = this.expandToIndex(index);\n        if (current != null) {\n            let previous = current.previous;\n            current.previous = null;\n\n            if (entry.onEnd) entry.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0) {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous != null && current.mixTime / current.mixDuration < 0.5) {\n                    entry.previous = previous;\n                    previous = current;\n                } else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    }\n\n    /** @see #setAnimation(int, Animation, boolean) */\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\n        let current = this.expandToIndex(trackIndex);\n        if (current != null) this.freeAll(current.next);\n\n        let entry = new TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    }\n\n    /** {@link #addAnimation(int, Animation, boolean, float)} */\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    hasAnimation(animationName: string): boolean\n    {\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n    }\n\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        let entry = new TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        let last = this.expandToIndex(trackIndex);\n        if (last != null) {\n            while (last.next != null)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0) {\n            if (last != null)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** @return May be null. */\n    getCurrent (trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: boolean = false;\n    setAnimationByName (trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2: boolean = false;\n    addAnimationByName (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3: boolean = false;\n    hasAnimationByName (animationName: string): boolean\n    {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n        }\n        let animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n    }\n}\n\nexport class TrackEntry {\n    next: TrackEntry; previous: TrackEntry;\n    animation: Animation;\n    loop = false;\n    delay = 0; time = 0; lastTime = -1; endTime = 0; timeScale = 1;\n    mixTime = 0; mixDuration = 0;\n    mix = 1;\n\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    reset () {\n        this.next = null;\n        this.previous = null;\n        this.animation = null;\n        this.timeScale = 1;\n        this.lastTime = -1; // Trigger events on frame zero.\n        this.time = 0;\n    }\n\n    /** Returns true if the current time is greater than the end time, regardless of looping. */\n    isComplete () : boolean {\n        return this.time >= this.endTime;\n    }\n}\n","import {Animation} from \"./Animation\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationStateData {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = { };\n    defaultMix = 0;\n\n    constructor (skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n        this.skeletonData = skeletonData;\n    }\n\n    setMix (fromName: string, toName: string, duration: number) {\n        let from = this.skeletonData.findAnimation(fromName);\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\n        let to = this.skeletonData.findAnimation(toName);\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\n        this.setMixWith(from, to, duration);\n    }\n\n    setMixWith (from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error(\"from cannot be null.\");\n        if (to == null) throw new Error(\"to cannot be null.\");\n        let key = from.name + to.name;\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix (from: Animation, to: Animation) {\n        let key = from.name + to.name;\n        let value = this.animationToMixTime[key];\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport enum BlendMode {\n    Normal,\n    Additive,\n    Multiply,\n    Screen\n}\n","import {Updatable} from \"./Updatable\";\nimport {BoneData} from \"./BoneData\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils, Vector2} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Bone implements Updatable {\n    static yDown: boolean = false;\n    //be careful! Spine b,c is c,b in pixi matrix\n    matrix = new PIXI.Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0; y = 0; rotation = 0; scaleX = 0; scaleY = 0; shearX = 0; shearY = 0;\n    appliedRotation = 0;\n\n    worldSignX = 0; worldSignY = 0;\n\n    sorted = false;\n\n    /** @param parent May be null. */\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.appliedRotation = rotation;\n\n        let rotationY = rotation + 90 + shearY;\n        let la = MathUtils.cosDeg(rotation + shearX) * scaleX, lb = MathUtils.cosDeg(rotationY) * scaleY;\n        let lc = MathUtils.sinDeg(rotation + shearX) * scaleX, ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) { // Root bone.\n            let skeleton = this.skeleton;\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = MathUtils.signum(scaleX);\n            this.worldSignY = MathUtils.signum(scaleY);\n            return;\n        }\n\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * MathUtils.signum(scaleX);\n        this.worldSignY = parent.worldSignY * MathUtils.signum(scaleY);\n\n        if (this.data.inheritRotation && this.data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (this.data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\n                    let temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (this.data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\n                    let psx = parent.scaleX, psy = parent.scaleY;\n                    let za = cos * psx, zb = sin * psy, zc = sin * psx, zd = cos * psy;\n                    let temp = pa * za + pb * zc;\n                    pb = pb * zd - pa * zb;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pd * zd - pc * zb;\n                    pc = temp;\n\n                    if (psx >= 0) sin = -sin;\n                    temp = pa * cos + pb * sin;\n                    pb = pb * cos - pa * sin;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pd * cos - pc * sin;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (this.skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (this.skeleton.flipY !== Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    }\n\n    setToSetupPose () {\n        let data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX () {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY () {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX () {\n        return Math.sqrt(this.matrix.a * this.matrix.a + this.matrix.b * this.matrix.b) * this.worldSignX;\n    }\n\n    getWorldScaleY () {\n        return Math.sqrt(this.matrix.c * this.matrix.c + this.matrix.d * this.matrix.d) * this.worldSignY;\n    }\n\n    worldToLocalRotationX () {\n        let parent = this.parent;\n        if (parent == null) return this.rotation;\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d, a = this.matrix.a, c = this.matrix.b;\n        return Math.atan2(pa * c - pc * a, pd * a - pb * c) * MathUtils.radDeg;\n    }\n\n    worldToLocalRotationY () {\n        let parent = this.parent;\n        if (parent == null) return this.rotation;\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.b, pc = pm.c, pd = pm.d, b = this.matrix.c, d = this.matrix.d;\n        return Math.atan2(pa * d - pc * b, pd * b - pb * d) * MathUtils.radDeg;\n    }\n\n    rotateWorld (degrees: number) {\n        let m = this.matrix;\n        let a = this.matrix.a, b = m.c, c = m.b, d = m.d;\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n        m.a = cos * a - sin * c;\n        m.c = cos * b - sin * d;\n        m.b = sin * a + cos * c;\n        m.d = sin * b + cos * d;\n    }\n\n    /** Computes the local transform from the world transform. This can be useful to perform processing on the local transform\n     * after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some redundant information is lost by the world transform, such as -1,-1 scale versus 180 rotation. The computed local\n     * transform values may differ from the original values but are functionally the same. */\n    updateLocalTransform () {\n        let parent = this.parent;\n        let m = this.matrix;\n        if (parent == null) {\n            this.x = m.tx;\n            this.y = m.ty;\n            this.rotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.scaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.scaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            let det = m.a * m.d - m.b * m.c;\n            this.shearX = 0;\n            this.shearY = Math.atan2(m.a * m.c + m.b * m.d, det) * MathUtils.radDeg;\n            return;\n        }\n        let pm = parent.matrix;\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d;\n        let pid = 1 / (pa * pd - pb * pc);\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n        this.x = (dx * pd * pid - dy * pb * pid);\n        this.y = (dy * pa * pid - dx * pc * pid);\n        let ia = pid * pd;\n        let id = pid * pa;\n        let ib = pid * pb;\n        let ic = pid * pc;\n        let ra = ia * m.a - ib * m.b;\n        let rb = ia * m.c - ib * m.d;\n        let rc = id * m.b - ic * m.a;\n        let rd = id * m.d - ic * m.c;\n        this.shearX = 0;\n        this.scaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.scaleX > 0.0001) {\n            let det = ra * rd - rb * rc;\n            this.scaleY = det / this.scaleX;\n            this.shearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.rotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.scaleX = 0;\n            this.scaleY = Math.sqrt(rb * rb + rd * rd);\n            this.shearY = 0;\n            this.rotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n        this.appliedRotation = this.rotation;\n    }\n\n    worldToLocal (world: Vector2) {\n        let m = this.matrix;\n        let a = m.a, b = m.c, c = m.b, d = m.d;\n        let invDet = 1 / (a * d - b * c);\n        let x = world.x - m.tx, y = world.y - m.ty;\n        world.x = (x * d * invDet - y * b * invDet);\n        world.y = (y * a * invDet - x * c * invDet);\n        return world;\n    }\n\n    localToWorld (local: Vector2) {\n        let m = this.matrix;\n        let x = local.x, y = local.y;\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n        return local;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0; y = 0; rotation = 0; scaleX = 1; scaleY = 1; shearX = 0; shearY = 0;\n    inheritRotation = true; inheritScale = true;\n\n    constructor (index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n","import {EventData} from \"./EventData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Event {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n\n    constructor (time: number, data: EventData) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.time = time;\n        this.data = data;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class EventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Skeleton} from \"./Skeleton\";\nimport {MathUtils} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraint implements Updatable {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    mix = 1;\n    bendDirection = 0;\n\n    level = 0;\n\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let target = this.target;\n        let bones = this.bones;\n        switch (bones.length) {\n        case 1:\n            this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\n        let pp = bone.parent.matrix;\n        let id = 1 / (pp.a * pp.d - pp.b * pp.c);\n        let x = targetX - pp.tx, y = targetY - pp.ty;\n        let tx = (x * pp.d - y * pp.c) * id - bone.x, ty = (y * pp.a - x * pp.b) * id - bone.y;\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.shearX - bone.rotation;\n        if (bone.scaleX < 0) rotationIK += 180;\n        if (rotationIK > 180)\n            rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        bone.updateWorldTransformWith(bone.x, bone.y, bone.rotation + rotationIK * alpha, bone.scaleX, bone.scaleY, bone.shearX,\n            bone.shearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n            return;\n        }\n        let px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX;\n        let os1 = 0, os2 = 0, s2 = 0;\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else\n            os2 = 0;\n        let pm = parent.matrix;\n        let cx = child.x, cy = 0, cwx = 0, cwy = 0, a = pm.a, b = pm.c, c = pm.b, d = pm.d;\n        let u = Math.abs(psx - psy) <= 0.0001;\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pm.tx;\n            cwy = c * cx + pm.ty;\n        } else {\n            cy = child.y;\n            cwx = a * cx + b * cy + pm.tx;\n            cwy = c * cx + d * cy + pm.ty;\n        }\n        let pp = parent.parent;\n        let ppm = parent.parent.matrix;\n        a = ppm.a;\n        b = ppm.c;\n        c = ppm.b;\n        d = ppm.d;\n        let id = 1 / (a * d - b * c), x = targetX - ppm.tx, y = targetY - ppm.ty;\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n        x = cwx - ppm.tx;\n        y = cwy - ppm.ty;\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n        outer:\n        if (u) {\n            l2 *= psx;\n            let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            let c1 = -2 * bb * l1, c2 = bb - aa;\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                let r0 = q / c2, r1 = c / q;\n                let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            let minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;\n            let maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            x = l1 + a;\n            d = x * x;\n            if (d > maxDist) {\n                maxAngle = 0;\n                maxDist = d;\n                maxX = x;\n            }\n            x = l1 - a;\n            d = x * x;\n            if (d < minDist) {\n                minAngle = MathUtils.PI;\n                minDist = d;\n                minX = x;\n            }\n            let angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            y = b * Math.sin(angle);\n            d = x * x + y * y;\n            if (d < minDist) {\n                minAngle = angle;\n                minDist = d;\n                minX = x;\n                minY = y;\n            }\n            if (d > maxDist) {\n                maxAngle = angle;\n                maxDist = d;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        let os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.rotation;\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180)\n            a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.scaleX, parent.scaleY, 0, 0);\n        rotation = child.rotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.shearX) * s2 + os2 - rotation;\n        if (a2 > 180)\n            a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.scaleX, child.scaleY, child.shearX, child.shearY);\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class IkConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    mix = 1;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Slot} from \"./Slot\";\nimport {Skeleton} from \"./Skeleton\";\nimport {PathAttachment} from \"./attachments\";\nimport {Utils, MathUtils} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraint implements Updatable {\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\n\n    spaces = new Array<number>(); positions = new Array<number>();\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n    segments = new Array<number>();\n\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let attachment = this.target.getAttachment();\n        if (!(attachment instanceof PathAttachment)) return;\n\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\n        let translate = translateMix > 0, rotate = rotateMix > 0;\n        if (!translate && !rotate) return;\n\n        let data = this.data;\n        let spacingMode = data.spacingMode;\n        let lengthSpacing = spacingMode == SpacingMode.Length;\n        let rotateMode = data.rotateMode;\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n        let bones = this.bones;\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\n        let spacing = this.spacing;\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n;) {\n                let bone = bones[i];\n                let m = bone.matrix;\n                let length = bone.data.length, x = length * m.a, y = length * m.b;\n                length = Math.sqrt(x * x + y * y);\n                if (scale) lengths[i] = length;\n                spaces[++i] = lengthSpacing ? Math.max(0, length + spacing) : spacing;\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++)\n                spaces[i] = spacing;\n        }\n\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\n        let skeleton = this.target.bone.skeleton;\n        let skeletonX = skeleton.x, skeletonY = skeleton.y;\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n        let tip = rotateMode == RotateMode.Chain && offsetRotation == 0;\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            let bone = bones[i];\n            let m = bone.matrix;\n            m.tx += (boneX - skeletonX - bone.worldX) * translateMix;\n            m.ty += (boneY - skeletonY - bone.worldY) * translateMix;\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n            if (scale) {\n                let length = lengths[i];\n                if (length != 0) {\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n                    m.a *= s;\n                    m.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                let a = m.a, b = m.c, c = m.b, d = m.d, r = 0, cos = 0, sin = 0;\n                if (tangents)\n                    r = positions[p - 1];\n                else if (spaces[i + 1] == 0)\n                    r = positions[p + 2];\n                else\n                    r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a) - offsetRotation * MathUtils.degRad;\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    let length = bone.data.length;\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                }\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n            }\n        }\n    }\n\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\n        percentSpacing: boolean) {\n        let target = this.target;\n        let position = this.position;\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\n        let closed = path.closed;\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            let lengths = path.lengths;\n            curveCount -= closed ? 1 : 2;\n            let pathLength = lengths[curveCount];\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                let space = spaces[i];\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVerticesWith(target, 2, 4, world, 0);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (;; curve++) {\n                    let length = lengths[curve];\n                    if (p > length) continue;\n                    if (curve == 0)\n                        p /= length;\n                    else {\n                        let prev = lengths[curve - 1];\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);\n                        path.computeWorldVerticesWith(target, 0, 4, world, 4);\n                    } else\n                        path.computeWorldVerticesWith(target, curve * 6 + 2, 8, world, 0);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n                    tangents || (i > 0 && space == 0));\n            }\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);\n            path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);\n        }\n\n        // Curve lengths.\n        let curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++)\n                spaces[i] *= pathLength;\n        }\n\n        let segments = this.segments;\n        let curveLength = 0;\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            let space = spaces[i];\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (;; curve++) {\n                let length = curves[curve];\n                if (p > length) continue;\n                if (curve == 0)\n                    p /= length;\n                else {\n                    let prev = curves[curve - 1];\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (;; segment++) {\n                let length = segments[segment];\n                if (p > length) continue;\n                if (segment == 0)\n                    p /= length;\n                else {\n                    let prev = segments[segment - 1];\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n        return out;\n    }\n\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n        out: Array<number>, o: number, tangents: boolean) {\n        if (p == 0) p = 0.0001;\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number; spacing: number; rotateMix: number; translateMix: number;\n\n    constructor (name: string) {\n        this.name = name;\n    }\n}\n\nexport enum PositionMode {\n    Fixed, Percent\n}\n\nexport enum SpacingMode {\n    Length, Fixed, Percent\n}\n\nexport enum RotateMode {\n    Tangent, Chain, ChainScale\n}\n","import {Slot} from \"./Slot\";\nimport {Bone} from \"./Bone\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Color, Utils, Vector2} from \"./Utils\";\nimport {Skin} from \"./Skin\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Updatable} from \"./Updatable\";\nimport {Attachment, PathAttachment, RegionAttachment, MeshAttachment} from \"./attachments\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skeleton {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>; ikConstraintsSorted: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    flipX = false; flipY = false;\n    x = 0; y = 0;\n\n    constructor (data: SkeletonData) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            let boneData = data.bones[i];\n            let bone: Bone;\n            if (boneData.parent == null)\n                bone = new Bone(boneData, this, null);\n            else {\n                let parent = this.bones[boneData.parent.index];\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            let slotData = data.slots[i];\n            let bone = this.bones[slotData.boneData.index];\n            let slot = new Slot(slotData, bone);\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        this.ikConstraintsSorted = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            let ikConstraintData = data.ikConstraints[i];\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            let transformConstraintData = data.transformConstraints[i];\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            let pathConstraintData = data.pathConstraints[i];\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache () {\n        let updateCache = this._updateCache;\n        updateCache.length = 0;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].sorted = false;\n\n        // IK first, lowest hierarchy depth first.\n        let ikConstraints = this.ikConstraintsSorted;\n        ikConstraints.length = 0;\n        for (let i = 0; i < this.ikConstraints.length; i++)\n            ikConstraints.push(this.ikConstraints[i]);\n        let ikCount = ikConstraints.length;\n        for (let i = 0, level = 0, n = ikCount; i < n; i++) {\n            let ik = ikConstraints[i];\n            let bone = ik.bones[0].parent;\n            for (level = 0; bone != null; level++)\n                bone = bone.parent;\n            ik.level = level;\n        }\n        for (let i = 1, ii = 0; i < ikCount; i++) {\n            let ik = ikConstraints[i];\n            let level = ik.level;\n            for (ii = i - 1; ii >= 0; ii--) {\n                let other = ikConstraints[ii];\n                if (other.level < level) break;\n                ikConstraints[ii + 1] = other;\n            }\n            ikConstraints[ii + 1] = ik;\n        }\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            let target = constraint.target;\n            this.sortBone(target);\n\n            let constrained = constraint.bones;\n            let parent = constrained[0];\n            this.sortBone(parent);\n\n            updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            constrained[constrained.length - 1].sorted = true;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n\n            let slot = constraint.target;\n            let slotIndex = slot.data.index;\n            let slotBone = slot.bone;\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n            for (let ii = 0, nn = this.data.skins.length; ii < nn; ii++)\n                this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);\n\n            let attachment = slot.getAttachment();\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortBone(constrained[ii]);\n\n            updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n\n            this.sortBone(constraint.target);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortBone(constrained[ii]);\n\n            updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++)\n            this.sortBone(bones[i]);\n    }\n\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n        let attachments = skin.attachments[slotIndex];\n        if (!attachments) return;\n        for (let key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        let pathBones = (<PathAttachment>attachment).bones;\n        if (pathBones == null)\n            this.sortBone(slotBone);\n        else {\n            let bones = this.bones;\n            for (let i = 0; i < pathBones.length; i++) {\n                let boneIndex = pathBones[i];\n                this.sortBone(bones[boneIndex]);\n            }\n        }\n    }\n\n    sortBone (bone: Bone) {\n        if (bone.sorted) return;\n        let parent = bone.parent;\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset (bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform () {\n        let updateCache = this._updateCache;\n        for (let i = 0, n = updateCache.length; i < n; i++)\n            updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose () {\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.mix = constraint.data.mix;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            let data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            let data = constraint.data;\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose () {\n        let slots = this.slots;\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone () {\n        if (this.bones.length == 0) return null;\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.data.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName (skinName: string) {\n        let skin = this.data.findSkin(skinName);\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin (newSkin: Skin) {\n        if (newSkin != null) {\n            if (this.skin != null)\n                newSkin.attachAll(this, this.skin);\n            else {\n                let slots = this.slots;\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    let slot = slots[i];\n                    let name = slot.data.attachmentName;\n                    if (name != null) {\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    }\n\n    /** @return May be null. */\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n        if (this.skin != null) {\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment (slotName: string, attachmentName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null)\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw new Error(\"Slot not found: \" + slotName);\n    }\n\n    /** @return May be null. */\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let ikConstraint = ikConstraints[i];\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB. */\n    getBounds (offset: Vector2, size: Vector2) {\n        if (offset == null) throw new Error(\"offset cannot be null.\");\n        if (size == null) throw new Error(\"size cannot be null.\");\n        let drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            let slot = drawOrder[i];\n            let vertices: ArrayLike<number> = null;\n            let attachment = slot.getAttachment();\n            if (attachment instanceof RegionAttachment)\n                vertices = (<RegionAttachment>attachment).updateWorldVertices(slot, false);\n            else if (attachment instanceof MeshAttachment) //\n                vertices = (<MeshAttachment>attachment).updateWorldVertices(slot, true);\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 8) {\n                    let x = vertices[ii], y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update (delta: number) {\n        this.time += delta;\n    }\n}\n","import {Utils, Pool} from \"./Utils\";\nimport {Skeleton} from \"./Skeleton\";\nimport {BoundingBoxAttachment} from \"./attachments\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonBounds {\n    minX = 0; minY = 0; maxX = 0; maxY = 0;\n    boundingBoxes = new Array<BoundingBoxAttachment>();\n    polygons = new Array<ArrayLike<number>>();\n    private polygonPool = new Pool<ArrayLike<number>>(() => {\n        return Utils.newFloatArray(16);\n    });\n\n    update (skeleton: Skeleton, updateAabb: boolean) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        let boundingBoxes = this.boundingBoxes;\n        let polygons = this.polygons;\n        let polygonPool = this.polygonPool;\n        let slots = skeleton.slots;\n        let slotCount = slots.length;\n\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (let i = 0; i < slotCount; i++) {\n            let slot = slots[i];\n            let attachment = slot.getAttachment();\n            if (attachment instanceof BoundingBoxAttachment) {\n                let boundingBox = attachment as BoundingBoxAttachment;\n                boundingBoxes.push(boundingBox);\n\n                let polygon = polygonPool.obtain();\n                if (polygon.length != boundingBox.worldVerticesLength) {\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                }\n                polygons.push(polygon);\n                boundingBox.computeWorldVertices(slot, polygon);\n            }\n        }\n\n        if (updateAabb) this.aabbCompute();\n    }\n\n    aabbCompute () {\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            let polygon = polygons[i];\n            let vertices = polygon;\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                let x = vertices[ii];\n                let y = vertices[ii + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint (x: number, y: number) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        let m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        let x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton (bounds: SkeletonBounds) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    }\n\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n    containsPoint (x: number, y: number): BoundingBoxAttachment {\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++)\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n        return null;\n    }\n\n    /** Returns true if the polygon contains the point. */\n    containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\n        let vertices = polygon;\n        let nn = polygon.length;\n\n        let prevIndex = nn - 2;\n        let inside = false;\n        for (let ii = 0; ii < nn; ii += 2) {\n            let vertexY = vertices[ii + 1];\n            let prevY = vertices[prevIndex + 1];\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                let vertexX = vertices[ii];\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n        return inside;\n    }\n\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\n     * true. */\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n        let polygons = this.polygons;\n        for (let i = 0, n = polygons.length; i < n; i++)\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n        return null;\n    }\n\n    /** Returns true if the polygon contains any part of the line segment. */\n    intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\n        let vertices = polygon;\n        let nn = polygon.length;\n\n        let width12 = x1 - x2, height12 = y1 - y2;\n        let det1 = x1 * y2 - y1 * x2;\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n        for (let ii = 0; ii < nn; ii += 2) {\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\n            let det2 = x3 * y4 - y3 * x4;\n            let width34 = x3 - x4, height34 = y3 - y4;\n            let det3 = width12 * height34 - height12 * width34;\n            let x = (det1 * width34 - width12 * det2) / det3;\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                let y = (det1 * height34 - height12 * det2) / det3;\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n        return false;\n    }\n\n    /** Returns the polygon for the specified bounding box, or null. */\n    getPolygon (boundingBox: BoundingBoxAttachment) {\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n        let index = this.boundingBoxes.indexOf(boundingBox);\n        return index == -1 ? null : this.polygons[index];\n    }\n\n    getWidth () {\n        return this.maxX - this.minX;\n    }\n\n    getHeight () {\n        return this.maxY - this.minY;\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Animation} from \"./Animation\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData} from \"./PathConstraintData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonData {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    width: number; height: number;\n    version: string; hash: string; imagesPath: string;\n\n    findBone (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    findBoneIndex (boneName: string) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    }\n\n    findSlot (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    findSlotIndex (slotName: string) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    }\n\n    findSkin (skinName: string) {\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\n        let skins = this.skins;\n        for (let i = 0, n = skins.length; i < n; i++) {\n            let skin = skins[i];\n            if (skin.name == skinName) return skin;\n        }\n        return null;\n    }\n\n    findEvent (eventDataName: string) {\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n        let events = this.events;\n        for (let i = 0, n = events.length; i < n; i++) {\n            let event = events[i];\n            if (event.name == eventDataName) return event;\n        }\n        return null;\n    }\n\n    findAnimation (animationName: string) {\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\n        let animations = this.animations;\n        for (let i = 0, n = animations.length; i < n; i++) {\n            let animation = animations[i];\n            if (animation.name == animationName) return animation;\n        }\n        return null;\n    }\n\n    findIkConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findTransformConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraint (constraintName: string) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    findPathConstraintIndex (pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\n            if (pathConstraints[i].name == pathConstraintName) return i;\n        return -1;\n    }\n}\n","import {SkeletonData} from \"./SkeletonData\";\nimport {BoneData} from \"./BoneData\";\nimport {SlotData} from \"./SlotData\";\nimport {Event} from \"./Event\";\nimport {IkConstraintData} from \"./IkConstraintData\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {PathConstraintData, PositionMode, SpacingMode, RotateMode} from \"./PathConstraintData\";\nimport {Skin} from \"./Skin\";\nimport {EventData} from \"./EventData\";\nimport {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from \"./attachments\";\nimport {Utils, Color} from \"./Utils\";\nimport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nimport {BlendMode} from \"./BlendMode\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor (attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData (json: string | any ): SkeletonData {\n        let scale = this.scale;\n        let skeletonData = new SkeletonData();\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\n\n        // Skeleton\n        let skeletonMap = root.skeleton;\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                let boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n                }\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                data.inheritRotation = this.getValue(boneMap, \"inheritRotation\", true);\n                data.inheritScale = this.getValue(boneMap, \"inheritScale\", true);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                let slotMap = root.slots[i];\n                let slotName: string = slotMap.name;\n                let boneName: string = slotMap.bone;\n                let boneData = skeletonData.findBone(boneName);\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                let color: string = this.getValue(slotMap, \"color\", null);\n                if (color != null) data.color.setFromString(color);\n\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                let constraintMap = root.ik[i];\n                let data = new IkConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                let constraintMap = root.transform[i];\n                let data = new TransformConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                let constraintMap = root.path[i];\n                let data = new PathConstraintData(constraintMap.name);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    let boneName = constraintMap.bones[j];\n                    let bone = skeletonData.findBone(boneName);\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                    data.bones.push(bone);\n                }\n\n                let targetName: string = constraintMap.target;\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                data.position = this.getValue(constraintMap, \"position\", 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let skinName in root.skins) {\n                let skinMap = root.skins[skinName]\n                let skin = new Skin(skinName);\n                for (let slotName in skinMap) {\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                    let slotMap = skinMap[slotName];\n                    for (let entryName in slotMap) {\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            let linkedMesh = this.linkedMeshes[i];\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (let eventName in root.events) {\n                let eventMap = root.events[eventName];\n                let data = new EventData(eventName);\n                data.intValue = this.getValue(eventMap, \"int\", 0);\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\n                data.stringValue = this.getValue(eventMap, \"string\", null);\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (let animationName in root.animations) {\n                let animationMap = root.animations[animationName];\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string): Attachment {\n        let scale = this.scale;\n        name = this.getValue(map, \"name\", name);\n\n        let type = this.getValue(map, \"type\", \"region\");\n\n        switch (type) {\n            case \"region\": {\n                let path = this.getValue(map, \"path\", name);\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, \"x\", 0) * scale;\n                region.y = this.getValue(map, \"y\", 0) * scale;\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\n                region.rotation = this.getValue(map, \"rotation\", 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) region.color.setFromString(color);\n\n                return region;\n            }\n            case \"boundingbox\": {\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) box.color.setFromString(color);\n                return box;\n            }\n            //weightedmesh is deprecated but who cares\n            case \"weightedmesh\":\n            case \"skinnedmesh\":\n            case \"mesh\":\n            case \"linkedmesh\": {\n                let path = this.getValue(map, \"path\", name);\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                let color = this.getValue(map, \"color\", null);\n                if (color != null) mesh.color.setFromString(color);\n\n                let parent: string = this.getValue(map, \"parent\", null);\n                if (parent != null) {\n                    mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\n                    return mesh;\n                }\n\n                let uvs: Array<number> = map.uvs;\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = uvs;\n                // mesh.updateUVs();\n\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                return mesh;\n            }\n            case \"path\": {\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\n                if (path == null) return null;\n                path.closed = this.getValue(map, \"closed\", false);\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\n                let vertexCount = map.vertexCount;\n                this.readVertices(map, path, vertexCount << 1);\n\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n                for (let i = 0; i < map.lengths.length; i++)\n                    lengths[i++] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                let color: string = this.getValue(map, \"color\", null);\n                if (color != null) path.color.setFromString(color);\n                return path;\n            }\n        }\n        return null;\n    }\n\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n        let scale = this.scale;\n        attachment.worldVerticesLength = verticesLength;\n        let vertices: Array<number> = map.vertices;\n        if (verticesLength == vertices.length) {\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++)\n                    vertices[i] *= scale;\n            }\n            attachment.vertices = Utils.toFloatArray(vertices);\n            return;\n        }\n        let weights = new Array<number>();\n        let bones = new Array<number>();\n        for (let i = 0, n = vertices.length; i < n;) {\n            let boneCount = vertices[i++];\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\n        let scale = this.scale;\n        let timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (let slotName in map.slots) {\n                let slotMap = map.slots[slotName];\n                let slotIndex = skeletonData.findSlotIndex(slotName);\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                for (let timelineName in slotMap) {\n                    let timelineMap = slotMap[timelineName];\n                    if (timelineName == \"color\") {\n                        let timeline = new ColorTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let color = new Color();\n                            color.setFromString(valueMap.color);\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n\n                    } else if (timelineName = \"attachment\") {\n                        let timeline = new AttachmentTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (let boneName in map.bones) {\n                let boneMap = map.bones[boneName];\n                let boneIndex = skeletonData.findBoneIndex(boneName);\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                for (let timelineName in boneMap) {\n                    let timelineMap = boneMap[timelineName];\n                    if (timelineName === \"rotate\") {\n                        let timeline = new RotateTimeline(timelineMap.length);\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"scale\")\n                            timeline = new ScaleTimeline(timelineMap.length);\n                        else if (timelineName === \"shear\")\n                            timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n\n                    } else\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (let constraintName in map.ik) {\n                let constraintMap = map.ik[constraintName];\n                let constraint = skeletonData.findIkConstraint(constraintName);\n                let timeline = new IkConstraintTimeline(constraintMap.length);\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (let constraintName in map.transform) {\n                let constraintMap = map.transform[constraintName];\n                let constraint = skeletonData.findTransformConstraint(constraintName);\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n                for (let i = 0; i < constraintMap.length; i++) {\n                    let valueMap = constraintMap[i];\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration,\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.paths) {\n            for (let constraintName in map.paths) {\n                let constraintMap = map.paths[constraintName];\n                let index = skeletonData.findPathConstraintIndex(constraintName);\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                let data = skeletonData.pathConstraints[index];\n                for (let timelineName in constraintMap) {\n                    let timelineMap = constraintMap[timelineName];\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n                        if (timelineName === \"spacing\") {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === \"mix\") {\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            let valueMap = timelineMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                                this.getValue(valueMap, \"translateMix\", 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration,\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (let deformName in map.deform) {\n                let deformMap = map.deform[deformName];\n                let skin = skeletonData.findSkin(deformName);\n                if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                for (let slotName in deformMap) {\n                    let slotMap = deformMap[slotName];\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                    for (let timelineName in slotMap) {\n                        let timelineMap = slotMap[timelineName];\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                        let weighted = attachment.bones != null;\n                        let vertices = attachment.vertices;\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n                        let timeline = new DeformTimeline(timelineMap.length);\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            let valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\n                            if (verticesValue == null)\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\n                                        deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++)\n                                        deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\n            let slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                let drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0, unchangedIndex = 0;\n                    for (let i = 0; i < offsets.length; i++) {\n                        let offsetMap = offsets[i];\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--)\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            let timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n            for (let i = 0; i < map.events.length; i++) {\n                let eventMap = map.events[i];\n                let eventData = skeletonData.findEvent(eventMap.name);\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                let event = new Event(eventMap.time, eventData);\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error(\"Error while parsing animation, duration is NaN\");\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.curve) return;\n        if (map.curve === \"stepped\")\n            timeline.setStepped(frameIndex);\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n            let curve: Array<number> = map.curve;\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n    }\n\n    getValue (map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString (str: string): number {\n        if (str === 'multiply') return PIXI.BLEND_MODES.MULTIPLY;\n        if (str === 'additive') return PIXI.BLEND_MODES.ADD;\n        if (str === 'screen') return PIXI.BLEND_MODES.SCREEN;\n        if (str === 'normal') return PIXI.BLEND_MODES.NORMAL;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"fixed\") return PositionMode.Fixed;\n        if (str == \"percent\") return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"length\") return SpacingMode.Length;\n        if (str == \"fixed\") return SpacingMode.Fixed;\n        if (str == \"percent\") return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString (str: string) {\n        str = str.toLowerCase();\n        if (str == \"tangent\") return RotateMode.Tangent;\n        if (str == \"chain\") return RotateMode.Chain;\n        if (str == \"chainscale\") return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string; skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n    }\n}\n","import {Attachment} from \"./attachments\";\nimport {Skeleton} from \"./Skeleton\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Skin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n\n    addAttachment (slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\n        let attachments = this.attachments;\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** @return May be null. */\n    getAttachment (slotIndex: number, name: string): Attachment {\n        let dictionary = this.attachments[slotIndex];\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            let slot = skeleton.slots[i];\n            let slotAttachment = slot.getAttachment();\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                let dictionary = oldSkin.attachments[slotIndex];\n                for (let key in dictionary) {\n                    let skinAttachment:Attachment = dictionary[key];\n                    if (slotAttachment == skinAttachment) {\n                        let attachment = this.getAttachment(slotIndex, key);\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import {Attachment} from \"./attachments\";\nimport {SlotData} from \"./SlotData\";\nimport {Bone} from \"./Bone\";\nimport {Color} from \"./Utils\";\nimport {TextureRegion} from \"./Texture\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class Slot {\n    //this is for PIXI\n    currentMesh: any;\n    currentSprite: any;\n    meshes: any;\n    currentMeshName: String;\n    sprites: any;\n    currentSpriteName: String;\n    blendMode: number;\n    //assign hack region a bit later\n    tempRegion: TextureRegion;\n    tempAttachment: Attachment;\n\n    //canon\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentVertices = new Array<number>();\n\n    constructor (data: SlotData, bone: Bone) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (bone == null) throw new Error(\"bone cannot be null.\");\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.blendMode = data.blendMode;\n        this.setToSetupPose();\n    }\n\n    /** @return May be null. */\n    getAttachment (): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment (attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    }\n\n    setAttachmentTime (time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime (): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose () {\n        this.color.setFromColor(this.data.color);\n        if (this.data.attachmentName == null)\n            this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n","import {BoneData} from \"./BoneData\";\nimport {Color} from \"./Utils\";\nimport {BlendMode} from \"./BlendMode\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class SlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    attachmentName: string;\n    blendMode: number;\n\n    constructor (index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n","export abstract class Texture {\n    protected _image: HTMLImageElement;\n\n    constructor (image: HTMLImageElement) {\n        this._image = image;\n    }\n\n    getImage (): HTMLImageElement {\n        return this._image;\n    }\n\n    abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n    abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n    abstract dispose (): void;\n\n\n    public static filterFromString (text: string): TextureFilter {\n        switch (text.toLowerCase()) {\n            case \"nearest\": return TextureFilter.Nearest;\n            case \"linear\": return TextureFilter.Linear;\n            case \"mipmap\": return TextureFilter.MipMap;\n            case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n            case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n            case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n            case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n            default: throw new Error(`Unknown texture filter ${text}`);\n        }\n    }\n\n    public static wrapFromString (text: string): TextureWrap {\n        switch (text.toLowerCase()) {\n            case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n            case \"clamptoedge\": return TextureWrap.ClampToEdge;\n            case \"repeat\": return TextureWrap.Repeat;\n            default: throw new Error(`Unknown texture wrap ${text}`);\n        }\n    }\n}\n\nexport enum TextureFilter {\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\n    Linear = 9729, // WebGLRenderingContext.LINEAR\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\nexport enum TextureWrap {\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\n}\n\nexport class TextureRegion {\n    texture: PIXI.Texture;\n\n    //thats for overrides\n    size: PIXI.Rectangle = null;\n\n    get width(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            return tex.crop.width;\n        }\n        if (tex.trim) {\n            return tex.trim.width;\n        }\n        return tex.orig.width;\n    }\n\n    get height(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            return tex.crop.height;\n        }\n        if (tex.trim) {\n            return tex.trim.height;\n        }\n        return tex.orig.height;\n    }\n\n    get u(): number {\n        return this.texture._uvs.x0;\n    }\n\n    get v(): number {\n        return this.texture._uvs.y0;\n    }\n\n    get u2(): number {\n        return this.texture._uvs.x2;\n    }\n\n    get v2(): number {\n        return this.texture._uvs.y2;\n    }\n\n    get offsetX(): number {\n        const tex = this.texture;\n        return tex.trim ? tex.trim.x : 0;\n    }\n\n    get offsetY(): number {\n        console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n        return this.spineOffsetY;\n    }\n\n    get pixiOffsetY(): number {\n        const tex = this.texture;\n        return tex.trim ? tex.trim.y : 0;\n    }\n\n    get spineOffsetY(): number {\n        var tex = this.texture;\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n    }\n\n    get originalWidth(): number {\n        var tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.crop.width;\n        }\n        return tex.orig.width;\n    }\n\n    get originalHeight(): number {\n        const tex = this.texture;\n        if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.crop.height;\n        }\n        return tex.orig.height;\n    }\n\n    get x(): number {\n        return this.texture.frame.x;\n    }\n\n    get y(): number {\n        return this.texture.frame.y;\n    }\n\n    get rotate(): boolean {\n        return this.texture.rotate !== 0;\n    }\n}\n","import {Disposable, Map} from \"./Utils\";\nimport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TextureAtlas implements Disposable {\n    pages = new Array<TextureAtlasPage>();\n    regions = new Array<TextureAtlasRegion>();\n\n    constructor(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (atlasText) {\n            this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n    }\n\n    addTexture(name: string, texture: PIXI.Texture) {\n        let pages = this.pages;\n        let page: TextureAtlasPage = null;\n        for (var i=0;i<pages.length;i++) {\n            if (pages[i].baseTexture === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new TextureAtlasPage();\n            page.name = 'texturePage';\n            var baseTexture = texture.baseTexture;\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.baseTexture = baseTexture;\n            //those fields are not relevant in Pixi\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\n            page.uWrap = TextureWrap.ClampToEdge;\n            page.vWrap = TextureWrap.ClampToEdge;\n            pages.push(page);\n        }\n        var region = new TextureAtlasRegion();\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n        return region;\n    }\n\n    addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\n        for (var key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    }\n\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\n        return this.load(atlasText, textureLoader, callback);\n    }\n\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (textureLoader == null)\n            throw new Error(\"textureLoader cannot be null.\");\n\n        let reader = new TextureAtlasReader(atlasText);\n        let tuple = new Array<string>(4);\n        let page: TextureAtlasPage = null;\n\n        let iterateParser = () => {\n            while (true) {\n                let line = reader.readLine();\n                if (line == null) {\n                    return callback && callback(this);\n                }\n                line = line.trim();\n                if (line.length == 0)\n                    page = null;\n                else if (!page) {\n                    page = new TextureAtlasPage();\n                    page.name = line;\n\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                        page.width = parseInt(tuple[0]);\n                        page.height = parseInt(tuple[1]);\n                        reader.readTuple(tuple);\n                    }\n                    // page.format = Format[tuple[0]]; we don't need format in WebGL\n\n                    reader.readTuple(tuple);\n                    page.minFilter = Texture.filterFromString(tuple[0]);\n                    page.magFilter = Texture.filterFromString(tuple[1]);\n\n                    let direction = reader.readValue();\n                    page.uWrap = TextureWrap.ClampToEdge;\n                    page.vWrap = TextureWrap.ClampToEdge;\n                    if (direction == \"x\")\n                        page.uWrap = TextureWrap.Repeat;\n                    else if (direction == \"y\")\n                        page.vWrap = TextureWrap.Repeat;\n                    else if (direction == \"xy\")\n                        page.uWrap = page.vWrap = TextureWrap.Repeat;\n\n                    textureLoader(line, (texture: PIXI.BaseTexture) => {\n                        page.baseTexture = texture;\n                        if (!texture.hasLoaded) {\n                            texture.width = page.width;\n                            texture.height = page.height;\n                        }\n                        this.pages.push(page);\n                        page.setFilters();\n\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                            }\n                        }\n                        iterateParser();\n                    });\n                    this.pages.push(page);\n                    break;\n                } else {\n                    let region: TextureAtlasRegion = new TextureAtlasRegion();\n                    region.name = line;\n                    region.page = page;\n\n                    let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\n\n                    reader.readTuple(tuple);\n                    let x = parseInt(tuple[0]);\n                    let y = parseInt(tuple[1]);\n\n                    reader.readTuple(tuple);\n                    let width = parseInt(tuple[0]);\n                    let height = parseInt(tuple[1]);\n\n                    let resolution = page.baseTexture.resolution;\n                    x /= resolution;\n                    y /= resolution;\n                    width /= resolution;\n                    height /= resolution;\n\n                    let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                    if (reader.readTuple(tuple) == 4) { // split is optional\n                        // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                            //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                            reader.readTuple(tuple);\n                        }\n                    }\n\n                    let originalWidth = parseInt(tuple[0]) / resolution;\n                    let originalHeight = parseInt(tuple[1]) / resolution;\n                    reader.readTuple(tuple);\n                    let offsetX = parseInt(tuple[0]) / resolution;\n                    let offsetY = parseInt(tuple[1]) / resolution;\n\n                    let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                    let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                    //TODO: pixiv3 uses different frame/crop/trim\n\n                    if (PIXI.VERSION[0] == '4') {\n                        // pixi v4.0.0\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                    } else {\n                        // pixi v3.0.11\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\n                        var crop = frame2.clone();\n                        trim.width = originalWidth;\n                        trim.height = originalHeight;\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                    }\n\n                    region.index = parseInt(reader.readValue());\n                    region.texture._updateUvs();\n\n                    this.regions.push(region);\n                }\n            }\n        }\n\n        iterateParser();\n    }\n\n    findRegion(name: string): TextureAtlasRegion {\n        for (let i = 0; i < this.regions.length; i++) {\n            if (this.regions[i].name == name) {\n                return this.regions[i];\n            }\n        }\n        return null;\n    }\n\n    dispose() {\n        for (let i = 0; i < this.pages.length; i++) {\n            this.pages[i].baseTexture.dispose();\n        }\n    }\n}\n\nclass TextureAtlasReader {\n    lines: Array<string>;\n    index: number = 0;\n\n    constructor(text: string) {\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n    }\n\n    readLine(): string {\n        if (this.index >= this.lines.length)\n            return null;\n        return this.lines[this.index++];\n    }\n\n    readValue(): string {\n        let line = this.readLine();\n        let colon = line.indexOf(\":\");\n        if (colon == -1)\n            throw new Error(\"Invalid line: \" + line);\n        return line.substring(colon + 1).trim();\n    }\n\n    readTuple(tuple: Array<string>): number {\n        let line = this.readLine();\n        let colon = line.indexOf(\":\");\n        if (colon == -1)\n            throw new Error(\"Invalid line: \" + line);\n        let i = 0, lastMatch = colon + 1;\n        for (; i < 3; i++) {\n            let comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) break;\n            tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n            lastMatch = comma + 1;\n        }\n        tuple[i] = line.substring(lastMatch).trim();\n        return i + 1;\n    }\n}\n\nexport class TextureAtlasPage {\n    name: string;\n    minFilter: TextureFilter;\n    magFilter: TextureFilter;\n    uWrap: TextureWrap;\n    vWrap: TextureWrap;\n    baseTexture: PIXI.BaseTexture;\n    width: number;\n    height: number;\n\n    public setFilters() {\n        let tex = this.baseTexture;\n        let filter = this.minFilter;\n        if (filter == TextureFilter.Linear) {\n            tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n        } else if (this.minFilter == TextureFilter.Nearest) {\n            tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        } else {\n            tex.mipmap = true;\n            if (filter == TextureFilter.MipMapNearestNearest) {\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n            } else {\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n            }\n        }\n    }\n}\n\nexport class TextureAtlasRegion extends TextureRegion {\n    page: TextureAtlasPage;\n    name: string;\n    index: number;\n}\n","import {Skin} from \"./Skin\";\nimport {AttachmentLoader, BoundingBoxAttachment, MeshAttachment, PathAttachment, RegionAttachment} from \"./attachments\";\nimport {TextureAtlas} from \"./TextureAtlas\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TextureAtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor (atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n        let attachment = new RegionAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment (skin: Skin, name: string, path: string) : MeshAttachment {\n        let region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n        let attachment = new MeshAttachment(name);\n        attachment.region = region;\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment (skin: Skin, name: string) : BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment (skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n}\n","import {Updatable} from \"./Updatable\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {Vector2, MathUtils} from \"./Utils\";\nimport {Skeleton} from \"./Skeleton\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraint implements Updatable {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    temp = new Vector2();\n\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply () {\n        this.update();\n    }\n\n    update () {\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n        let target = this.target;\n        let tm = target.matrix;\n        let ta = tm.a, tb = tm.c, tc = tm.b, td = tm.d;\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            let m = bone.matrix;\n\n            if (rotateMix > 0) {\n                let a = m.a, b = m.c, c = m.b, d = m.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + this.data.offsetRotation * MathUtils.degRad;\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                let cos = Math.cos(r), sin = Math.sin(r);\n                m.a = cos * a - sin * c;\n                m.c = cos * b - sin * d;\n                m.b = sin * a + cos * c;\n                m.d = sin * b + cos * d;\n            }\n\n            if (translateMix > 0) {\n                let temp = this.temp;\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                m.tx += (temp.x - bone.worldX) * translateMix;\n                m.ty += (temp.y - bone.worldY) * translateMix;\n            }\n\n            if (scaleMix > 0) {\n                let bs = Math.sqrt(m.a * m.a + m.b * m.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n                let s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleX) * scaleMix) / bs : 0;\n                m.a *= s;\n                m.b *= s;\n                bs = Math.sqrt(m.c * m.c + m.d * m.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleY) * scaleMix) / bs : 0;\n                m.c *= s;\n                m.d *= s;\n            }\n\n            if (shearMix > 0) {\n                let b = m.c, d = m.d;\n                let by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(m.b, m.a));\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    r += MathUtils.PI2;\n                r = by + (r + this.data.offsetShearY * MathUtils.degRad) * shearMix;\n                let s = Math.sqrt(b * b + d * d);\n                m.c = Math.cos(r) * s;\n                m.d = Math.sin(r) * s;\n            }\n        }\n    }\n}\n","import {BoneData} from \"./BoneData\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class TransformConstraintData {\n    name: string;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n","import {Skeleton} from \"./Skeleton\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport interface Map<T> {\n    [key: string]: T;\n}\n\nexport interface Disposable {\n    dispose (): void;\n}\n\nexport class Color {\n    public static WHITE = new Color(1, 1, 1, 1);\n    public static RED = new Color(1, 0, 0, 1);\n    public static GREEN = new Color(0, 1, 0, 1);\n    public static BLUE = new Color(0, 0, 1, 1);\n    public static MAGENTA = new Color(1, 0, 1, 1);\n\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n    }\n\n    set (r: number, g: number, b: number, a: number) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.clamp();\n        return this;\n    }\n\n    setFromColor (c: Color) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n        return this;\n    }\n\n    setFromString (hex: string) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n        this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n        return this;\n    }\n\n    add (r: number, g: number, b: number, a: number) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n        this.clamp();\n        return this;\n    }\n\n    clamp () {\n        if (this.r < 0) this.r = 0;\n        else if (this.r > 1) this.r = 1;\n\n        if (this.g < 0) this.g = 0;\n        else if (this.g > 1) this.g = 1;\n\n        if (this.b < 0) this.b = 0;\n        else if (this.b > 1) this.b = 1;\n\n        if (this.a < 0) this.a = 0;\n        else if (this.a > 1) this.a = 1;\n        return this;\n    }\n}\n\nexport class MathUtils {\n    static PI = 3.1415927;\n    static PI2 = MathUtils.PI * 2;\n    static radiansToDegrees = 180 / MathUtils.PI;\n    static radDeg = MathUtils.radiansToDegrees;\n    static degreesToRadians = MathUtils.PI / 180;\n    static degRad = MathUtils.degreesToRadians;\n\n    static clamp (value: number, min: number, max: number) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n\n    static cosDeg (degrees: number) {\n        return Math.cos(degrees * MathUtils.degRad);\n    }\n\n    static sinDeg (degrees: number) {\n        return Math.sin(degrees * MathUtils.degRad);\n    }\n\n    static signum (value: number): number {\n        return value >= 0 ? 1 : -1;\n    }\n\n    static toInt (x: number) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n    }\n\n    static cbrt (x: number) {\n        var y = Math.pow(Math.abs(x), 1/3);\n        return x < 0 ? -y : y;\n    }\n}\n\nexport class Utils {\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n            dest[j] = source[i];\n        }\n    }\n\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n        let oldSize = array.length;\n        if (oldSize == size) return array;\n        array.length = size;\n        if (oldSize < size) {\n            for (let i = oldSize; i < size; i++) array[i] = value;\n        }\n        return array;\n    }\n\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\n        let array = new Array<T>(size);\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\n        return array;\n    }\n\n    static newFloatArray (size: number): ArrayLike<number> {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Float32Array(size)\n        } else {\n             let array = new Array<number>(size);\n             for (let i = 0; i < array.length; i++) array[i] = 0;\n             return array;\n        }\n    }\n\n    static toFloatArray (array: Array<number>) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n    }\n}\n\nexport class DebugUtils {\n    static logBones(skeleton: Skeleton) {\n        for (let i = 0; i < skeleton.bones.length; i++) {\n            let bone = skeleton.bones[i];\n            let m = bone.matrix;\n            console.log(bone.data.name + \", \" + m.a + \", \" + m.b + \", \" + m.c + \", \" + m.d + \", \" + m.tx + \", \" + m.ty);\n        }\n    }\n}\n\nexport class Pool<T> {\n    private items = new Array<T>();\n    private instantiator: () => T;\n\n    constructor (instantiator: () => T) {\n        this.instantiator = instantiator;\n    }\n\n    obtain () {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n    }\n\n    free (item: T) {\n        this.items.push(item);\n    }\n\n    freeAll (items: ArrayLike<T>) {\n        for (let i = 0; i < items.length; i++) this.items[i] = items[i];\n    }\n\n    clear () {\n        this.items.length = 0;\n    }\n}\n\nexport class Vector2 {\n    constructor (public x = 0, public y = 0) {\n    }\n\n    set (x: number, y: number): Vector2 {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n\n    length () {\n        let x = this.x;\n        let y = this.y;\n        return Math.sqrt(x * x + y * y);\n    }\n\n    normalize () {\n        let len = this.length();\n        if (len != 0) {\n            this.x /= len;\n            this.y /= len;\n        }\n        return this;\n    }\n}\n\nexport class TimeKeeper {\n    maxDelta = 0.064;\n    framesPerSecond = 0;\n    delta = 0;\n    totalTime = 0;\n\n    private lastTime = Date.now() / 1000;\n    private frameCount = 0;\n    private frameTime = 0;\n\n    update () {\n        var now = Date.now() / 1000;\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n\n        this.frameCount++;\n        if (this.frameTime > 1) {\n            this.framesPerSecond = this.frameCount / this.frameTime;\n            this.frameTime = 0;\n            this.frameCount = 0;\n        }\n    }\n}\n","import {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport abstract class Attachment {\n    name: string;\n\n    constructor (name: string) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n    }\n}\n\nexport abstract class VertexAttachment extends Attachment {\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n\n    constructor (name: string) {\n        super(name);\n    }\n\n    computeWorldVertices (slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVerticesWith (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number) {\n        count += offset;\n        let skeleton = slot.bone.skeleton;\n        let x = skeleton.x, y = skeleton.y;\n        let deformArray = slot.attachmentVertices;\n        let vertices = this.vertices;\n        let bones = this.bones;\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            let bone = slot.bone;\n            let m = bone.matrix;\n            x += m.tx;\n            y += m.ty;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            for (let v = start, w = offset; w < count; v += 2, w += 2) {\n                let vx = vertices[v], vy = vertices[v + 1];\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n            return;\n        }\n        let v = 0, skip = 0;\n        for (let i = 0; i < start; i += 2) {\n            let n = bones[v];\n            v += n + 1;\n            skip += n;\n        }\n        let skeletonBones = skeleton.bones;\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += 2) {\n                let wx = x, wy = y;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            let deform = deformArray;\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += 2) {\n                let wx = x, wy = y;\n                let n = bones[v++];\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    let bone = skeletonBones[bones[v]];\n                    let m = bone.matrix;\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n    applyDeform (sourceAttachment: VertexAttachment) {\n        return this == sourceAttachment;\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport enum AttachmentType {\n    Region, BoundingBox, Mesh, LinkedMesh, Path\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {Color} from \"../Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class BoundingBoxAttachment extends VertexAttachment {\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {TextureRegion} from \"../Texture\";\nimport {Color, Utils} from \"../Utils\";\nimport {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class MeshAttachment extends VertexAttachment {\n    region: TextureRegion;\n    path: string;\n    regionUVs: ArrayLike<number>;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    hullLength: number;\n    private parentMesh: MeshAttachment;\n    inheritDeform = false;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\n        return [];\n        //nothing\n    }\n\n    updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\n        let regionUVs = this.regionUVs;\n        let n = regionUVs.length;\n        if (!uvs || uvs.length != n) {\n            uvs = Utils.newFloatArray(n);\n        }\n\n        if (region == null) {\n            return;\n        }\n\n        let texture = region.texture;\n        let r = texture._uvs;\n        let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        let x = region.offsetX, y = region.pixiOffsetY;\n\n        for (let i = 0; i < n; i += 2) {\n            let u = this.regionUVs[i], v = this.regionUVs[i + 1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n\n        return uvs;\n    }\n\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n}\n","import {VertexAttachment} from \"./Attachment\";\nimport {Color} from \"../Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class PathAttachment extends VertexAttachment {\n    lengths: Array<number>;\n    closed = false; constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor (name: string) {\n        super(name);\n    }\n}\n","import {Attachment} from \"./Attachment\";\nimport {Color, Utils} from \"../Utils\";\nimport {TextureRegion} from \"../Texture\";\nimport {Slot} from \"../Slot\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class RegionAttachment extends Attachment {\n    x = 0; y = 0; scaleX = 1; scaleY = 1; rotation = 0; width = 0; height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    region: TextureRegion;\n\n    constructor (name:string) {\n        super(name);\n    }\n\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\n        return [];\n        //nothing\n    }\n}\n","export {Attachment, VertexAttachment} from \"./Attachment\";\nexport {AttachmentLoader} from \"./AttachmentLoader\";\nexport {AttachmentType} from \"./AttachmentType\";\nexport {BoundingBoxAttachment} from \"./BoundingBoxAttachment\";\nexport {MeshAttachment} from \"./MeshAttachment\";\nexport {PathAttachment} from \"./PathAttachment\";\nexport {RegionAttachment} from \"./RegionAttachment\";\n","export * from \"./attachments\";\n\nexport {\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\n    Animation, CurveTimeline\n} from \"./Animation\";\nexport {AnimationState} from \"./AnimationState\";\nexport {AnimationStateData} from \"./AnimationStateData\";\nexport {BlendMode} from \"./BlendMode\";\nexport {Bone} from \"./Bone\";\nexport {BoneData} from \"./BoneData\";\nexport {Event} from \"./Event\";\nexport {EventData} from \"./EventData\";\nexport {IkConstraint} from \"./IkConstraint\";\nexport {IkConstraintData} from \"./IkConstraintData\";\nexport {PathConstraint} from \"./PathConstraint\";\nexport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\nexport {Skeleton} from \"./Skeleton\";\nexport {SkeletonBounds} from \"./SkeletonBounds\";\nexport {SkeletonData} from \"./SkeletonData\";\nexport {SkeletonJson} from \"./SkeletonJson\";\nexport {Skin} from \"./Skin\";\nexport {Slot} from \"./Slot\";\nexport {SlotData} from \"./SlotData\";\nexport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\nexport {TextureAtlas, TextureAtlasRegion} from \"./TextureAtlas\";\nexport {TextureAtlasAttachmentLoader} from \"./TextureAtlasAttachmentLoader\";\nexport {TransformConstraint} from \"./TransformConstraint\";\nexport {TransformConstraintData} from \"./TransformConstraintData\";\nexport {Updatable} from \"./Updatable\";\nexport {Disposable, Map, Utils, Pool, MathUtils, Color, Vector2} from \"./Utils\";\n","import * as spine from \"./core\";\n\nexport function atlasParser() {\n    return function (resource: PIXI.loaders.Resource, next: () => any) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\n        if (metadataAtlas === false) {\n            return next();\n        }\n        if (metadataAtlas && metadataAtlas.pages) {\n            //its an atlas!\n            var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(metadataAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = metadataAtlas;\n\n            return next();\n        }\n\n        var metadataAtlasSuffix = '.atlas';\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n        //remove the baseUrl\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n        //remove the baseUrl\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function () {\n            new spine.TextureAtlas(this.xhr.responseText, adapter, function(spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n\n                next();\n            });\n        });\n    };\n}\n\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: String, callback: (baseTexture: PIXI.BaseTexture) => any) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\n            callback(resource.texture.baseTexture);\n        });\n    }\n}\n\nexport function syncImageLoaderAdapter (baseUrl: any, crossOrigin: any) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line: any, callback: any) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    }\n}\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n","import * as core from \"./core\";\nimport * as loaders from \"./loaders\";\n\nexport {core, loaders}\nexport {Spine, SpineMesh, SpineSprite} from \"./Spine\";\n"],"sourceRoot":"/source/"}